// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/clients/mithril/v1/mithril.proto

package mithril

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ProtocolMessagePartKey int32

const (
	SNAPSHOT_DIGEST                  ProtocolMessagePartKey = 0
	CARDANO_TRANSACTIONS_MERKLE_ROOT ProtocolMessagePartKey = 1
	NEXT_AGGREGATE_VERIFICATION_KEY  ProtocolMessagePartKey = 2
	LATEST_IMMUTABLE_FILE_NUMBER     ProtocolMessagePartKey = 3
)

var ProtocolMessagePartKey_name = map[int32]string{
	0: "SNAPSHOT_DIGEST",
	1: "CARDANO_TRANSACTIONS_MERKLE_ROOT",
	2: "NEXT_AGGREGATE_VERIFICATION_KEY",
	3: "LATEST_IMMUTABLE_FILE_NUMBER",
}

var ProtocolMessagePartKey_value = map[string]int32{
	"SNAPSHOT_DIGEST":                  0,
	"CARDANO_TRANSACTIONS_MERKLE_ROOT": 1,
	"NEXT_AGGREGATE_VERIFICATION_KEY":  2,
	"LATEST_IMMUTABLE_FILE_NUMBER":     3,
}

func (x ProtocolMessagePartKey) String() string {
	return proto.EnumName(ProtocolMessagePartKey_name, int32(x))
}

func (ProtocolMessagePartKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{0}
}

type SignedEntityType int32

const (
	MITHRIL_STAKE_DISTRIBUTION SignedEntityType = 0
	CARDANO_TRANSACTIONS       SignedEntityType = 1
)

var SignedEntityType_name = map[int32]string{
	0: "MITHRIL_STAKE_DISTRIBUTION",
	1: "CARDANO_TRANSACTIONS",
}

var SignedEntityType_value = map[string]int32{
	"MITHRIL_STAKE_DISTRIBUTION": 0,
	"CARDANO_TRANSACTIONS":       1,
}

func (x SignedEntityType) String() string {
	return proto.EnumName(SignedEntityType_name, int32(x))
}

func (SignedEntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{1}
}

type CertificateSignature int32

const (
	GENESIS_SIGNATURE CertificateSignature = 0
	MULTI_SIGNATURE   CertificateSignature = 1
)

var CertificateSignature_name = map[int32]string{
	0: "GENESIS_SIGNATURE",
	1: "MULTI_SIGNATURE",
}

var CertificateSignature_value = map[string]int32{
	"GENESIS_SIGNATURE": 0,
	"MULTI_SIGNATURE":   1,
}

func (x CertificateSignature) String() string {
	return proto.EnumName(CertificateSignature_name, int32(x))
}

func (CertificateSignature) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{2}
}

type Height struct {
	// the immutable file number
	MithrilHeight uint64 `protobuf:"varint,1,opt,name=mithril_height,json=mithrilHeight,proto3" json:"mithril_height,omitempty"`
}

func (m *Height) Reset()      { *m = Height{} }
func (*Height) ProtoMessage() {}
func (*Height) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{0}
}
func (m *Height) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Height) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Height.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Height) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Height.Merge(m, src)
}
func (m *Height) XXX_Size() int {
	return m.Size()
}
func (m *Height) XXX_DiscardUnknown() {
	xxx_messageInfo_Height.DiscardUnknown(m)
}

var xxx_messageInfo_Height proto.InternalMessageInfo

type ClientState struct {
	// Chain id
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Latest height the client was updated to
	LatestHeight *Height `protobuf:"bytes,2,opt,name=latest_height,json=latestHeight,proto3" json:"latest_height,omitempty"`
	// Block height when the client was frozen due to a misbehaviour
	FrozenHeight *Height `protobuf:"bytes,3,opt,name=frozen_height,json=frozenHeight,proto3" json:"frozen_height,omitempty"`
	// Epoch number of current chain state
	CurrentEpoch       uint64                     `protobuf:"varint,4,opt,name=current_epoch,json=currentEpoch,proto3" json:"current_epoch,omitempty"`
	TrustingPeriod     uint64                     `protobuf:"varint,5,opt,name=trusting_period,json=trustingPeriod,proto3" json:"trusting_period,omitempty"`
	ProtocolParameters *MithrilProtocolParameters `protobuf:"bytes,6,opt,name=protocol_parameters,json=protocolParameters,proto3" json:"protocol_parameters,omitempty"`
	// Path at which next upgraded client will be committed.
	UpgradePath []string `protobuf:"bytes,7,rep,name=upgrade_path,json=upgradePath,proto3" json:"upgrade_path,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{1}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

type ConsensusState struct {
	Timestamp                           uint64              `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	MithrilStakeDistributionCertificate *MithrilCertificate `protobuf:"bytes,2,opt,name=mithril_stake_distribution_certificate,json=mithrilStakeDistributionCertificate,proto3" json:"mithril_stake_distribution_certificate,omitempty"`
	TransactionSnapshotCertificate      *MithrilCertificate `protobuf:"bytes,3,opt,name=transaction_snapshot_certificate,json=transactionSnapshotCertificate,proto3" json:"transaction_snapshot_certificate,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{2}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

type Misbehaviour struct {
	// ClientID is deprecated
	ClientId       string         `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"` // Deprecated: Do not use.
	MithrilHeader1 *MithrilHeader `protobuf:"bytes,2,opt,name=mithril_header_1,json=mithrilHeader1,proto3" json:"mithril_header_1,omitempty"`
	MithrilHeader2 *MithrilHeader `protobuf:"bytes,3,opt,name=mithril_header_2,json=mithrilHeader2,proto3" json:"mithril_header_2,omitempty"`
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{3}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

type MithrilHeader struct {
	MithrilStakeDistribution            *MithrilStakeDistribution   `protobuf:"bytes,1,opt,name=mithril_stake_distribution,json=mithrilStakeDistribution,proto3" json:"mithril_stake_distribution,omitempty"`
	MithrilStakeDistributionCertificate *MithrilCertificate         `protobuf:"bytes,2,opt,name=mithril_stake_distribution_certificate,json=mithrilStakeDistributionCertificate,proto3" json:"mithril_stake_distribution_certificate,omitempty"`
	TransactionSnapshot                 *CardanoTransactionSnapshot `protobuf:"bytes,3,opt,name=transaction_snapshot,json=transactionSnapshot,proto3" json:"transaction_snapshot,omitempty"`
	TransactionSnapshotCertificate      *MithrilCertificate         `protobuf:"bytes,4,opt,name=transaction_snapshot_certificate,json=transactionSnapshotCertificate,proto3" json:"transaction_snapshot_certificate,omitempty"`
}

func (m *MithrilHeader) Reset()         { *m = MithrilHeader{} }
func (m *MithrilHeader) String() string { return proto.CompactTextString(m) }
func (*MithrilHeader) ProtoMessage()    {}
func (*MithrilHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{4}
}
func (m *MithrilHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilHeader.Merge(m, src)
}
func (m *MithrilHeader) XXX_Size() int {
	return m.Size()
}
func (m *MithrilHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilHeader proto.InternalMessageInfo

type MithrilStakeDistribution struct {
	Epoch             uint64                     `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	SignersWithStake  []*SignerWithStake         `protobuf:"bytes,2,rep,name=signers_with_stake,json=signersWithStake,proto3" json:"signers_with_stake,omitempty"`
	Hash              string                     `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	CertificateHash   string                     `protobuf:"bytes,4,opt,name=certificate_hash,json=certificateHash,proto3" json:"certificate_hash,omitempty"`
	CreatedAt         uint64                     `protobuf:"varint,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	ProtocolParameter *MithrilProtocolParameters `protobuf:"bytes,6,opt,name=protocol_parameter,json=protocolParameter,proto3" json:"protocol_parameter,omitempty"`
}

func (m *MithrilStakeDistribution) Reset()         { *m = MithrilStakeDistribution{} }
func (m *MithrilStakeDistribution) String() string { return proto.CompactTextString(m) }
func (*MithrilStakeDistribution) ProtoMessage()    {}
func (*MithrilStakeDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{5}
}
func (m *MithrilStakeDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilStakeDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilStakeDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilStakeDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilStakeDistribution.Merge(m, src)
}
func (m *MithrilStakeDistribution) XXX_Size() int {
	return m.Size()
}
func (m *MithrilStakeDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilStakeDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilStakeDistribution proto.InternalMessageInfo

type CardanoTransactionSnapshot struct {
	SnapshotHash    string  `protobuf:"bytes,1,opt,name=snapshot_hash,json=snapshotHash,proto3" json:"snapshot_hash,omitempty"`
	MerkleRoot      string  `protobuf:"bytes,2,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
	CertificateHash string  `protobuf:"bytes,3,opt,name=certificate_hash,json=certificateHash,proto3" json:"certificate_hash,omitempty"`
	Epoch           uint64  `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Height          *Height `protobuf:"bytes,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *CardanoTransactionSnapshot) Reset()         { *m = CardanoTransactionSnapshot{} }
func (m *CardanoTransactionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CardanoTransactionSnapshot) ProtoMessage()    {}
func (*CardanoTransactionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{6}
}
func (m *CardanoTransactionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoTransactionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoTransactionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoTransactionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoTransactionSnapshot.Merge(m, src)
}
func (m *CardanoTransactionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CardanoTransactionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoTransactionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoTransactionSnapshot proto.InternalMessageInfo

type MithrilCertificate struct {
	Hash                     string               `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	PreviousHash             string               `protobuf:"bytes,2,opt,name=previous_hash,json=previousHash,proto3" json:"previous_hash,omitempty"`
	Epoch                    uint64               `protobuf:"varint,3,opt,name=epoch,proto3" json:"epoch,omitempty"`
	SignedEntityType         SignedEntityType     `protobuf:"varint,4,opt,name=signed_entity_type,json=signedEntityType,proto3,enum=ibc.clients.mithril.v1.SignedEntityType" json:"signed_entity_type,omitempty"`
	Metadata                 *CertificateMetadata `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ProtocolMessage          *ProtocolMessage     `protobuf:"bytes,6,opt,name=protocol_message,json=protocolMessage,proto3" json:"protocol_message,omitempty"`
	SignedMessage            string               `protobuf:"bytes,7,opt,name=signed_message,json=signedMessage,proto3" json:"signed_message,omitempty"`
	AggregateVerificationKey string               `protobuf:"bytes,8,opt,name=aggregate_verification_key,json=aggregateVerificationKey,proto3" json:"aggregate_verification_key,omitempty"`
	Signature                CertificateSignature `protobuf:"varint,9,opt,name=signature,proto3,enum=ibc.clients.mithril.v1.CertificateSignature" json:"signature,omitempty"`
}

func (m *MithrilCertificate) Reset()         { *m = MithrilCertificate{} }
func (m *MithrilCertificate) String() string { return proto.CompactTextString(m) }
func (*MithrilCertificate) ProtoMessage()    {}
func (*MithrilCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{7}
}
func (m *MithrilCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilCertificate.Merge(m, src)
}
func (m *MithrilCertificate) XXX_Size() int {
	return m.Size()
}
func (m *MithrilCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilCertificate proto.InternalMessageInfo

type CertificateMetadata struct {
	ProtocolVersion    string                     `protobuf:"bytes,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	ProtocolParameters *MithrilProtocolParameters `protobuf:"bytes,2,opt,name=protocol_parameters,json=protocolParameters,proto3" json:"protocol_parameters,omitempty"`
	InitiatedAt        uint64                     `protobuf:"varint,3,opt,name=initiatedAt,proto3" json:"initiatedAt,omitempty"`
	SealedAt           uint64                     `protobuf:"varint,4,opt,name=sealedAt,proto3" json:"sealedAt,omitempty"`
	Signers            []*SignerWithStake         `protobuf:"bytes,5,rep,name=signers,proto3" json:"signers,omitempty"`
}

func (m *CertificateMetadata) Reset()         { *m = CertificateMetadata{} }
func (m *CertificateMetadata) String() string { return proto.CompactTextString(m) }
func (*CertificateMetadata) ProtoMessage()    {}
func (*CertificateMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{8}
}
func (m *CertificateMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertificateMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateMetadata.Merge(m, src)
}
func (m *CertificateMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CertificateMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateMetadata proto.InternalMessageInfo

type SignerWithStake struct {
	PartyId string `protobuf:"bytes,1,opt,name=party_id,json=partyId,proto3" json:"party_id,omitempty"`
	Stake   uint64 `protobuf:"varint,2,opt,name=stake,proto3" json:"stake,omitempty"`
}

func (m *SignerWithStake) Reset()         { *m = SignerWithStake{} }
func (m *SignerWithStake) String() string { return proto.CompactTextString(m) }
func (*SignerWithStake) ProtoMessage()    {}
func (*SignerWithStake) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{9}
}
func (m *SignerWithStake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignerWithStake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignerWithStake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignerWithStake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignerWithStake.Merge(m, src)
}
func (m *SignerWithStake) XXX_Size() int {
	return m.Size()
}
func (m *SignerWithStake) XXX_DiscardUnknown() {
	xxx_messageInfo_SignerWithStake.DiscardUnknown(m)
}

var xxx_messageInfo_SignerWithStake proto.InternalMessageInfo

type ProtocolMessage struct {
	ProtocolMessagePartKey   ProtocolMessagePartKey `protobuf:"varint,1,opt,name=protocol_message_part_key,json=protocolMessagePartKey,proto3,enum=ibc.clients.mithril.v1.ProtocolMessagePartKey" json:"protocol_message_part_key,omitempty"`
	ProtocolMessagePartValue string                 `protobuf:"bytes,2,opt,name=protocol_message_part_value,json=protocolMessagePartValue,proto3" json:"protocol_message_part_value,omitempty"`
}

func (m *ProtocolMessage) Reset()         { *m = ProtocolMessage{} }
func (m *ProtocolMessage) String() string { return proto.CompactTextString(m) }
func (*ProtocolMessage) ProtoMessage()    {}
func (*ProtocolMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{10}
}
func (m *ProtocolMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolMessage.Merge(m, src)
}
func (m *ProtocolMessage) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolMessage proto.InternalMessageInfo

type MithrilProtocolParameters struct {
	// Quorum parameter
	K uint64 `protobuf:"varint,1,opt,name=k,proto3" json:"k,omitempty"`
	// Security parameter (number of lotteries)
	M uint64 `protobuf:"varint,2,opt,name=m,proto3" json:"m,omitempty"`
	// f in phi(w) = 1 - (1 - f)^w, where w is the stake of a participant
	PhiF uint64 `protobuf:"varint,3,opt,name=phi_f,json=phiF,proto3" json:"phi_f,omitempty"`
}

func (m *MithrilProtocolParameters) Reset()         { *m = MithrilProtocolParameters{} }
func (m *MithrilProtocolParameters) String() string { return proto.CompactTextString(m) }
func (*MithrilProtocolParameters) ProtoMessage()    {}
func (*MithrilProtocolParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{11}
}
func (m *MithrilProtocolParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilProtocolParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilProtocolParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilProtocolParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilProtocolParameters.Merge(m, src)
}
func (m *MithrilProtocolParameters) XXX_Size() int {
	return m.Size()
}
func (m *MithrilProtocolParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilProtocolParameters.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilProtocolParameters proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("ibc.clients.mithril.v1.ProtocolMessagePartKey", ProtocolMessagePartKey_name, ProtocolMessagePartKey_value)
	proto.RegisterEnum("ibc.clients.mithril.v1.SignedEntityType", SignedEntityType_name, SignedEntityType_value)
	proto.RegisterEnum("ibc.clients.mithril.v1.CertificateSignature", CertificateSignature_name, CertificateSignature_value)
	proto.RegisterType((*Height)(nil), "ibc.clients.mithril.v1.Height")
	proto.RegisterType((*ClientState)(nil), "ibc.clients.mithril.v1.ClientState")
	proto.RegisterType((*ConsensusState)(nil), "ibc.clients.mithril.v1.ConsensusState")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.clients.mithril.v1.Misbehaviour")
	proto.RegisterType((*MithrilHeader)(nil), "ibc.clients.mithril.v1.MithrilHeader")
	proto.RegisterType((*MithrilStakeDistribution)(nil), "ibc.clients.mithril.v1.MithrilStakeDistribution")
	proto.RegisterType((*CardanoTransactionSnapshot)(nil), "ibc.clients.mithril.v1.CardanoTransactionSnapshot")
	proto.RegisterType((*MithrilCertificate)(nil), "ibc.clients.mithril.v1.MithrilCertificate")
	proto.RegisterType((*CertificateMetadata)(nil), "ibc.clients.mithril.v1.CertificateMetadata")
	proto.RegisterType((*SignerWithStake)(nil), "ibc.clients.mithril.v1.SignerWithStake")
	proto.RegisterType((*ProtocolMessage)(nil), "ibc.clients.mithril.v1.ProtocolMessage")
	proto.RegisterType((*MithrilProtocolParameters)(nil), "ibc.clients.mithril.v1.MithrilProtocolParameters")
}

func init() {
	proto.RegisterFile("ibc/clients/mithril/v1/mithril.proto", fileDescriptor_4410ce5523531b7b)
}

var fileDescriptor_4410ce5523531b7b = []byte{
	// 1366 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x4d, 0x73, 0xdb, 0xc4,
	0x1b, 0xb7, 0x62, 0xe7, 0xc5, 0x4f, 0xde, 0xdc, 0x4d, 0xfe, 0x1d, 0x35, 0xed, 0xdf, 0x31, 0x4d,
	0x4b, 0x43, 0x61, 0x12, 0x62, 0x06, 0x66, 0xe8, 0xc0, 0xc1, 0x71, 0xd4, 0x44, 0x24, 0x76, 0x32,
	0x2b, 0x25, 0xbc, 0x5c, 0x96, 0x8d, 0xb5, 0xb5, 0x76, 0x12, 0x4b, 0x1a, 0x69, 0x1d, 0x08, 0x17,
	0xae, 0xbd, 0x30, 0x70, 0xe4, 0xd8, 0x19, 0x8e, 0x7c, 0x0a, 0x6e, 0x5c, 0x98, 0xe9, 0x91, 0x13,
	0x03, 0xc9, 0x07, 0x81, 0xd1, 0x6a, 0x65, 0x2b, 0x89, 0x4d, 0xd3, 0x0e, 0x0c, 0x37, 0xed, 0x6f,
	0x9f, 0xf7, 0xe7, 0xb7, 0xcf, 0xae, 0xe0, 0x1e, 0x3f, 0x6c, 0xad, 0xb6, 0x8e, 0x39, 0xf3, 0x44,
	0xb4, 0xda, 0xe1, 0xc2, 0x0d, 0xf9, 0xf1, 0xea, 0xc9, 0x5a, 0xfa, 0xb9, 0x12, 0x84, 0xbe, 0xf0,
	0xd1, 0x4d, 0x7e, 0xd8, 0x5a, 0x51, 0x52, 0x2b, 0xe9, 0xd6, 0xc9, 0xda, 0xc2, 0x7c, 0xdb, 0x6f,
	0xfb, 0x52, 0x64, 0x35, 0xfe, 0x4a, 0xa4, 0xef, 0xbe, 0x0f, 0x63, 0x5b, 0x8c, 0xb7, 0x5d, 0x81,
	0xee, 0xc3, 0x8c, 0x92, 0x26, 0xae, 0x44, 0x74, 0xad, 0xa2, 0x2d, 0x17, 0xf0, 0xb4, 0x42, 0x13,
	0xb1, 0x47, 0x13, 0x4f, 0x9f, 0x2d, 0xe6, 0xbe, 0x7f, 0xb6, 0x98, 0xbb, 0xfb, 0x4d, 0x1e, 0x26,
	0xeb, 0xd2, 0x8f, 0x25, 0xa8, 0x60, 0xe8, 0x16, 0x4c, 0xb4, 0x5c, 0xca, 0x3d, 0xc2, 0x1d, 0xa9,
	0x5a, 0xc4, 0xe3, 0x72, 0x6d, 0x3a, 0xa8, 0x0e, 0xd3, 0xc7, 0x54, 0xb0, 0x48, 0xa4, 0xa6, 0x47,
	0x2a, 0xda, 0xf2, 0x64, 0xb5, 0xbc, 0x32, 0x38, 0xd6, 0x95, 0xc4, 0x17, 0x9e, 0x4a, 0x94, 0x54,
	0x80, 0x75, 0x98, 0x7e, 0x12, 0xfa, 0x5f, 0x31, 0x2f, 0x35, 0x92, 0xbf, 0x9e, 0x91, 0x44, 0x49,
	0x19, 0x59, 0x82, 0xe9, 0x56, 0x37, 0x0c, 0x99, 0x27, 0x08, 0x0b, 0xfc, 0x96, 0xab, 0x17, 0x64,
	0x92, 0x53, 0x0a, 0x34, 0x62, 0x0c, 0x3d, 0x80, 0x59, 0x11, 0x76, 0x23, 0xc1, 0xbd, 0x36, 0x09,
	0x58, 0xc8, 0x7d, 0x47, 0x1f, 0x95, 0x62, 0x33, 0x29, 0xbc, 0x27, 0x51, 0x74, 0x08, 0x73, 0xb2,
	0x8c, 0x2d, 0xff, 0x98, 0x04, 0x34, 0xa4, 0x1d, 0x26, 0x58, 0x18, 0xe9, 0x63, 0x32, 0xb0, 0xb5,
	0x61, 0x81, 0x35, 0x92, 0xcf, 0x3d, 0xa5, 0xb9, 0xd7, 0x53, 0xc4, 0x28, 0xb8, 0x82, 0xa1, 0xd7,
	0x60, 0xaa, 0x1b, 0xb4, 0x43, 0xea, 0x30, 0x12, 0x50, 0xe1, 0xea, 0xe3, 0x95, 0xfc, 0x72, 0x11,
	0x4f, 0x2a, 0x6c, 0x8f, 0x0a, 0xf7, 0x51, 0x21, 0xee, 0xc9, 0xdd, 0x1f, 0x47, 0x60, 0xa6, 0xee,
	0x7b, 0x11, 0xf3, 0xa2, 0x6e, 0x94, 0xb4, 0xe4, 0x0e, 0x14, 0x05, 0xef, 0xb0, 0x48, 0xd0, 0x4e,
	0xa0, 0xda, 0xd9, 0x07, 0xd0, 0xd7, 0xf0, 0x7a, 0xda, 0xf1, 0x48, 0xd0, 0x23, 0x46, 0x1c, 0x1e,
	0x89, 0x90, 0x1f, 0x76, 0x05, 0xf7, 0x3d, 0xd2, 0x62, 0xa1, 0xe0, 0x4f, 0x78, 0x8b, 0x0a, 0xa6,
	0xda, 0xf5, 0xf0, 0x05, 0x09, 0xd5, 0xfb, 0x1a, 0x78, 0x49, 0x6d, 0x5b, 0xb1, 0xe1, 0x8d, 0x8c,
	0xdd, 0x8c, 0x10, 0x12, 0x50, 0x11, 0x21, 0xf5, 0x22, 0xda, 0x92, 0x1e, 0x23, 0x8f, 0x06, 0x91,
	0xeb, 0x8b, 0x0b, 0xae, 0xf3, 0x2f, 0xed, 0xba, 0x9c, 0xb1, 0x69, 0x29, 0x93, 0x99, 0x7d, 0x55,
	0xad, 0x3f, 0x35, 0x98, 0x6a, 0xf0, 0xe8, 0x90, 0xb9, 0xf4, 0x84, 0xfb, 0xdd, 0x10, 0x2d, 0x42,
	0x31, 0xb1, 0xdf, 0xe3, 0xef, 0xfa, 0x88, 0xae, 0xe1, 0x89, 0x04, 0x34, 0x1d, 0xd4, 0x82, 0x52,
	0xff, 0x80, 0x50, 0x87, 0x85, 0x64, 0x4d, 0x15, 0xe6, 0xfe, 0x0b, 0xa2, 0xdb, 0x92, 0xe2, 0xeb,
	0xe8, 0xec, 0xb7, 0xc5, 0x99, 0x0b, 0xd0, 0x1a, 0x9e, 0xe9, 0x5c, 0x58, 0x0f, 0x70, 0x52, 0x55,
	0x25, 0x78, 0x65, 0x27, 0xd5, 0x4b, 0x4e, 0xaa, 0xaa, 0x02, 0xe7, 0x79, 0x98, 0xbe, 0x20, 0x88,
	0x3c, 0x58, 0x18, 0x4e, 0x08, 0x59, 0x93, 0xc9, 0xea, 0xdb, 0x2f, 0x08, 0xe3, 0x4a, 0xc3, 0xb1,
	0x3e, 0x8c, 0x0a, 0xff, 0x3d, 0x01, 0x19, 0xcc, 0x0f, 0x22, 0xa0, 0xaa, 0x78, 0x75, 0x98, 0xbb,
	0x3a, 0x0d, 0x1d, 0xea, 0xf9, 0xf6, 0x55, 0x9e, 0xe1, 0xb9, 0x01, 0xe4, 0xbb, 0x16, 0xcf, 0x0b,
	0xff, 0x12, 0xcf, 0x7f, 0x19, 0x01, 0x7d, 0x58, 0x6b, 0xd0, 0x3c, 0x8c, 0x26, 0x53, 0x30, 0x99,
	0x0d, 0xc9, 0x02, 0xed, 0x03, 0x8a, 0x78, 0xdb, 0x63, 0x61, 0x44, 0xbe, 0xe0, 0xc2, 0x4d, 0x7a,
	0xa3, 0x8f, 0x54, 0xf2, 0xcb, 0x93, 0xd5, 0x07, 0xc3, 0x02, 0xb4, 0xa4, 0xc6, 0xc7, 0x5c, 0xb8,
	0xd2, 0x0d, 0x2e, 0x29, 0x13, 0x3d, 0x04, 0x21, 0x28, 0xb8, 0x34, 0x72, 0x65, 0x71, 0x8b, 0x58,
	0x7e, 0xa3, 0x37, 0xa0, 0x94, 0x29, 0x02, 0x91, 0xfb, 0x05, 0xb9, 0x3f, 0x9b, 0xc1, 0xb7, 0x62,
	0xd1, 0xff, 0x03, 0xb4, 0x42, 0x46, 0x05, 0x73, 0x08, 0x15, 0x6a, 0x1e, 0x17, 0x15, 0x52, 0x13,
	0xe8, 0x73, 0x40, 0x57, 0x47, 0xf1, 0xab, 0x4f, 0xe2, 0x1b, 0x57, 0x26, 0xb1, 0xaa, 0xe7, 0x1f,
	0x1a, 0x2c, 0x0c, 0xef, 0x7f, 0x7c, 0xbf, 0xf4, 0xda, 0x2b, 0xb3, 0x49, 0x6e, 0xc2, 0xa9, 0x14,
	0x94, 0xa9, 0x2c, 0xc2, 0x64, 0x87, 0x85, 0x47, 0xc7, 0x8c, 0x84, 0xbe, 0x9f, 0x5c, 0x86, 0x45,
	0x0c, 0x09, 0x84, 0x7d, 0x5f, 0x0c, 0x2c, 0x4b, 0x7e, 0x70, 0x59, 0x7a, 0x2d, 0x2c, 0x64, 0x5b,
	0xf8, 0x1e, 0x8c, 0xa9, 0x4b, 0x72, 0xf4, 0x5a, 0x97, 0xa4, 0x92, 0x56, 0x39, 0x7e, 0x5b, 0x00,
	0x74, 0x95, 0x70, 0xbd, 0x06, 0x6a, 0x99, 0x06, 0x2e, 0xc1, 0x74, 0x10, 0xb2, 0x78, 0x82, 0x46,
	0x49, 0x98, 0x49, 0x32, 0x53, 0x29, 0x78, 0x31, 0xc6, 0x7c, 0x36, 0xc6, 0x03, 0x45, 0x33, 0x87,
	0x30, 0x4f, 0x70, 0x71, 0x4a, 0xc4, 0x69, 0x90, 0x9c, 0x83, 0x99, 0xea, 0xf2, 0xdf, 0xd2, 0xcc,
	0x31, 0xa4, 0x82, 0x7d, 0x1a, 0xa4, 0x3c, 0xcb, 0x20, 0x68, 0x13, 0x26, 0x3a, 0x4c, 0x50, 0x87,
	0x0a, 0xaa, 0xb2, 0x7f, 0x73, 0xe8, 0x41, 0xee, 0x67, 0xd7, 0x50, 0x2a, 0xb8, 0xa7, 0x8c, 0x30,
	0x94, 0x7a, 0x94, 0xea, 0xb0, 0x28, 0xa2, 0x6d, 0xa6, 0x08, 0x35, 0xf4, 0x14, 0xa4, 0x4c, 0x6a,
	0x24, 0xe2, 0x78, 0x36, 0xb8, 0x08, 0xc4, 0xaf, 0x2c, 0x95, 0x74, 0x6a, 0x71, 0x5c, 0x16, 0x6c,
	0x3a, 0x41, 0x53, 0xb1, 0x0f, 0x60, 0x81, 0xb6, 0xdb, 0x21, 0x6b, 0xc7, 0xed, 0x3f, 0x61, 0x61,
	0x12, 0x64, 0x3c, 0x3c, 0x8e, 0xd8, 0xa9, 0x3e, 0x21, 0x55, 0xf4, 0x9e, 0xc4, 0x41, 0x46, 0x60,
	0x9b, 0x9d, 0xa2, 0x8f, 0xa0, 0x18, 0x9b, 0xa3, 0xa2, 0x1b, 0x32, 0xbd, 0x28, 0x0b, 0xfa, 0xd6,
	0x35, 0x4a, 0x60, 0xa5, 0x3a, 0xb8, 0xaf, 0xde, 0x7f, 0x5b, 0xcc, 0x0d, 0x28, 0x56, 0x4c, 0xd4,
	0x5e, 0x89, 0x4e, 0x58, 0x18, 0xa5, 0xf7, 0x44, 0xb1, 0x9f, 0xf9, 0x41, 0x02, 0x0f, 0x7b, 0x2b,
	0x8d, 0xfc, 0x93, 0x6f, 0xa5, 0x0a, 0x4c, 0x72, 0x8f, 0x0b, 0x9e, 0xcc, 0x04, 0x45, 0xb7, 0x2c,
	0x84, 0x16, 0x60, 0x22, 0x62, 0xf4, 0x58, 0x6e, 0x27, 0x27, 0xa6, 0xb7, 0x46, 0x35, 0x18, 0x57,
	0x43, 0x4b, 0x1f, 0x7d, 0xb9, 0x61, 0x97, 0xea, 0xa9, 0x6a, 0x6d, 0xc1, 0xec, 0x25, 0x89, 0xf8,
	0x71, 0x1c, 0xd0, 0x50, 0x9c, 0x66, 0x1e, 0xc7, 0x72, 0x6d, 0x3a, 0xf1, 0xe9, 0x48, 0x27, 0xac,
	0x3c, 0x1d, 0x72, 0xa1, 0x2c, 0xfd, 0xa4, 0xc1, 0xec, 0x25, 0x4e, 0x21, 0x0e, 0xb7, 0x2e, 0xd3,
	0x32, 0x2e, 0xa8, 0x90, 0xd4, 0xd0, 0x64, 0xb7, 0x57, 0xae, 0xc9, 0xcf, 0x3d, 0x1a, 0x8a, 0x6d,
	0x76, 0x8a, 0x6f, 0x06, 0x03, 0x71, 0xf4, 0x21, 0xdc, 0x1e, 0xec, 0xea, 0x84, 0x1e, 0x77, 0x99,
	0x3a, 0xeb, 0xfa, 0x00, 0xe5, 0x83, 0x78, 0x5f, 0xe5, 0x80, 0xe1, 0xd6, 0xd0, 0x2e, 0xa2, 0x29,
	0xd0, 0x8e, 0xd4, 0xed, 0xa3, 0x1d, 0xc5, 0xab, 0x8e, 0x2a, 0x83, 0xd6, 0x41, 0x73, 0x30, 0x1a,
	0xb8, 0x9c, 0x3c, 0x51, 0x7d, 0x2c, 0x04, 0x2e, 0x7f, 0x9c, 0xd8, 0x7c, 0xf8, 0x4c, 0x83, 0x9b,
	0x83, 0x73, 0x41, 0x73, 0x30, 0x6b, 0x35, 0x6b, 0x7b, 0xd6, 0xd6, 0xae, 0x4d, 0x36, 0xcc, 0x4d,
	0xc3, 0xb2, 0x4b, 0x39, 0x74, 0x0f, 0x2a, 0xf5, 0x1a, 0xde, 0xa8, 0x35, 0x77, 0x89, 0x8d, 0x6b,
	0x4d, 0xab, 0x56, 0xb7, 0xcd, 0xdd, 0xa6, 0x45, 0x1a, 0x06, 0xde, 0xde, 0x31, 0x08, 0xde, 0xdd,
	0xb5, 0x4b, 0x1a, 0x5a, 0x82, 0xc5, 0xa6, 0xf1, 0x89, 0x4d, 0x6a, 0x9b, 0x9b, 0xd8, 0xd8, 0xac,
	0xd9, 0x06, 0x39, 0x30, 0xb0, 0xf9, 0xd8, 0xac, 0xd7, 0x62, 0x69, 0xb2, 0x6d, 0x7c, 0x5a, 0x1a,
	0x41, 0x15, 0xb8, 0xb3, 0x53, 0xb3, 0x0d, 0xcb, 0x26, 0x66, 0xa3, 0xb1, 0x6f, 0xd7, 0xd6, 0x77,
	0x0c, 0xf2, 0xd8, 0xdc, 0x31, 0x48, 0x73, 0xbf, 0xb1, 0x6e, 0xe0, 0x52, 0x7e, 0xa1, 0xf0, 0xf4,
	0x87, 0x72, 0xee, 0x21, 0x86, 0xd2, 0xe5, 0x61, 0x85, 0xca, 0xb0, 0xd0, 0x30, 0xed, 0x2d, 0x6c,
	0xee, 0x10, 0xcb, 0xae, 0x6d, 0x1b, 0x64, 0xc3, 0xb4, 0x6c, 0x6c, 0xae, 0xef, 0xc7, 0xf6, 0x4b,
	0x39, 0xa4, 0xc3, 0xfc, 0xa0, 0x30, 0x4b, 0x9a, 0xb2, 0xb9, 0x05, 0xf3, 0x83, 0xce, 0x2b, 0xfa,
	0x1f, 0xdc, 0xd8, 0x34, 0x9a, 0x86, 0x65, 0x5a, 0xc4, 0x32, 0x37, 0x9b, 0x35, 0x7b, 0x1f, 0x1b,
	0xa5, 0x5c, 0x5c, 0x8a, 0xc6, 0xfe, 0x8e, 0x6d, 0x66, 0x40, 0x65, 0x69, 0xfd, 0xdd, 0x9f, 0xcf,
	0xca, 0xda, 0xf3, 0xb3, 0xb2, 0xf6, 0xfb, 0x59, 0x59, 0xfb, 0xee, 0xbc, 0x9c, 0x7b, 0x7e, 0x5e,
	0xce, 0xfd, 0x7a, 0x5e, 0xce, 0x7d, 0x76, 0x3b, 0xe2, 0x0e, 0x93, 0x3f, 0x6e, 0xab, 0x5f, 0x5e,
	0xfe, 0xdb, 0x3c, 0x1c, 0x93, 0xbd, 0x7e, 0xe7, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xdf, 0xbd,
	0x0f, 0xdd, 0x8b, 0x0e, 0x00, 0x00,
}

func (m *Height) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Height) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Height) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MithrilHeight != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.MithrilHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpgradePath) > 0 {
		for iNdEx := len(m.UpgradePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpgradePath[iNdEx])
			copy(dAtA[i:], m.UpgradePath[iNdEx])
			i = encodeVarintMithril(dAtA, i, uint64(len(m.UpgradePath[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ProtocolParameters != nil {
		{
			size, err := m.ProtocolParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TrustingPeriod != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.TrustingPeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.CurrentEpoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.CurrentEpoch))
		i--
		dAtA[i] = 0x20
	}
	if m.FrozenHeight != nil {
		{
			size, err := m.FrozenHeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LatestHeight != nil {
		{
			size, err := m.LatestHeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionSnapshotCertificate != nil {
		{
			size, err := m.TransactionSnapshotCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MithrilStakeDistributionCertificate != nil {
		{
			size, err := m.MithrilStakeDistributionCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MithrilHeader2 != nil {
		{
			size, err := m.MithrilHeader2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MithrilHeader1 != nil {
		{
			size, err := m.MithrilHeader1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionSnapshotCertificate != nil {
		{
			size, err := m.TransactionSnapshotCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TransactionSnapshot != nil {
		{
			size, err := m.TransactionSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MithrilStakeDistributionCertificate != nil {
		{
			size, err := m.MithrilStakeDistributionCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MithrilStakeDistribution != nil {
		{
			size, err := m.MithrilStakeDistribution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilStakeDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProtocolParameter != nil {
		{
			size, err := m.ProtocolParameter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CreatedAt != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CertificateHash) > 0 {
		i -= len(m.CertificateHash)
		copy(dAtA[i:], m.CertificateHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.CertificateHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SignersWithStake) > 0 {
		for iNdEx := len(m.SignersWithStake) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignersWithStake[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardanoTransactionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoTransactionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoTransactionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != nil {
		{
			size, err := m.Height.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CertificateHash) > 0 {
		i -= len(m.CertificateHash)
		copy(dAtA[i:], m.CertificateHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.CertificateHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SnapshotHash) > 0 {
		i -= len(m.SnapshotHash)
		copy(dAtA[i:], m.SnapshotHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.SnapshotHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Signature))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AggregateVerificationKey) > 0 {
		i -= len(m.AggregateVerificationKey)
		copy(dAtA[i:], m.AggregateVerificationKey)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.AggregateVerificationKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SignedMessage) > 0 {
		i -= len(m.SignedMessage)
		copy(dAtA[i:], m.SignedMessage)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.SignedMessage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ProtocolMessage != nil {
		{
			size, err := m.ProtocolMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SignedEntityType != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.SignedEntityType))
		i--
		dAtA[i] = 0x20
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PreviousHash) > 0 {
		i -= len(m.PreviousHash)
		copy(dAtA[i:], m.PreviousHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.PreviousHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertificateMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SealedAt != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.SealedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.InitiatedAt != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.InitiatedAt))
		i--
		dAtA[i] = 0x18
	}
	if m.ProtocolParameters != nil {
		{
			size, err := m.ProtocolParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProtocolVersion) > 0 {
		i -= len(m.ProtocolVersion)
		copy(dAtA[i:], m.ProtocolVersion)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ProtocolVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignerWithStake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignerWithStake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignerWithStake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stake != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Stake))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PartyId) > 0 {
		i -= len(m.PartyId)
		copy(dAtA[i:], m.PartyId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.PartyId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolMessagePartValue) > 0 {
		i -= len(m.ProtocolMessagePartValue)
		copy(dAtA[i:], m.ProtocolMessagePartValue)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ProtocolMessagePartValue)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProtocolMessagePartKey != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.ProtocolMessagePartKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MithrilProtocolParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilProtocolParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilProtocolParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PhiF != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.PhiF))
		i--
		dAtA[i] = 0x18
	}
	if m.M != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.M))
		i--
		dAtA[i] = 0x10
	}
	if m.K != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.K))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMithril(dAtA []byte, offset int, v uint64) int {
	offset -= sovMithril(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Height) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MithrilHeight != 0 {
		n += 1 + sovMithril(uint64(m.MithrilHeight))
	}
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.LatestHeight != nil {
		l = m.LatestHeight.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.FrozenHeight != nil {
		l = m.FrozenHeight.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.CurrentEpoch != 0 {
		n += 1 + sovMithril(uint64(m.CurrentEpoch))
	}
	if m.TrustingPeriod != 0 {
		n += 1 + sovMithril(uint64(m.TrustingPeriod))
	}
	if m.ProtocolParameters != nil {
		l = m.ProtocolParameters.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if len(m.UpgradePath) > 0 {
		for _, s := range m.UpgradePath {
			l = len(s)
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovMithril(uint64(m.Timestamp))
	}
	if m.MithrilStakeDistributionCertificate != nil {
		l = m.MithrilStakeDistributionCertificate.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.TransactionSnapshotCertificate != nil {
		l = m.TransactionSnapshotCertificate.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilHeader1 != nil {
		l = m.MithrilHeader1.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilHeader2 != nil {
		l = m.MithrilHeader2.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MithrilStakeDistribution != nil {
		l = m.MithrilStakeDistribution.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilStakeDistributionCertificate != nil {
		l = m.MithrilStakeDistributionCertificate.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.TransactionSnapshot != nil {
		l = m.TransactionSnapshot.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.TransactionSnapshotCertificate != nil {
		l = m.TransactionSnapshotCertificate.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if len(m.SignersWithStake) > 0 {
		for _, e := range m.SignersWithStake {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.CertificateHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovMithril(uint64(m.CreatedAt))
	}
	if m.ProtocolParameter != nil {
		l = m.ProtocolParameter.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *CardanoTransactionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SnapshotHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.CertificateHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.Height != nil {
		l = m.Height.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.PreviousHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.SignedEntityType != 0 {
		n += 1 + sovMithril(uint64(m.SignedEntityType))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.ProtocolMessage != nil {
		l = m.ProtocolMessage.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.SignedMessage)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.AggregateVerificationKey)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Signature != 0 {
		n += 1 + sovMithril(uint64(m.Signature))
	}
	return n
}

func (m *CertificateMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProtocolVersion)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.ProtocolParameters != nil {
		l = m.ProtocolParameters.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.InitiatedAt != 0 {
		n += 1 + sovMithril(uint64(m.InitiatedAt))
	}
	if m.SealedAt != 0 {
		n += 1 + sovMithril(uint64(m.SealedAt))
	}
	if len(m.Signers) > 0 {
		for _, e := range m.Signers {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	return n
}

func (m *SignerWithStake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartyId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Stake != 0 {
		n += 1 + sovMithril(uint64(m.Stake))
	}
	return n
}

func (m *ProtocolMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolMessagePartKey != 0 {
		n += 1 + sovMithril(uint64(m.ProtocolMessagePartKey))
	}
	l = len(m.ProtocolMessagePartValue)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilProtocolParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K != 0 {
		n += 1 + sovMithril(uint64(m.K))
	}
	if m.M != 0 {
		n += 1 + sovMithril(uint64(m.M))
	}
	if m.PhiF != 0 {
		n += 1 + sovMithril(uint64(m.PhiF))
	}
	return n
}

func sovMithril(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMithril(x uint64) (n int) {
	return sovMithril(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Height) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Height: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Height: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilHeight", wireType)
			}
			m.MithrilHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MithrilHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestHeight == nil {
				m.LatestHeight = &Height{}
			}
			if err := m.LatestHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FrozenHeight == nil {
				m.FrozenHeight = &Height{}
			}
			if err := m.FrozenHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentEpoch", wireType)
			}
			m.CurrentEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustingPeriod", wireType)
			}
			m.TrustingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameters == nil {
				m.ProtocolParameters = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradePath = append(m.UpgradePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistributionCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilStakeDistributionCertificate == nil {
				m.MithrilStakeDistributionCertificate = &MithrilCertificate{}
			}
			if err := m.MithrilStakeDistributionCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionSnapshotCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionSnapshotCertificate == nil {
				m.TransactionSnapshotCertificate = &MithrilCertificate{}
			}
			if err := m.TransactionSnapshotCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilHeader1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilHeader1 == nil {
				m.MithrilHeader1 = &MithrilHeader{}
			}
			if err := m.MithrilHeader1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilHeader2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilHeader2 == nil {
				m.MithrilHeader2 = &MithrilHeader{}
			}
			if err := m.MithrilHeader2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilStakeDistribution == nil {
				m.MithrilStakeDistribution = &MithrilStakeDistribution{}
			}
			if err := m.MithrilStakeDistribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistributionCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilStakeDistributionCertificate == nil {
				m.MithrilStakeDistributionCertificate = &MithrilCertificate{}
			}
			if err := m.MithrilStakeDistributionCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionSnapshot == nil {
				m.TransactionSnapshot = &CardanoTransactionSnapshot{}
			}
			if err := m.TransactionSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionSnapshotCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionSnapshotCertificate == nil {
				m.TransactionSnapshotCertificate = &MithrilCertificate{}
			}
			if err := m.TransactionSnapshotCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilStakeDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilStakeDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilStakeDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignersWithStake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignersWithStake = append(m.SignersWithStake, &SignerWithStake{})
			if err := m.SignersWithStake[len(m.SignersWithStake)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameter == nil {
				m.ProtocolParameter = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoTransactionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoTransactionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoTransactionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Height == nil {
				m.Height = &Height{}
			}
			if err := m.Height.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilCertificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilCertificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedEntityType", wireType)
			}
			m.SignedEntityType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignedEntityType |= SignedEntityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &CertificateMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolMessage == nil {
				m.ProtocolMessage = &ProtocolMessage{}
			}
			if err := m.ProtocolMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateVerificationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregateVerificationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			m.Signature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Signature |= CertificateSignature(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameters == nil {
				m.ProtocolParameters = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			m.InitiatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedAt", wireType)
			}
			m.SealedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SealedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, &SignerWithStake{})
			if err := m.Signers[len(m.Signers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignerWithStake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignerWithStake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignerWithStake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			m.Stake = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stake |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessagePartKey", wireType)
			}
			m.ProtocolMessagePartKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolMessagePartKey |= ProtocolMessagePartKey(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessagePartValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolMessagePartValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilProtocolParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilProtocolParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilProtocolParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			m.M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.M |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhiF", wireType)
			}
			m.PhiF = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhiF |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMithril(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMithril
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMithril
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMithril
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMithril        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMithril          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMithril = fmt.Errorf("proto: unexpected end of group")
)
