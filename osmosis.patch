diff --git a/Dockerfile b/Dockerfile
index 7dbf949ec..cb908e945 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -66,8 +66,8 @@ ENV HOME /osmosis
 WORKDIR $HOME
 
 EXPOSE 26656
-EXPOSE 26657
-EXPOSE 1317
+EXPOSE 26658
+EXPOSE 1318
 # Note: uncomment the line below if you need pprof in localosmosis
 # We disable it by default in out main Dockerfile for security reasons
 # EXPOSE 6060
diff --git a/cosmwasm/Cargo.lock b/cosmwasm/Cargo.lock
index f87a7fcbf..ca4ded98c 100644
--- a/cosmwasm/Cargo.lock
+++ b/cosmwasm/Cargo.lock
@@ -2,21 +2,6 @@
 # It is not intended for manual editing.
 version = 3
 
-[[package]]
-name = "addr2line"
-version = "0.21.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8a30b2e23b9e17a9f90641c7ab1549cd9b44f296d3ccbf309d2863cfe398a0cb"
-dependencies = [
- "gimli",
-]
-
-[[package]]
-name = "adler"
-version = "1.0.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"
-
 [[package]]
 name = "ahash"
 version = "0.7.6"
@@ -30,34 +15,28 @@ dependencies = [
 
 [[package]]
 name = "aho-corasick"
-version = "1.0.4"
+version = "0.7.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6748e8def348ed4d14996fa801f4122cd763fff530258cdc03f64b25f89d3a5a"
+checksum = "cc936419f96fa211c1b9166887b38e5e40b19958e5b895be7c1f93adec7071ac"
 dependencies = [
  "memchr",
 ]
 
-[[package]]
-name = "android-tzdata"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
-
 [[package]]
 name = "anyhow"
-version = "1.0.75"
+version = "1.0.68"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a4668cab20f66d8d020e1fbc0ebe47217433c1b6c8f2040faf858554e394ace6"
+checksum = "2cb2f989d18dd141ab8ae82f64d1a8cdd37e0840f73a406896cf5e99502fab61"
 
 [[package]]
 name = "async-trait"
-version = "0.1.73"
+version = "0.1.61"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bc00ceb34980c03614e35a3a4e218276a0a824e911d07651cd0d858a51e8c0f0"
+checksum = "705339e0e4a9690e2908d2b3d049d85682cf19fbd5782494498fbf7003a6a282"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.29",
+ "syn",
 ]
 
 [[package]]
@@ -66,7 +45,7 @@ version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
 dependencies = [
- "hermit-abi 0.1.19",
+ "hermit-abi",
  "libc",
  "winapi",
 ]
@@ -77,21 +56,6 @@ version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
 
-[[package]]
-name = "backtrace"
-version = "0.3.69"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2089b7e3f35b9dd2d0ed921ead4f6d318c27680d4a5bd167b3ee120edb105837"
-dependencies = [
- "addr2line",
- "cc",
- "cfg-if",
- "libc",
- "miniz_oxide",
- "object",
- "rustc-demangle",
-]
-
 [[package]]
 name = "base16ct"
 version = "0.1.1"
@@ -106,9 +70,9 @@ checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"
 
 [[package]]
 name = "base64ct"
-version = "1.6.0"
+version = "1.5.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"
+checksum = "b645a089122eccb6111b4f81cbc1a49f5900ac4666bb93ac027feaecf15607bf"
 
 [[package]]
 name = "bech32"
@@ -152,7 +116,7 @@ dependencies = [
  "pbkdf2",
  "rand_core 0.6.4",
  "ripemd",
- "sha2 0.10.7",
+ "sha2 0.10.6",
  "subtle",
  "zeroize",
 ]
@@ -174,19 +138,13 @@ dependencies = [
 
 [[package]]
 name = "block-buffer"
-version = "0.10.4"
+version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
+checksum = "69cce20737498f97b993470a6e536b8523f0af7892a4f928cceb1ac5e52ebe7e"
 dependencies = [
  "generic-array",
 ]
 
-[[package]]
-name = "bnum"
-version = "0.7.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "845141a4fade3f790628b7daaaa298a25b204fb28907eb54febe5142db6ce653"
-
 [[package]]
 name = "bs58"
 version = "0.4.0"
@@ -198,9 +156,9 @@ dependencies = [
 
 [[package]]
 name = "bumpalo"
-version = "3.13.0"
+version = "3.11.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a3e2c3daef883ecc1b5d58c15adae93470a91d425f3532ba1695849656af3fc1"
+checksum = "572f695136211188308f16ad2ca5c851a712c464060ae6974944458eb83880ba"
 
 [[package]]
 name = "byteorder"
@@ -210,18 +168,9 @@ checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"
 
 [[package]]
 name = "bytes"
-version = "1.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be"
-
-[[package]]
-name = "cc"
-version = "1.0.83"
+version = "1.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f1174fb0b6ec23863f8b971027804a42614e347eafb0a95bf0b12cdae21fc4d0"
-dependencies = [
- "libc",
-]
+checksum = "dfb24e866b15a1af2a1b663f10c6b6b8f397a84aadb828f12e5b289ec23a3a3c"
 
 [[package]]
 name = "cexpr"
@@ -240,19 +189,19 @@ checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
 name = "chrono"
-version = "0.4.26"
+version = "0.4.23"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ec837a71355b28f6556dbd569b37b3f363091c0bd4b2e735674521b4c5fd9bc5"
+checksum = "16b0a3d9ed01224b22057780a37bb8c5dbfe1be8ba48678e7bf57ec4b385411f"
 dependencies = [
- "android-tzdata",
+ "num-integer",
  "num-traits",
 ]
 
 [[package]]
 name = "clang-sys"
-version = "1.6.1"
+version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c688fc74432808e3eb684cae8830a86be1d66a2bd58e1f248ed0960a590baf6f"
+checksum = "fa2e27ae6ab525c3d369ded447057bca5438d86dc3a68f6faafb8269ba82ebf3"
 dependencies = [
  "glob",
  "libc",
@@ -261,9 +210,9 @@ dependencies = [
 
 [[package]]
 name = "clap"
-version = "3.2.25"
+version = "3.2.23"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4ea181bf566f71cb9a5d17a59e1871af638180a18fb0035c92ae62b705207123"
+checksum = "71655c45cb9845d3270c9d6df84ebe72b4dad3c2ba3f7023ad47c144e4e473a5"
 dependencies = [
  "atty",
  "bitflags",
@@ -285,25 +234,9 @@ dependencies = [
 
 [[package]]
 name = "const-oid"
-version = "0.9.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "28c122c3980598d243d63d9a704629a2d748d101f278052ff068be5a4423ab6f"
-
-[[package]]
-name = "core-foundation"
-version = "0.9.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "194a7a9e6de53fa55116934067c844d9d749312f75c6f6d0980e8c252f8c2146"
-dependencies = [
- "core-foundation-sys",
- "libc",
-]
-
-[[package]]
-name = "core-foundation-sys"
-version = "0.8.4"
+version = "0.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e496a50fda8aacccc86d7529e2c1e0892dbd0f898a6b5645b5561b89c3210efa"
+checksum = "cec318a675afcb6a1ea1d4340e2d377e56e47c266f28043ceccbf4412ddfdd3b"
 
 [[package]]
 name = "cosmos-sdk-proto"
@@ -311,7 +244,7 @@ version = "0.14.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "20b42021d8488665b1a0d9748f1f81df7235362d194f44481e2e61bf376b77b4"
 dependencies = [
- "prost 0.11.9",
+ "prost 0.11.6",
  "prost-types",
  "tendermint-proto",
 ]
@@ -333,17 +266,16 @@ dependencies = [
  "serde_json",
  "subtle-encoding",
  "tendermint",
- "tendermint-rpc",
  "thiserror",
 ]
 
 [[package]]
 name = "cosmwasm-crypto"
-version = "1.3.3"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "871ce1d5a4b00ed1741f84b377eec19fadd81a904a227bc1e268d76539d26f5e"
+checksum = "cb56fffc2233212e9546df66e01267277173d55f6237ab939690ef2c5cfd50c2"
 dependencies = [
- "digest 0.10.7",
+ "digest 0.10.6",
  "ed25519-zebra",
  "k256",
  "rand_core 0.6.4",
@@ -352,18 +284,18 @@ dependencies = [
 
 [[package]]
 name = "cosmwasm-derive"
-version = "1.3.3"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ce8b44b45a7c8c6d6f770cd0a51458c2445c7c15b6115e1d215fa35c77b305c"
+checksum = "e26a78e202d602a23fd5d13dff898732814ebe7a8bde20f1bf71eb0209d56d56"
 dependencies = [
- "syn 1.0.109",
+ "syn",
 ]
 
 [[package]]
 name = "cosmwasm-schema"
-version = "1.3.3"
+version = "1.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "99222fa0401ee36389550d8a065700380877a2299c3043d24c38d705708c9d9d"
+checksum = "04135971e2c3b867eb793ca4e832543c077dbf72edaef7672699190f8fcdb619"
 dependencies = [
  "cosmwasm-schema-derive",
  "schemars",
@@ -374,23 +306,22 @@ dependencies = [
 
 [[package]]
 name = "cosmwasm-schema-derive"
-version = "1.3.3"
+version = "1.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4b74eaf9e585ef8e5e3486b240b13ee593cb0f658b5879696937d8c22243d4fb"
+checksum = "a06c8f516a13ae481016aa35f0b5c4652459e8aee65b15b6fb51547a07cea5a0"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
 ]
 
 [[package]]
 name = "cosmwasm-std"
-version = "1.3.3"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "da78abcf059181e8cb01e95e5003cf64fe95dde6c72b3fe37e5cabc75cdba32a"
+checksum = "7b50f4deaed6196047a3ceec9bc23e85d4292b73442d77af63723842d8b6049d"
 dependencies = [
  "base64",
- "bnum",
  "cosmwasm-crypto",
  "cosmwasm-derive",
  "derivative",
@@ -399,32 +330,28 @@ dependencies = [
  "schemars",
  "serde",
  "serde-json-wasm",
- "sha2 0.10.7",
+ "sha2 0.10.6",
  "thiserror",
+ "uint",
 ]
 
 [[package]]
-name = "cpufeatures"
-version = "0.2.9"
+name = "cosmwasm-storage"
+version = "1.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a17b76ff3a4162b0b27f354a0c87015ddad39d35f9c0c36607a3bdd175dde1f1"
+checksum = "9162c3f85412914d5be2ee650ebdbf11b08e5e9acdebcf4dc03608fb01cf9676"
 dependencies = [
- "libc",
+ "cosmwasm-std",
+ "serde",
 ]
 
 [[package]]
-name = "crosschain-registry"
-version = "0.1.0"
+name = "cpufeatures"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "28d997bd5e24a5928dd43e46dc529867e207907fe0b239c3477d924f7f2ca320"
 dependencies = [
- "cosmwasm-schema",
- "cosmwasm-std",
- "cw-multi-test",
- "cw-storage-plus",
- "cw-utils",
- "cw2",
- "registry",
- "serde",
- "thiserror",
+ "libc",
 ]
 
 [[package]]
@@ -434,17 +361,16 @@ dependencies = [
  "bech32",
  "cosmwasm-schema",
  "cosmwasm-std",
- "crosschain-registry",
+ "cosmwasm-storage",
  "cw-multi-test",
  "cw-storage-plus",
  "cw-utils",
  "cw2",
  "enum-repr",
- "itertools 0.11.0",
- "osmosis-std 0.16.2",
- "osmosis-test-tube",
- "prost 0.11.9",
- "registry",
+ "osmosis-std",
+ "osmosis-std-derive",
+ "osmosis-testing",
+ "prost 0.11.6",
  "schemars",
  "serde",
  "serde-cw-value",
@@ -453,6 +379,12 @@ dependencies = [
  "thiserror",
 ]
 
+[[package]]
+name = "crunchy"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"
+
 [[package]]
 name = "crypto-bigint"
 version = "0.4.9"
@@ -475,15 +407,6 @@ dependencies = [
  "typenum",
 ]
 
-[[package]]
-name = "ct-logs"
-version = "0.8.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c1a816186fa68d9e426e3cb4ae4dff1fcd8e4a2c34b781bf7a822574a0d0aac8"
-dependencies = [
- "sct",
-]
-
 [[package]]
 name = "curve25519-dalek"
 version = "3.2.0"
@@ -499,16 +422,16 @@ dependencies = [
 
 [[package]]
 name = "cw-multi-test"
-version = "0.16.5"
+version = "0.16.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "127c7bb95853b8e828bdab97065c81cb5ddc20f7339180b61b2300565aaa99d1"
+checksum = "c2eb84554bbfa6b66736abcd6a9bfdf237ee0ecb83910f746dff7f799093c80a"
 dependencies = [
  "anyhow",
  "cosmwasm-std",
  "cw-storage-plus",
  "cw-utils",
  "derivative",
- "itertools 0.10.5",
+ "itertools",
  "k256",
  "prost 0.9.0",
  "schemars",
@@ -518,9 +441,9 @@ dependencies = [
 
 [[package]]
 name = "cw-storage-plus"
-version = "1.1.0"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3f0e92a069d62067f3472c62e30adedb4cab1754725c0f2a682b3128d2bf3c79"
+checksum = "053a5083c258acd68386734f428a5a171b29f7d733151ae83090c6fcc9417ffa"
 dependencies = [
  "cosmwasm-std",
  "schemars",
@@ -544,16 +467,15 @@ dependencies = [
 
 [[package]]
 name = "cw2"
-version = "1.1.0"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "29ac2dc7a55ad64173ca1e0a46697c31b7a5c51342f55a1e84a724da4eb99908"
+checksum = "8fb70cee2cf0b4a8ff7253e6bc6647107905e8eb37208f87d54f67810faa62f8"
 dependencies = [
  "cosmwasm-schema",
  "cosmwasm-std",
  "cw-storage-plus",
  "schemars",
  "serde",
- "thiserror",
 ]
 
 [[package]]
@@ -574,7 +496,7 @@ checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
 ]
 
 [[package]]
@@ -588,20 +510,20 @@ dependencies = [
 
 [[package]]
 name = "digest"
-version = "0.10.7"
+version = "0.10.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
+checksum = "8168378f4e5023e7218c89c891c0fd8ecdb5e5e4f18cb78f38cf245dd021e76f"
 dependencies = [
- "block-buffer 0.10.4",
+ "block-buffer 0.10.3",
  "crypto-common",
  "subtle",
 ]
 
 [[package]]
 name = "dyn-clone"
-version = "1.0.13"
+version = "1.0.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbfc4744c1b8f2a09adc0e55242f60b1af195d88596bd8700be74418c056c555"
+checksum = "c9b0705efd4599c15a38151f4721f7bc388306f61084d3bfd50bd07fbca5cb60"
 
 [[package]]
 name = "ecdsa"
@@ -653,9 +575,9 @@ dependencies = [
 
 [[package]]
 name = "either"
-version = "1.9.0"
+version = "1.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"
+checksum = "90e5c1c8368803113bf0c9584fc495a58b86dc8a29edbf8fe877d21d9507e797"
 
 [[package]]
 name = "elliptic-curve"
@@ -666,7 +588,7 @@ dependencies = [
  "base16ct",
  "crypto-bigint",
  "der",
- "digest 0.10.7",
+ "digest 0.10.6",
  "ff",
  "generic-array",
  "group",
@@ -685,7 +607,7 @@ checksum = "bad30c9c0fa1aaf1ae5010dab11f1117b15d35faf62cda4bbbc53b9987950f18"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
 ]
 
 [[package]]
@@ -731,21 +653,6 @@ dependencies = [
  "paste",
 ]
 
-[[package]]
-name = "fnv"
-version = "1.0.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
-
-[[package]]
-name = "form_urlencoded"
-version = "1.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a62bc1cf6f830c2ec14a513a9fb124d0a213a629668a4186f329db21fe045652"
-dependencies = [
- "percent-encoding",
-]
-
 [[package]]
 name = "forward_ref"
 version = "1.0.0"
@@ -754,13 +661,12 @@ checksum = "c8cbd1169bd7b4a0a20d92b9af7a7e0422888bd38a6f5ec29c1fd8c1558a272e"
 
 [[package]]
 name = "futures"
-version = "0.3.28"
+version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "23342abe12aba583913b2e62f22225ff9c950774065e4bfb61a19cd9770fec40"
+checksum = "38390104763dc37a5145a53c29c63c1290b5d316d6086ec32c293f6736051bb0"
 dependencies = [
  "futures-channel",
  "futures-core",
- "futures-executor",
  "futures-io",
  "futures-sink",
  "futures-task",
@@ -769,9 +675,9 @@ dependencies = [
 
 [[package]]
 name = "futures-channel"
-version = "0.3.28"
+version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "955518d47e09b25bbebc7a18df10b81f0c766eaf4c4f1cccef2fca5f2a4fb5f2"
+checksum = "52ba265a92256105f45b719605a571ffe2d1f0fea3807304b522c1d778f79eed"
 dependencies = [
  "futures-core",
  "futures-sink",
@@ -779,73 +685,46 @@ dependencies = [
 
 [[package]]
 name = "futures-core"
-version = "0.3.28"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4bca583b7e26f571124fe5b7561d49cb2868d79116cfa0eefce955557c6fee8c"
-
-[[package]]
-name = "futures-executor"
-version = "0.3.28"
+version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ccecee823288125bd88b4d7f565c9e58e41858e47ab72e8ea2d64e93624386e0"
-dependencies = [
- "futures-core",
- "futures-task",
- "futures-util",
-]
+checksum = "04909a7a7e4633ae6c4a9ab280aeb86da1236243a77b694a49eacd659a4bd3ac"
 
 [[package]]
 name = "futures-io"
-version = "0.3.28"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4fff74096e71ed47f8e023204cfd0aa1289cd54ae5430a9523be060cdb849964"
-
-[[package]]
-name = "futures-macro"
-version = "0.3.28"
+version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "89ca545a94061b6365f2c7355b4b32bd20df3ff95f02da9329b34ccc3bd6ee72"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.29",
-]
+checksum = "00f5fb52a06bdcadeb54e8d3671f8888a39697dcb0b81b23b55174030427f4eb"
 
 [[package]]
 name = "futures-sink"
-version = "0.3.28"
+version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f43be4fe21a13b9781a69afa4985b0f6ee0e1afab2c6f454a8cf30e2b2237b6e"
+checksum = "39c15cf1a4aa79df40f1bb462fb39676d0ad9e366c2a33b590d7c66f4f81fcf9"
 
 [[package]]
 name = "futures-task"
-version = "0.3.28"
+version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "76d3d132be6c0e6aa1534069c705a74a5997a356c0dc2f86a47765e5617c5b65"
+checksum = "2ffb393ac5d9a6eaa9d3fdf37ae2776656b706e200c8e16b1bdb227f5198e6ea"
 
 [[package]]
 name = "futures-util"
-version = "0.3.28"
+version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26b01e40b772d54cf6c6d721c1d1abd0647a0106a12ecaa1c186273392a69533"
+checksum = "197676987abd2f9cadff84926f410af1c183608d36641465df73ae8211dc65d6"
 dependencies = [
- "futures-channel",
  "futures-core",
- "futures-io",
- "futures-macro",
  "futures-sink",
  "futures-task",
- "memchr",
  "pin-project-lite",
  "pin-utils",
- "slab",
 ]
 
 [[package]]
 name = "generic-array"
-version = "0.14.7"
+version = "0.14.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
+checksum = "bff49e947297f3312447abdca79f45f4738097cc82b06e72054d2223f601f1b9"
 dependencies = [
  "typenum",
  "version_check",
@@ -853,9 +732,9 @@ dependencies = [
 
 [[package]]
 name = "getrandom"
-version = "0.2.10"
+version = "0.2.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427"
+checksum = "c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31"
 dependencies = [
  "cfg-if",
  "js-sys",
@@ -864,12 +743,6 @@ dependencies = [
  "wasm-bindgen",
 ]
 
-[[package]]
-name = "gimli"
-version = "0.28.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6fb8d784f27acf97159b40fc4db5ecd8aa23b9ad5ef69cdd136d3bc80665f0c0"
-
 [[package]]
 name = "glob"
 version = "0.3.1"
@@ -887,25 +760,6 @@ dependencies = [
  "subtle",
 ]
 
-[[package]]
-name = "h2"
-version = "0.3.21"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "91fc23aa11be92976ef4729127f1a74adf36d8436f7816b185d18df956790833"
-dependencies = [
- "bytes",
- "fnv",
- "futures-core",
- "futures-sink",
- "futures-util",
- "http",
- "indexmap",
- "slab",
- "tokio",
- "tokio-util",
- "tracing",
-]
-
 [[package]]
 name = "hashbrown"
 version = "0.12.3"
@@ -915,31 +769,6 @@ dependencies = [
  "ahash",
 ]
 
-[[package]]
-name = "headers"
-version = "0.3.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f3e372db8e5c0d213e0cd0b9be18be2aca3d44cf2fe30a9d46a65581cd454584"
-dependencies = [
- "base64",
- "bitflags",
- "bytes",
- "headers-core",
- "http",
- "httpdate",
- "mime",
- "sha1",
-]
-
-[[package]]
-name = "headers-core"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e7f66481bfee273957b1f20485a4ff3362987f85b2c236580d81b4eb7a326429"
-dependencies = [
- "http",
-]
-
 [[package]]
 name = "hermit-abi"
 version = "0.1.19"
@@ -949,12 +778,6 @@ dependencies = [
  "libc",
 ]
 
-[[package]]
-name = "hermit-abi"
-version = "0.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "443144c8cdadd93ebf52ddb4056d257f5b52c04d3c804e657d19eb73fc33668b"
-
 [[package]]
 name = "hex"
 version = "0.4.3"
@@ -967,120 +790,15 @@ version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
 dependencies = [
- "digest 0.10.7",
-]
-
-[[package]]
-name = "http"
-version = "0.2.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bd6effc99afb63425aff9b05836f029929e345a6148a14b7ecd5ab67af944482"
-dependencies = [
- "bytes",
- "fnv",
- "itoa",
-]
-
-[[package]]
-name = "http-body"
-version = "0.4.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d5f38f16d184e36f2408a55281cd658ecbd3ca05cce6d6510a176eca393e26d1"
-dependencies = [
- "bytes",
- "http",
- "pin-project-lite",
+ "digest 0.10.6",
 ]
 
-[[package]]
-name = "httparse"
-version = "1.8.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d897f394bad6a705d5f4104762e116a75639e470d80901eed05a860a95cb1904"
-
-[[package]]
-name = "httpdate"
-version = "1.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"
-
 [[package]]
 name = "humantime"
 version = "2.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"
 
-[[package]]
-name = "hyper"
-version = "0.14.27"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ffb1cfd654a8219eaef89881fdb3bb3b1cdc5fa75ded05d6933b2b382e395468"
-dependencies = [
- "bytes",
- "futures-channel",
- "futures-core",
- "futures-util",
- "h2",
- "http",
- "http-body",
- "httparse",
- "httpdate",
- "itoa",
- "pin-project-lite",
- "socket2 0.4.9",
- "tokio",
- "tower-service",
- "tracing",
- "want",
-]
-
-[[package]]
-name = "hyper-proxy"
-version = "0.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ca815a891b24fdfb243fa3239c86154392b0953ee584aa1a2a1f66d20cbe75cc"
-dependencies = [
- "bytes",
- "futures",
- "headers",
- "http",
- "hyper",
- "hyper-rustls",
- "rustls-native-certs",
- "tokio",
- "tokio-rustls",
- "tower-service",
- "webpki",
-]
-
-[[package]]
-name = "hyper-rustls"
-version = "0.22.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5f9f7a97316d44c0af9b0301e65010573a853a9fc97046d7331d7f6bc0fd5a64"
-dependencies = [
- "ct-logs",
- "futures-util",
- "hyper",
- "log",
- "rustls",
- "rustls-native-certs",
- "tokio",
- "tokio-rustls",
- "webpki",
- "webpki-roots",
-]
-
-[[package]]
-name = "idna"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7d20d6b07bfbc108882d88ed8e37d39636dcc260e15e30c45e6ba089610b917c"
-dependencies = [
- "unicode-bidi",
- "unicode-normalization",
-]
-
 [[package]]
 name = "indenter"
 version = "0.3.3"
@@ -1089,9 +807,9 @@ checksum = "ce23b50ad8242c51a442f3ff322d56b02f08852c77e4c0b4d3fd684abc89c683"
 
 [[package]]
 name = "indexmap"
-version = "1.9.3"
+version = "1.9.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
+checksum = "1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399"
 dependencies = [
  "autocfg",
  "hashbrown",
@@ -1106,26 +824,17 @@ dependencies = [
  "either",
 ]
 
-[[package]]
-name = "itertools"
-version = "0.11.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b1c173a5686ce8bfa551b3563d0c2170bf24ca44da99c7ca4bfdab5418c3fe57"
-dependencies = [
- "either",
-]
-
 [[package]]
 name = "itoa"
-version = "1.0.9"
+version = "1.0.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "af150ab688ff2122fcef229be89cb50dd66af9e01a4ff320cc137eecc9bacc38"
+checksum = "fad582f4b9e86b6caa621cabeb0963332d92eea04729ab12892c2533951e6440"
 
 [[package]]
 name = "js-sys"
-version = "0.3.64"
+version = "0.3.60"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c5f195fe497f702db0f318b07fdd68edb16955aed830df8363d837542f8f935a"
+checksum = "49409df3e3bf0856b916e2ceaca09ee28e6871cf7d9ce97a692cacfdb2a25a47"
 dependencies = [
  "wasm-bindgen",
 ]
@@ -1139,15 +848,15 @@ dependencies = [
  "cfg-if",
  "ecdsa",
  "elliptic-curve",
- "sha2 0.10.7",
+ "sha2 0.10.6",
  "sha3",
 ]
 
 [[package]]
 name = "keccak"
-version = "0.1.4"
+version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f6d5ed8676d904364de097082f4e7d240b571b67989ced0240f08b7f966f940"
+checksum = "3afef3b6eff9ce9d8ff9b3601125eec7f0c8cbac7abd14f355d053fa56c98768"
 dependencies = [
  "cpufeatures",
 ]
@@ -1166,9 +875,9 @@ checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
 
 [[package]]
 name = "libc"
-version = "0.2.153"
+version = "0.2.139"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd"
+checksum = "201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79"
 
 [[package]]
 name = "libloading"
@@ -1182,21 +891,18 @@ dependencies = [
 
 [[package]]
 name = "log"
-version = "0.4.20"
+version = "0.4.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f"
+checksum = "abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e"
+dependencies = [
+ "cfg-if",
+]
 
 [[package]]
 name = "memchr"
-version = "2.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "76fc44e2588d5b436dbc3c6cf62aef290f90dab6235744a93dfe1cc18f451e2c"
-
-[[package]]
-name = "mime"
-version = "0.3.17"
+version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
+checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"
 
 [[package]]
 name = "minimal-lexical"
@@ -1204,26 +910,6 @@ version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
 
-[[package]]
-name = "miniz_oxide"
-version = "0.7.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7"
-dependencies = [
- "adler",
-]
-
-[[package]]
-name = "mio"
-version = "0.8.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a4a650543ca06a924e8b371db273b2756685faae30f8487da1b56505a8f78b0c"
-dependencies = [
- "libc",
- "wasi",
- "windows-sys",
-]
-
 [[package]]
 name = "nom"
 version = "7.1.3"
@@ -1242,26 +928,26 @@ checksum = "876a53fff98e03a936a674b29568b0e605f06b29372c2489ff4de23f1949743d"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
 ]
 
 [[package]]
-name = "num-traits"
-version = "0.2.16"
+name = "num-integer"
+version = "0.1.45"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f30b0abd723be7e2ffca1272140fac1a2f084c77ec3e123c192b66af1ee9e6c2"
+checksum = "225d3389fb3509a24c93f5c29eb6bde2586b98d9f016636dff58d7c6f7569cd9"
 dependencies = [
  "autocfg",
+ "num-traits",
 ]
 
 [[package]]
-name = "num_cpus"
-version = "1.16.0"
+name = "num-traits"
+version = "0.2.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
+checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
 dependencies = [
- "hermit-abi 0.3.2",
- "libc",
+ "autocfg",
 ]
 
 [[package]]
@@ -1273,20 +959,11 @@ dependencies = [
  "libc",
 ]
 
-[[package]]
-name = "object"
-version = "0.32.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "77ac5bbd07aea88c60a577a1ce218075ffd59208b2d7ca97adf9bfc5aeb21ebe"
-dependencies = [
- "memchr",
-]
-
 [[package]]
 name = "once_cell"
-version = "1.18.0"
+version = "1.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d"
+checksum = "6f61fba1741ea2b3d6a1e3178721804bb716a68a6aeba1149b5d52e3d464ea66"
 
 [[package]]
 name = "opaque-debug"
@@ -1294,17 +971,11 @@ version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5"
 
-[[package]]
-name = "openssl-probe"
-version = "0.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"
-
 [[package]]
 name = "os_str_bytes"
-version = "6.5.1"
+version = "6.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4d5d9eb14b174ee9aa2ef96dc2b94637a2d4b6e7cb873c7e171f0c20c6cf3eac"
+checksum = "9b7820b9daea5457c9f21c69448905d723fbd21136ccf521748f23fd49e723ee"
 
 [[package]]
 name = "osmosis-std"
@@ -1314,8 +985,8 @@ checksum = "10d6fe6ac7fcba45ed61d738091d33c838c4cabbcf4892dc7aa56d19d39cc976"
 dependencies = [
  "chrono",
  "cosmwasm-std",
- "osmosis-std-derive 0.13.2",
- "prost 0.11.9",
+ "osmosis-std-derive",
+ "prost 0.11.6",
  "prost-types",
  "schemars",
  "serde",
@@ -1323,77 +994,31 @@ dependencies = [
 ]
 
 [[package]]
-name = "osmosis-std"
-version = "0.16.2"
+name = "osmosis-std-derive"
+version = "0.13.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "75895e4db1a81ca29118e366365744f64314938327e4eedba8e6e462fb15e94f"
+checksum = "a455e262a6fdfd3914f3a4e11e6bc0ce491901cb9d507d7856d7ef6e129e90c6"
 dependencies = [
- "chrono",
- "cosmwasm-std",
- "osmosis-std-derive 0.16.2",
- "prost 0.11.9",
- "prost-types",
- "schemars",
- "serde",
- "serde-cw-value",
+ "itertools",
+ "proc-macro2",
+ "quote",
+ "syn",
 ]
 
 [[package]]
-name = "osmosis-std"
-version = "0.17.0-rc0"
+name = "osmosis-testing"
+version = "0.13.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c0b022b748710ecdf1adc6a124c3bef29f17ef05e7fa1260a08889d1d53f9cc5"
-dependencies = [
- "chrono",
- "cosmwasm-std",
- "osmosis-std-derive 0.16.2",
- "prost 0.11.9",
- "prost-types",
- "schemars",
- "serde",
- "serde-cw-value",
-]
-
-[[package]]
-name = "osmosis-std-derive"
-version = "0.13.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a455e262a6fdfd3914f3a4e11e6bc0ce491901cb9d507d7856d7ef6e129e90c6"
-dependencies = [
- "itertools 0.10.5",
- "proc-macro2",
- "quote",
- "syn 1.0.109",
-]
-
-[[package]]
-name = "osmosis-std-derive"
-version = "0.16.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f47f0b2f22adb341bb59e5a3a1b464dde033181954bd055b9ae86d6511ba465b"
-dependencies = [
- "itertools 0.10.5",
- "proc-macro2",
- "prost-types",
- "quote",
- "syn 1.0.109",
-]
-
-[[package]]
-name = "osmosis-test-tube"
-version = "17.0.0-rc0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "977a2b4f088dd704a47e96b5914e28465cfcdb1cb1145a1f9b45c219a9b145c5"
+checksum = "42636a83a181b7c4f94658eb3bb219caa51ff55bcc69750cd7ae4bf50b12cb2f"
 dependencies = [
  "base64",
  "bindgen",
  "cosmrs",
  "cosmwasm-std",
- "osmosis-std 0.17.0-rc0",
- "prost 0.11.9",
+ "osmosis-std",
+ "prost 0.11.6",
  "serde",
  "serde_json",
- "test-tube",
  "thiserror",
 ]
 
@@ -1404,13 +1029,16 @@ dependencies = [
  "bech32",
  "cosmwasm-schema",
  "cosmwasm-std",
+ "cosmwasm-storage",
  "crosschain-swaps",
  "cw-multi-test",
  "cw-storage-plus",
  "cw-utils",
  "cw2",
- "osmosis-std 0.16.2",
- "registry",
+ "osmosis-std",
+ "schemars",
+ "serde",
+ "serde-cw-value",
  "serde-json-wasm",
  "swaprouter",
  "thiserror",
@@ -1418,9 +1046,9 @@ dependencies = [
 
 [[package]]
 name = "paste"
-version = "1.0.14"
+version = "1.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"
+checksum = "d01a5bd0424d00070b0098dd17ebca6f961a959dead1dbcbbbc1d1cd8d3deeba"
 
 [[package]]
 name = "pbkdf2"
@@ -1428,7 +1056,7 @@ version = "0.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "83a0692ec44e4cf1ef28ca317f14f8f07da2d95ec3fa01f86e4467b725e60917"
 dependencies = [
- "digest 0.10.7",
+ "digest 0.10.6",
 ]
 
 [[package]]
@@ -1437,64 +1065,11 @@ version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"
 
-[[package]]
-name = "peg"
-version = "0.7.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "07c0b841ea54f523f7aa556956fbd293bcbe06f2e67d2eb732b7278aaf1d166a"
-dependencies = [
- "peg-macros",
- "peg-runtime",
-]
-
-[[package]]
-name = "peg-macros"
-version = "0.7.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b5aa52829b8decbef693af90202711348ab001456803ba2a98eb4ec8fb70844c"
-dependencies = [
- "peg-runtime",
- "proc-macro2",
- "quote",
-]
-
-[[package]]
-name = "peg-runtime"
-version = "0.7.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c719dcf55f09a3a7e764c6649ab594c18a177e3599c467983cdf644bfc0a4088"
-
-[[package]]
-name = "percent-encoding"
-version = "2.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9b2a4787296e9989611394c33f193f676704af1686e70b8f8033ab5ba9a35a94"
-
-[[package]]
-name = "pin-project"
-version = "1.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fda4ed1c6c173e3fc7a83629421152e01d7b1f9b7f65fb301e490e8cfc656422"
-dependencies = [
- "pin-project-internal",
-]
-
-[[package]]
-name = "pin-project-internal"
-version = "1.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4359fd9c9171ec6e8c62926d6faaf553a8dc3f64e1507e76da7911b4f6a04405"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.29",
-]
-
 [[package]]
 name = "pin-project-lite"
-version = "0.2.13"
+version = "0.2.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8afb450f006bf6385ca15ef45d71d2288452bc3683ce2e2cacc0d18e4be60b58"
+checksum = "e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116"
 
 [[package]]
 name = "pin-utils"
@@ -1514,9 +1089,9 @@ dependencies = [
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.66"
+version = "1.0.50"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "18fb31db3f9bddb2ea821cde30a9f70117e3f119938b5ee630b7403aa6e2ead9"
+checksum = "6ef7d57beacfaf2d8aee5937dab7b7f28de3cb8b1828479bb5de2a7106f2bae2"
 dependencies = [
  "unicode-ident",
 ]
@@ -1533,12 +1108,12 @@ dependencies = [
 
 [[package]]
 name = "prost"
-version = "0.11.9"
+version = "0.11.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0b82eaa1d779e9a4bc1c3217db8ffbeabaae1dca241bf70183242128d48681cd"
+checksum = "21dc42e00223fc37204bd4aa177e69420c604ca4a183209a8f9de30c6d934698"
 dependencies = [
  "bytes",
- "prost-derive 0.11.9",
+ "prost-derive 0.11.6",
 ]
 
 [[package]]
@@ -1548,39 +1123,40 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f9cc1a3263e07e0bf68e96268f37665207b49560d98739662cdfaae215c720fe"
 dependencies = [
  "anyhow",
- "itertools 0.10.5",
+ "itertools",
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
 ]
 
 [[package]]
 name = "prost-derive"
-version = "0.11.9"
+version = "0.11.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e5d2d8d10f3c6ded6da8b05b5fb3b8a5082514344d56c9f871412d29b4e075b4"
+checksum = "8bda8c0881ea9f722eb9629376db3d0b903b462477c1aafcb0566610ac28ac5d"
 dependencies = [
  "anyhow",
- "itertools 0.10.5",
+ "itertools",
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
 ]
 
 [[package]]
 name = "prost-types"
-version = "0.11.9"
+version = "0.11.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "213622a1460818959ac1181aaeb2dc9c7f63df720db7d788b3e24eacd1983e13"
+checksum = "a5e0526209433e96d83d750dd81a99118edbc55739e7e61a46764fd2ad537788"
 dependencies = [
- "prost 0.11.9",
+ "bytes",
+ "prost 0.11.6",
 ]
 
 [[package]]
 name = "quote"
-version = "1.0.33"
+version = "1.0.23"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5267fca4496028628a95160fc423a33e8b2e6af8a5302579e322e4b520293cae"
+checksum = "8856d8364d252a14d474036ea1358d63c9e6965c8e5c1885c18f73d70bff9c7b"
 dependencies = [
  "proc-macro2",
 ]
@@ -1602,21 +1178,9 @@ dependencies = [
 
 [[package]]
 name = "regex"
-version = "1.9.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "12de2eff854e5fa4b1295edd650e227e9d8fb0c9e90b12e7f36d6a6811791a29"
-dependencies = [
- "aho-corasick",
- "memchr",
- "regex-automata",
- "regex-syntax",
-]
-
-[[package]]
-name = "regex-automata"
-version = "0.3.7"
+version = "1.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "49530408a136e16e5b486e883fbb6ba058e8e4e8ae6621a77b048b314336e629"
+checksum = "48aaa5748ba571fb95cd2c85c09f629215d3a6ece942baa100950af03a34f733"
 dependencies = [
  "aho-corasick",
  "memchr",
@@ -1625,29 +1189,9 @@ dependencies = [
 
 [[package]]
 name = "regex-syntax"
-version = "0.7.5"
+version = "0.6.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dbb5fb1acd8a1a18b3dd5be62d25485eb770e05afb408a9627d14d451bae12da"
-
-[[package]]
-name = "registry"
-version = "0.1.0"
-dependencies = [
- "bech32",
- "cosmwasm-schema",
- "cosmwasm-std",
- "hex",
- "itertools 0.11.0",
- "osmosis-std 0.13.2",
- "osmosis-std-derive 0.13.2",
- "prost 0.11.9",
- "schemars",
- "serde",
- "serde-cw-value",
- "serde-json-wasm",
- "sha2 0.10.7",
- "thiserror",
-]
+checksum = "456c603be3e8d448b072f410900c09faf164fbce2d480456f50eea6e25f9c848"
 
 [[package]]
 name = "rfc6979"
@@ -1660,28 +1204,13 @@ dependencies = [
  "zeroize",
 ]
 
-[[package]]
-name = "ring"
-version = "0.16.20"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3053cf52e236a3ed746dfc745aa9cacf1b791d846bdaf412f60a8d7d6e17c8fc"
-dependencies = [
- "cc",
- "libc",
- "once_cell",
- "spin",
- "untrusted",
- "web-sys",
- "winapi",
-]
-
 [[package]]
 name = "ripemd"
 version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bd124222d17ad93a644ed9d011a40f4fb64aa54275c08cc216524a9ea82fb09f"
 dependencies = [
- "digest 0.10.7",
+ "digest 0.10.6",
 ]
 
 [[package]]
@@ -1695,72 +1224,23 @@ dependencies = [
  "opaque-debug",
 ]
 
-[[package]]
-name = "rustc-demangle"
-version = "0.1.23"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"
-
 [[package]]
 name = "rustc-hash"
 version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
 
-[[package]]
-name = "rustls"
-version = "0.19.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "35edb675feee39aec9c99fa5ff985081995a06d594114ae14cbe797ad7b7a6d7"
-dependencies = [
- "base64",
- "log",
- "ring",
- "sct",
- "webpki",
-]
-
-[[package]]
-name = "rustls-native-certs"
-version = "0.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5a07b7c1885bd8ed3831c289b7870b13ef46fe0e856d288c30d9cc17d75a2092"
-dependencies = [
- "openssl-probe",
- "rustls",
- "schannel",
- "security-framework",
-]
-
 [[package]]
 name = "ryu"
-version = "1.0.15"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ad4cc8da4ef723ed60bced201181d83791ad433213d8c24efffda1eec85d741"
-
-[[package]]
-name = "same-file"
-version = "1.0.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
-dependencies = [
- "winapi-util",
-]
-
-[[package]]
-name = "schannel"
-version = "0.1.22"
+version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0c3733bf4cf7ea0880754e19cb5a462007c4a8c1914bff372ccc95b464f1df88"
-dependencies = [
- "windows-sys",
-]
+checksum = "7b4b9743ed687d4b4bcedf9ff5eaa7398495ae14e61cba0a295704edbc7decde"
 
 [[package]]
 name = "schemars"
-version = "0.8.13"
+version = "0.8.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "763f8cd0d4c71ed8389c90cb8100cba87e763bd01a8e614d4f0af97bcd50a161"
+checksum = "2a5fb6c61f29e723026dc8e923d94c694313212abbecbbe5f55a7748eec5b307"
 dependencies = [
  "dyn-clone",
  "schemars_derive",
@@ -1770,24 +1250,14 @@ dependencies = [
 
 [[package]]
 name = "schemars_derive"
-version = "0.8.13"
+version = "0.8.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ec0f696e21e10fa546b7ffb1c9672c6de8fbc7a81acf59524386d8639bf12737"
+checksum = "f188d036977451159430f3b8dc82ec76364a42b7e289c2b18a9a18f4470058e9"
 dependencies = [
  "proc-macro2",
  "quote",
  "serde_derive_internals",
- "syn 1.0.109",
-]
-
-[[package]]
-name = "sct"
-version = "0.6.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b362b83898e0e69f38515b82ee15aa80636befe47c3b6d3d89a911e78fc228ce"
-dependencies = [
- "ring",
- "untrusted",
+ "syn",
 ]
 
 [[package]]
@@ -1804,40 +1274,17 @@ dependencies = [
  "zeroize",
 ]
 
-[[package]]
-name = "security-framework"
-version = "2.9.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05b64fb303737d99b81884b2c63433e9ae28abebe5eb5045dcdd175dc2ecf4de"
-dependencies = [
- "bitflags",
- "core-foundation",
- "core-foundation-sys",
- "libc",
- "security-framework-sys",
-]
-
-[[package]]
-name = "security-framework-sys"
-version = "2.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e932934257d3b408ed8f30db49d85ea163bfe74961f017f405b025af298f0c7a"
-dependencies = [
- "core-foundation-sys",
- "libc",
-]
-
 [[package]]
 name = "semver"
-version = "1.0.18"
+version = "1.0.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b0293b4b29daaf487284529cc2f5675b8e57c61f70167ba415a463651fd6a918"
+checksum = "58bc9567378fc7690d6b2addae4e60ac2eeea07becb2c64b9f218b53865cba2a"
 
 [[package]]
 name = "serde"
-version = "1.0.188"
+version = "1.0.152"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cf9e0fcba69a370eed61bcf2b728575f726b50b55cba78064753d708ddc7549e"
+checksum = "bb7d1f0d3021d347a83e556fc4683dea2ea09d87bccdf88ff5c12545d89d5efb"
 dependencies = [
  "serde_derive",
 ]
@@ -1853,31 +1300,31 @@ dependencies = [
 
 [[package]]
 name = "serde-json-wasm"
-version = "0.5.2"
+version = "0.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9e9213a07d53faa0b8dd81e767a54a8188a242fdb9be99ab75ec576a774bfdd7"
+checksum = "a15bee9b04dd165c3f4e142628982ddde884c2022a89e8ddf99c4829bf2c3a58"
 dependencies = [
  "serde",
 ]
 
 [[package]]
 name = "serde_bytes"
-version = "0.11.12"
+version = "0.11.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ab33ec92f677585af6d88c65593ae2375adde54efdbf16d597f2cbc7a6d368ff"
+checksum = "718dc5fff5b36f99093fc49b280cfc96ce6fc824317783bff5a1fed0c7a64819"
 dependencies = [
  "serde",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.188"
+version = "1.0.152"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4eca7ac642d82aa35b60049a6eccb4be6be75e599bd2e9adb5f875a737654af2"
+checksum = "af487d118eecd09402d70a5d72551860e788df87b464af30e5ea6a38c75c541e"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.29",
+ "syn",
 ]
 
 [[package]]
@@ -1888,14 +1335,14 @@ checksum = "85bf8229e7920a9f636479437026331ce11aa132b4dde37d121944a44d6e5f3c"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.105"
+version = "1.0.91"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "693151e1ac27563d6dbcec9dee9fbd5da8539b20fa14ad3752b2e6d363ace360"
+checksum = "877c235533714907a8c2464236f5c4b2a17262ef1bd71f38f35ea592c8da6883"
 dependencies = [
  "itoa",
  "ryu",
@@ -1904,24 +1351,13 @@ dependencies = [
 
 [[package]]
 name = "serde_repr"
-version = "0.1.16"
+version = "0.1.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8725e1dfadb3a50f7e5ce0b1a540466f6ed3fe7a0fca2ac2b8b831d31316bd00"
+checksum = "9a5ec9fa74a20ebbe5d9ac23dac1fc96ba0ecfe9f50f2843b52e537b10fbcb4e"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.29",
-]
-
-[[package]]
-name = "sha1"
-version = "0.10.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f04293dc80c3993519f2d7f6f511707ee7094fe0c6d3406feb330cdb3540eba3"
-dependencies = [
- "cfg-if",
- "cpufeatures",
- "digest 0.10.7",
+ "syn",
 ]
 
 [[package]]
@@ -1939,30 +1375,30 @@ dependencies = [
 
 [[package]]
 name = "sha2"
-version = "0.10.7"
+version = "0.10.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "479fb9d862239e610720565ca91403019f2f00410f1864c5aa7479b950a76ed8"
+checksum = "82e6b795fe2e3b1e845bafcb27aa35405c4d47cdfc92af5fc8d3002f76cebdc0"
 dependencies = [
  "cfg-if",
  "cpufeatures",
- "digest 0.10.7",
+ "digest 0.10.6",
 ]
 
 [[package]]
 name = "sha3"
-version = "0.10.8"
+version = "0.10.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
+checksum = "bdf0c33fae925bdc080598b84bc15c55e7b9a4a43b3c704da051f977469691c9"
 dependencies = [
- "digest 0.10.7",
+ "digest 0.10.6",
  "keccak",
 ]
 
 [[package]]
 name = "shlex"
-version = "1.3.0"
+version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"
+checksum = "43b2853a4d09f215c24cc5489c992ce46052d359b5109343cbafbf26bc62f8a3"
 
 [[package]]
 name = "signature"
@@ -1970,45 +1406,10 @@ version = "1.6.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "74233d3b3b2f6d4b006dc19dee745e73e2a6bfb6f93607cd3b02bd5b00797d7c"
 dependencies = [
- "digest 0.10.7",
+ "digest 0.10.6",
  "rand_core 0.6.4",
 ]
 
-[[package]]
-name = "slab"
-version = "0.4.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
-dependencies = [
- "autocfg",
-]
-
-[[package]]
-name = "socket2"
-version = "0.4.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "64a4a911eed85daf18834cfaa86a79b7d266ff93ff5ba14005426219480ed662"
-dependencies = [
- "libc",
- "winapi",
-]
-
-[[package]]
-name = "socket2"
-version = "0.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2538b18701741680e0322a2302176d3253a35388e2e62f172f64f4f16605f877"
-dependencies = [
- "libc",
- "windows-sys",
-]
-
-[[package]]
-name = "spin"
-version = "0.5.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
-
 [[package]]
 name = "spki"
 version = "0.6.0"
@@ -2019,6 +1420,12 @@ dependencies = [
  "der",
 ]
 
+[[package]]
+name = "static_assertions"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"
+
 [[package]]
 name = "strsim"
 version = "0.10.0"
@@ -2027,9 +1434,9 @@ checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"
 
 [[package]]
 name = "subtle"
-version = "2.5.0"
+version = "2.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "81cdd64d312baedb58e21336b31bc043b77e01cc99033ce76ef539f78e965ebc"
+checksum = "6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601"
 
 [[package]]
 name = "subtle-encoding"
@@ -2046,10 +1453,11 @@ version = "0.1.0"
 dependencies = [
  "cosmwasm-schema",
  "cosmwasm-std",
+ "cosmwasm-storage",
  "cw-storage-plus",
  "cw2",
- "osmosis-std 0.16.2",
- "osmosis-test-tube",
+ "osmosis-std",
+ "osmosis-testing",
  "schemars",
  "serde",
  "thiserror",
@@ -2057,9 +1465,9 @@ dependencies = [
 
 [[package]]
 name = "syn"
-version = "1.0.109"
+version = "1.0.107"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
+checksum = "1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -2067,14 +1475,15 @@ dependencies = [
 ]
 
 [[package]]
-name = "syn"
-version = "2.0.29"
+name = "synstructure"
+version = "0.12.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c324c494eba9d92503e6f1ef2e6df781e78f6a7705a0202d9801b198807d518a"
+checksum = "f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f"
 dependencies = [
  "proc-macro2",
  "quote",
- "unicode-ident",
+ "syn",
+ "unicode-xid",
 ]
 
 [[package]]
@@ -2092,7 +1501,7 @@ dependencies = [
  "k256",
  "num-traits",
  "once_cell",
- "prost 0.11.9",
+ "prost 0.11.6",
  "prost-types",
  "ripemd160",
  "serde",
@@ -2108,20 +1517,6 @@ dependencies = [
  "zeroize",
 ]
 
-[[package]]
-name = "tendermint-config"
-version = "0.23.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2d42ee0abc27ef5fc34080cce8d43c189950d331631546e7dfb983b6274fa327"
-dependencies = [
- "flex-error",
- "serde",
- "serde_json",
- "tendermint",
- "toml",
- "url",
-]
-
 [[package]]
 name = "tendermint-proto"
 version = "0.23.9"
@@ -2132,7 +1527,7 @@ dependencies = [
  "flex-error",
  "num-derive",
  "num-traits",
- "prost 0.11.9",
+ "prost 0.11.6",
  "prost-types",
  "serde",
  "serde_bytes",
@@ -2140,39 +1535,6 @@ dependencies = [
  "time",
 ]
 
-[[package]]
-name = "tendermint-rpc"
-version = "0.23.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6f14aafe3528a0f75e9f3f410b525617b2de16c4b7830a21f717eee62882ec60"
-dependencies = [
- "async-trait",
- "bytes",
- "flex-error",
- "futures",
- "getrandom",
- "http",
- "hyper",
- "hyper-proxy",
- "hyper-rustls",
- "peg",
- "pin-project",
- "serde",
- "serde_bytes",
- "serde_json",
- "subtle-encoding",
- "tendermint",
- "tendermint-config",
- "tendermint-proto",
- "thiserror",
- "time",
- "tokio",
- "tracing",
- "url",
- "uuid",
- "walkdir",
-]
-
 [[package]]
 name = "termcolor"
 version = "1.2.0"
@@ -2182,22 +1544,6 @@ dependencies = [
  "winapi-util",
 ]
 
-[[package]]
-name = "test-tube"
-version = "0.1.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "09b1f7cafdf7738331999fb1465d2d3032f08ac61940e1ef4601dbbef21d6a5e"
-dependencies = [
- "base64",
- "cosmrs",
- "cosmwasm-std",
- "osmosis-std 0.17.0-rc0",
- "prost 0.11.9",
- "serde",
- "serde_json",
- "thiserror",
-]
-
 [[package]]
 name = "textwrap"
 version = "0.16.0"
@@ -2206,22 +1552,22 @@ checksum = "222a222a5bfe1bba4a77b45ec488a741b3cb8872e5e499451fd7d0129c9c7c3d"
 
 [[package]]
 name = "thiserror"
-version = "1.0.47"
+version = "1.0.38"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "97a802ec30afc17eee47b2855fc72e0c4cd62be9b4efe6591edde0ec5bd68d8f"
+checksum = "6a9cd18aa97d5c45c6603caea1da6628790b37f7a34b6ca89522331c5180fed0"
 dependencies = [
  "thiserror-impl",
 ]
 
 [[package]]
 name = "thiserror-impl"
-version = "1.0.47"
+version = "1.0.38"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6bb623b56e39ab7dcd4b1b98bb6c8f8d907ed255b18de254088016b27a8ee19b"
+checksum = "1fb327af4685e4d03fa8cbcf1716380da910eeb2bb8be417e7f9fd3fb164f36f"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.29",
+ "syn",
 ]
 
 [[package]]
@@ -2241,115 +1587,6 @@ version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "42657b1a6f4d817cda8e7a0ace261fe0cc946cf3a80314390b22cc61ae080792"
 
-[[package]]
-name = "tinyvec"
-version = "1.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
-dependencies = [
- "tinyvec_macros",
-]
-
-[[package]]
-name = "tinyvec_macros"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
-
-[[package]]
-name = "tokio"
-version = "1.32.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "17ed6077ed6cd6c74735e21f37eb16dc3935f96878b1fe961074089cc80893f9"
-dependencies = [
- "backtrace",
- "bytes",
- "libc",
- "mio",
- "num_cpus",
- "pin-project-lite",
- "socket2 0.5.3",
- "tokio-macros",
- "windows-sys",
-]
-
-[[package]]
-name = "tokio-macros"
-version = "2.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "630bdcf245f78637c13ec01ffae6187cca34625e8c63150d424b59e55af2675e"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.29",
-]
-
-[[package]]
-name = "tokio-rustls"
-version = "0.22.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bc6844de72e57df1980054b38be3a9f4702aba4858be64dd700181a8a6d0e1b6"
-dependencies = [
- "rustls",
- "tokio",
- "webpki",
-]
-
-[[package]]
-name = "tokio-util"
-version = "0.7.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "806fe8c2c87eccc8b3267cbae29ed3ab2d0bd37fca70ab622e46aaa9375ddb7d"
-dependencies = [
- "bytes",
- "futures-core",
- "futures-sink",
- "pin-project-lite",
- "tokio",
- "tracing",
-]
-
-[[package]]
-name = "toml"
-version = "0.5.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
-dependencies = [
- "serde",
-]
-
-[[package]]
-name = "tower-service"
-version = "0.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b6bc1c9ce2b5135ac7f93c72918fc37feb872bdc6a5533a8b85eb4b86bfdae52"
-
-[[package]]
-name = "tracing"
-version = "0.1.37"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8ce8c33a8d48bd45d624a6e523445fd21ec13d3653cd51f681abf67418f54eb8"
-dependencies = [
- "cfg-if",
- "pin-project-lite",
- "tracing-core",
-]
-
-[[package]]
-name = "tracing-core"
-version = "0.1.31"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0955b8137a1df6f1a2e9a37d8a6656291ff0297c1a97c24e0d8425fe2312f79a"
-dependencies = [
- "once_cell",
-]
-
-[[package]]
-name = "try-lock"
-version = "0.2.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3528ecfd12c466c6f163363caf2d02a71161dd5e1cc6ae7b34207ea2d42d81ed"
-
 [[package]]
 name = "typenum"
 version = "1.16.0"
@@ -2357,48 +1594,28 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba"
 
 [[package]]
-name = "unicode-bidi"
-version = "0.3.13"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "92888ba5573ff080736b3648696b70cafad7d250551175acbaa4e0385b3e1460"
-
-[[package]]
-name = "unicode-ident"
-version = "1.0.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "301abaae475aa91687eb82514b328ab47a211a533026cb25fc3e519b86adfc3c"
-
-[[package]]
-name = "unicode-normalization"
-version = "0.1.22"
+name = "uint"
+version = "0.9.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
+checksum = "76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52"
 dependencies = [
- "tinyvec",
+ "byteorder",
+ "crunchy",
+ "hex",
+ "static_assertions",
 ]
 
 [[package]]
-name = "untrusted"
-version = "0.7.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a156c684c91ea7d62626509bce3cb4e1d9ed5c4d978f7b4352658f96a4c26b4a"
-
-[[package]]
-name = "url"
-version = "2.4.1"
+name = "unicode-ident"
+version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "143b538f18257fac9cad154828a57c6bf5157e1aa604d4816b5995bf6de87ae5"
-dependencies = [
- "form_urlencoded",
- "idna",
- "percent-encoding",
-]
+checksum = "84a22b9f218b40614adcb3f4ff08b703773ad44fa9423e4e0d346d5db86e4ebc"
 
 [[package]]
-name = "uuid"
-version = "0.8.2"
+name = "unicode-xid"
+version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bc5cf98d8186244414c848017f0e2676b3fcb46807f6668a97dfe67359a3c4b7"
+checksum = "f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c"
 
 [[package]]
 name = "version_check"
@@ -2406,25 +1623,6 @@ version = "0.9.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"
 
-[[package]]
-name = "walkdir"
-version = "2.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "36df944cda56c7d8d8b7496af378e6b16de9284591917d307c9b4d313c44e698"
-dependencies = [
- "same-file",
- "winapi-util",
-]
-
-[[package]]
-name = "want"
-version = "0.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
-dependencies = [
- "try-lock",
-]
-
 [[package]]
 name = "wasi"
 version = "0.11.0+wasi-snapshot-preview1"
@@ -2433,9 +1631,9 @@ checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.87"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7706a72ab36d8cb1f80ffbf0e071533974a60d0a308d01a5d0375bf60499a342"
+checksum = "eaf9f5aceeec8be17c128b2e93e031fb8a4d469bb9c4ae2d7dc1888b26887268"
 dependencies = [
  "cfg-if",
  "wasm-bindgen-macro",
@@ -2443,24 +1641,24 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.87"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5ef2b6d3c510e9625e5fe6f509ab07d66a760f0885d858736483c32ed7809abd"
+checksum = "4c8ffb332579b0557b52d268b91feab8df3615f265d5270fec2a8c95b17c1142"
 dependencies = [
  "bumpalo",
  "log",
  "once_cell",
  "proc-macro2",
  "quote",
- "syn 2.0.29",
+ "syn",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.87"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dee495e55982a3bd48105a7b947fd2a9b4a8ae3010041b9e0faab3f9cd028f1d"
+checksum = "052be0f94026e6cbc75cdefc9bae13fd6052cdcaf532fa6c45e7ae33a1e6c810"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
@@ -2468,57 +1666,28 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.87"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "54681b18a46765f095758388f2d0cf16eb8d4169b639ab575a8f5693af210c7b"
+checksum = "07bc0c051dc5f23e307b13285f9d75df86bfdf816c5721e573dec1f9b8aa193c"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.29",
+ "syn",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.87"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ca6ad05a4870b2bf5fe995117d3728437bd27d7cd5f06f13c17443ef369775a1"
-
-[[package]]
-name = "web-sys"
-version = "0.3.64"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9b85cbef8c220a6abc02aefd892dfc0fc23afb1c6a426316ec33253a3877249b"
-dependencies = [
- "js-sys",
- "wasm-bindgen",
-]
-
-[[package]]
-name = "webpki"
-version = "0.21.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b8e38c0608262c46d4a56202ebabdeb094cef7e560ca7a226c6bf055188aa4ea"
-dependencies = [
- "ring",
- "untrusted",
-]
-
-[[package]]
-name = "webpki-roots"
-version = "0.21.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aabe153544e473b775453675851ecc86863d2a81d786d741f6b76778f2a48940"
-dependencies = [
- "webpki",
-]
+checksum = "1c38c045535d93ec4f0b4defec448e4291638ee608530863b1e2ba115d4fff7f"
 
 [[package]]
 name = "which"
-version = "4.4.0"
+version = "4.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2441c784c52b289a054b7201fc93253e288f094e2f4be9058343127c4226a269"
+checksum = "1c831fbbee9e129a8cf93e7747a82da9d95ba8e16621cae60ec2cdc849bacb7b"
 dependencies = [
  "either",
  "libc",
@@ -2556,88 +1725,23 @@ version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
-[[package]]
-name = "windows-sys"
-version = "0.48.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
-dependencies = [
- "windows-targets",
-]
-
-[[package]]
-name = "windows-targets"
-version = "0.48.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
-dependencies = [
- "windows_aarch64_gnullvm",
- "windows_aarch64_msvc",
- "windows_i686_gnu",
- "windows_i686_msvc",
- "windows_x86_64_gnu",
- "windows_x86_64_gnullvm",
- "windows_x86_64_msvc",
-]
-
-[[package]]
-name = "windows_aarch64_gnullvm"
-version = "0.48.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
-
-[[package]]
-name = "windows_aarch64_msvc"
-version = "0.48.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
-
-[[package]]
-name = "windows_i686_gnu"
-version = "0.48.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
-
-[[package]]
-name = "windows_i686_msvc"
-version = "0.48.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
-
-[[package]]
-name = "windows_x86_64_gnu"
-version = "0.48.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
-
-[[package]]
-name = "windows_x86_64_gnullvm"
-version = "0.48.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
-
-[[package]]
-name = "windows_x86_64_msvc"
-version = "0.48.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
-
 [[package]]
 name = "zeroize"
-version = "1.6.0"
+version = "1.5.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2a0956f1ba7c7909bfb66c2e9e4124ab6f6482560f6628b5aaeba39207c9aad9"
+checksum = "c394b5bd0c6f669e7275d9c20aa90ae064cb22e75a1cad54e1b34088034b149f"
 dependencies = [
  "zeroize_derive",
 ]
 
 [[package]]
 name = "zeroize_derive"
-version = "1.4.2"
+version = "1.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
+checksum = "44bf07cb3e50ea2003396695d58bf46bc9887a1f362260446fad6bc4e79bd36c"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.29",
+ "syn",
+ "synstructure",
 ]
diff --git a/cosmwasm/Cargo.toml b/cosmwasm/Cargo.toml
index 34fd76c39..f36b45d72 100644
--- a/cosmwasm/Cargo.toml
+++ b/cosmwasm/Cargo.toml
@@ -1,7 +1,6 @@
 [workspace]
 members = [
   'contracts/*',
-  'packages/*'
 ]
 
 [workspace.package]
@@ -28,13 +27,12 @@ cosmwasm-storage = "1.1.2"
 cw-storage-plus = "1.0.1"
 cw2 = "1.0.0"
 schemars = "0.8.11"
-osmosis-std = "0.16.2"
+osmosis-std = "0.13.2"
 serde = { version = "1.0.137", default-features = false, features = ["derive"] }
 thiserror = { version = "1.0.31" }
 cw-multi-test = "0.16.1"
-osmosis-test-tube = "17.0.0-rc0"
-serde-json-wasm = "0.5.2"
+osmosis-testing = "0.13.2"
+serde-json-wasm = "0.5.0"
 serde-cw-value = "0.7.0"
 bech32 = "0.9.1"
 cw-utils = "1.0.0"
-itertools = "0.11.0"
diff --git a/cosmwasm/contracts/crosschain-registry/.cargo/config b/cosmwasm/contracts/crosschain-registry/.cargo/config
deleted file mode 100644
index af5698e58..000000000
--- a/cosmwasm/contracts/crosschain-registry/.cargo/config
+++ /dev/null
@@ -1,4 +0,0 @@
-[alias]
-wasm = "build --release --lib --target wasm32-unknown-unknown"
-unit-test = "test --lib"
-schema = "run --bin schema"
diff --git a/cosmwasm/contracts/crosschain-registry/Cargo.toml b/cosmwasm/contracts/crosschain-registry/Cargo.toml
deleted file mode 100644
index 9bb9baab6..000000000
--- a/cosmwasm/contracts/crosschain-registry/Cargo.toml
+++ /dev/null
@@ -1,57 +0,0 @@
-# This feature has been stabilized in 1.64. If using an earlier version (like in
-# rust-optimizer-arm:0.12.8) you should uncomment this like to be able to
-# compile the contract
-#
-#cargo-features = ["workspace-inheritance"]
-
-[package]
-name = "crosschain-registry"
-version = "0.1.0"
-authors = ["Adam Tucker <adam@osmosis.team>", "Nicolas Lara <nicolaslara@gmail.com>"]
-edition = "2021"
-
-exclude = [
-  # Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication.
-  "contract.wasm",
-  "hash.txt",
-]
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[lib]
-crate-type = ["cdylib", "rlib"]
-
-[features]
-# for more explicit tests, cargo test --features=backtraces
-backtraces = ["cosmwasm-std/backtraces"]
-# use imported feature to disable all instantiate/execute/query exports
-imported = []
-
-[package.metadata.scripts]
-optimize = """docker run --rm -v "$(pwd)":/code \
-  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
-  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
-  cosmwasm/rust-optimizer:0.12.11
-"""
-optimize-m1 = """docker run --rm -v "$(pwd)":/code \
-  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
-  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
-  cosmwasm/rust-optimizer-arm64:0.12.11
-"""
-
-[[bin]]
-name = "build-schema"
-path = "build-schema/schema.rs"
-
-[dependencies]
-cosmwasm-schema =  { workspace = true }
-cosmwasm-std =  { workspace = true }
-cw-storage-plus = { workspace = true }
-cw2 = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-cw-utils = { workspace = true }
-registry = { path = "../../packages/registry"}
-
-[dev-dependencies]
-cw-multi-test = "0.16.2"
diff --git a/cosmwasm/contracts/crosschain-registry/README.md b/cosmwasm/contracts/crosschain-registry/README.md
deleted file mode 100644
index 476a915f6..000000000
--- a/cosmwasm/contracts/crosschain-registry/README.md
+++ /dev/null
@@ -1,65 +0,0 @@
-# Swap Router Registry Contract
-
-This is a CosmWasm smart contract that allows the creation and maintenance of cross-chain connection channels between IBC-enabled blockchains. This contract acts as a central registry where various blockchains can create, update, and delete IBC channels in a coordinated way, without having to deal with the complexity of handling low-level details when creating cross-chain swap messages.
-
-The registry contains the following mappings:
-
-- contract alias to contract address
-  - maps a human-readable name to the address of a target contract
-- chain channel to source chain/destination chain
-  - maps a channel number to the source and destination chains it connects to
-- chain name to Bech32 prefix
-  - maps a chain name to its corresponding Bech32 prefix, which is used for address encoding
-
-It also exposes a query entry point to retrieve the address from the alias, the destination chain from the source chain via the channel, the channel from the chain pair, the bech32 prefix from the chain name, and the native denom on the source chain from the IBC denom trace.
-
-There are three levels of permission this contract supports:
-- global admin
-  - can add, update, or delete contract alias registry entries
-  - can add, update, delete, enable, or disable all chain registry connections
-- chain admin
-  - can add, update, delete, enable, or disable the chain registry connections for a specific chain
-- chain maintainer
-  - can add, enable, or disable the chain registry connections for a specific chain
-
-![](./xcs_regsitry_permission_chart.jpeg)
-
-## Operations
-
-### ModifyContractAlias
-
-The `ModifyContractAlias` operation allows the contract owner to create, update, or delete aliases that can be used to identify contracts on other blockchains. The operation expects a vector of ContractAliasOperation, where each operation is either a CreateAlias, UpdateAlias, or DeleteAlias operation.
-
-### ModifyChainChannelLinks
-
-The `ModifyChainChannelLinks` operation allows the owner (or an authorized address for a specific source_chain) to create, update, or delete IBC channel links between each chain. The operation expects a vector of ConnectionOperation, where each operation is either a CreateConnection, UpdateConnection, or DeleteConnection operation.
-
-### ModifyBech32Prefixes
-
-The `ModifyBech32Prefixes` operation allows the owner (or an authorized address for a specific source_chain) to create, update, or delete Bech32 prefixes for each chain. The operation expects a vector of ChainToPrefixOperation, where each operation is either a CreatePrefix, UpdatePrefix, or DeletePrefix operation.
-
-### UnwrapCoin
-
-The `UnwrapCoin` operation allows the contract to take an IBC denom and returns an IBC TransferMsg that can be used by the caller to send the coins to the source chain (unwrapping the IBC denom) and then to a receiver chain so the resulting denom goes only through one IBC hop.
-
-## Queries
-
-### GetAddressFromAlias
-
-The `GetAddressFromAlias` query allows a caller to retrieve the address of a contract on another blockchain, given the alias of that contract.
-
-### GetDestinationChainFromSourceChainViaChannel
-
-The `GetDestinationChainFromSourceChainViaChannel` query allows a caller to retrieve the destination chain for an IBC channel given the source chain and the channel id.
-
-### GetChannelFromChainPair
-
-The `GetChannelFromChainPair` query allows a caller to retrieve the channel id for an IBC channel given the source and destination chain.
-
-### GetBech32PrefixFromChainName
-
-The `GetBech32PrefixFromChainName` query allows a caller to retrieve the Bech32 prefix for a given chain.
-
-### GetDenomTrace
-
-The `GetDenomTrace` query allows a caller to retrieve the denom trace for a given IBC denom.
diff --git a/cosmwasm/contracts/crosschain-registry/build-schema/schema.rs b/cosmwasm/contracts/crosschain-registry/build-schema/schema.rs
deleted file mode 100644
index c33754e07..000000000
--- a/cosmwasm/contracts/crosschain-registry/build-schema/schema.rs
+++ /dev/null
@@ -1,12 +0,0 @@
-use cosmwasm_schema::write_api;
-
-use crosschain_registry::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
-
-fn main() {
-    write_api! {
-        name: "crosschain-registry",
-        instantiate: InstantiateMsg,
-        query: QueryMsg,
-        execute: ExecuteMsg,
-    };
-}
diff --git a/cosmwasm/contracts/crosschain-registry/src/contract.rs b/cosmwasm/contracts/crosschain-registry/src/contract.rs
deleted file mode 100644
index fc9e48a21..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/contract.rs
+++ /dev/null
@@ -1,405 +0,0 @@
-#[cfg(not(feature = "imported"))]
-use cosmwasm_std::entry_point;
-use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
-use cw2::set_contract_version;
-
-use crate::error::ContractError;
-use crate::msg::{
-    ExecuteMsg, GetAddressFromAliasResponse, IBCLifecycleComplete, InstantiateMsg, QueryMsg,
-    SudoMsg,
-};
-use crate::state::{ChainPFM, Config, CHAIN_PFM_MAP, CONFIG, CONTRACT_ALIAS_MAP};
-use crate::{execute, ibc_lifecycle, query};
-use registry::Registry;
-
-// version info for migration
-const CONTRACT_NAME: &str = "crates.io:crosschain-registry";
-const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");
-
-// The name of the chain on which this contract is instantiated
-pub const CONTRACT_CHAIN: &str = "osmosis";
-
-#[cfg_attr(not(feature = "imported"), entry_point)]
-pub fn instantiate(
-    deps: DepsMut,
-    _env: Env,
-    _info: MessageInfo,
-    msg: InstantiateMsg,
-) -> Result<Response, ContractError> {
-    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
-
-    // validate owner address and save to state
-    let owner = deps.api.addr_validate(&msg.owner)?;
-    let state = Config { owner };
-    CONFIG.save(deps.storage, &state)?;
-
-    CHAIN_PFM_MAP.save(
-        deps.storage,
-        CONTRACT_CHAIN,
-        &ChainPFM {
-            acknowledged: true,
-            validated: true,
-            initiator: None,
-        },
-    )?;
-
-    Ok(Response::new().add_attribute("method", "instantiate"))
-}
-
-#[cfg_attr(not(feature = "imported"), entry_point)]
-pub fn execute(
-    deps: DepsMut,
-    env: Env,
-    info: MessageInfo,
-    msg: ExecuteMsg,
-) -> Result<Response, ContractError> {
-    match msg {
-        ExecuteMsg::ModifyDenomAlias { operations } => {
-            execute::denom_alias_operations(deps, info.sender, operations)
-        }
-
-        // Contract aliases
-        ExecuteMsg::ModifyContractAlias { operations } => {
-            execute::contract_alias_operations(deps, info.sender, operations)
-        }
-
-        // Chain channel links
-        ExecuteMsg::ModifyChainChannelLinks { operations } => {
-            execute::connection_operations(deps, info.sender, operations)
-        }
-
-        // Bech32 prefixes
-        ExecuteMsg::ModifyBech32Prefixes { operations } => {
-            execute::chain_to_prefix_operations(deps, info.sender, operations)
-        }
-
-        // Authorized addresses
-        ExecuteMsg::ModifyAuthorizedAddresses { operations } => {
-            execute::authorized_address_operations(deps, info.sender, operations)
-        }
-
-        ExecuteMsg::UnwrapCoin {
-            receiver,
-            into_chain,
-            with_memo,
-        } => {
-            let registries = Registry::new(deps.as_ref(), env.contract.address.to_string())?;
-            let coin = cw_utils::one_coin(&info)?;
-            let transfer_msg = registries.unwrap_coin_into(
-                coin,
-                receiver,
-                into_chain.as_deref(),
-                env.contract.address.to_string(),
-                env.block.time,
-                with_memo,
-                None,
-                false,
-            )?;
-            deps.api.debug(&format!("transfer_msg: {transfer_msg:?}"));
-            Ok(Response::new()
-                .add_message(transfer_msg)
-                .add_attribute("method", "unwrap_coin"))
-        }
-
-        ExecuteMsg::ProposePFM { chain } => execute::propose_pfm((deps, env, info), chain),
-        ExecuteMsg::ValidatePFM { chain } => execute::validate_pfm((deps, env, info), chain),
-        ExecuteMsg::TransferOwnership { new_owner } => {
-            execute::transfer_ownership(deps, info.sender, new_owner)
-        }
-    }
-}
-
-#[cfg_attr(not(feature = "imported"), entry_point)]
-pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
-    deps.api.debug(&format!("executing query: {msg:?}"));
-    match msg {
-        QueryMsg::GetAddressFromAlias { contract_alias } => {
-            let address = CONTRACT_ALIAS_MAP.load(deps.storage, &contract_alias)?;
-            let response = GetAddressFromAliasResponse { address };
-            to_binary(&response)
-        }
-
-        QueryMsg::GetDestinationChainFromSourceChainViaChannel {
-            on_chain,
-            via_channel,
-        } => to_binary(&query::query_chain_from_channel_chain_pair(
-            deps,
-            on_chain,
-            via_channel,
-        )?),
-
-        QueryMsg::GetChannelFromChainPair {
-            source_chain,
-            destination_chain,
-        } => to_binary(&query::query_channel_from_chain_pair(
-            deps,
-            source_chain,
-            destination_chain,
-        )?),
-
-        QueryMsg::GetBech32PrefixFromChainName { chain_name } => to_binary(
-            &query::query_bech32_prefix_from_chain_name(deps, chain_name)?,
-        ),
-
-        QueryMsg::GetDenomTrace { ibc_denom } => {
-            to_binary(&query::query_denom_trace_from_ibc_denom(deps, ibc_denom)?)
-        }
-        QueryMsg::GetChainNameFromBech32Prefix { prefix } => {
-            to_binary(&query::query_chain_name_from_bech32_prefix(deps, prefix)?)
-        }
-        QueryMsg::HasPacketForwarding { chain } => {
-            to_binary(&query::query_chain_has_pfm(deps, chain))
-        }
-        QueryMsg::GetAliasForDenomPath { denom_path } => {
-            to_binary(&query::query_alias_for_denom_path(deps, &denom_path)?)
-        }
-        QueryMsg::GetDenomPathForAlias { alias } => {
-            to_binary(&query::query_denom_path_for_alias(deps, &alias)?)
-        }
-    }
-}
-
-#[cfg_attr(not(feature = "imported"), entry_point)]
-pub fn sudo(deps: DepsMut, env: Env, msg: SudoMsg) -> Result<Response, ContractError> {
-    let own_addr = env.contract.address.to_string();
-    match msg {
-        SudoMsg::IBCLifecycleComplete(IBCLifecycleComplete::IBCAck {
-            channel,
-            sequence,
-            ack,
-            success,
-        }) => ibc_lifecycle::receive_ack(deps, own_addr, channel, sequence, ack, success),
-        SudoMsg::IBCLifecycleComplete(IBCLifecycleComplete::IBCTimeout { channel, sequence }) => {
-            ibc_lifecycle::receive_timeout(deps, own_addr, channel, sequence)
-        }
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::execute::ConnectionInput;
-    use crate::helpers::test::setup;
-
-    use cosmwasm_std::from_binary;
-    use cosmwasm_std::testing::{mock_env, mock_info};
-
-    static CREATOR_ADDRESS: &str = "creator";
-
-    #[test]
-    fn query_aliases() {
-        // Store three alias<>address mappings
-        let deps = setup().unwrap();
-
-        // Retrieve alias one and check the contract address is what we expect
-        let address_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetAddressFromAlias {
-                contract_alias: "contract_one".to_string(),
-            },
-        )
-        .unwrap();
-        let address: GetAddressFromAliasResponse = from_binary(&address_binary).unwrap();
-        assert_eq!(
-            GetAddressFromAliasResponse {
-                address: "osmo1dfaselkjh32hnkljw3nlklk2lknmes".to_string(),
-            },
-            address
-        );
-
-        // Retrieve alias two and check the contract address is what we expect
-        let address_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetAddressFromAlias {
-                contract_alias: "contract_two".to_string(),
-            },
-        )
-        .unwrap();
-        let address: GetAddressFromAliasResponse = from_binary(&address_binary).unwrap();
-        assert_eq!(
-            GetAddressFromAliasResponse {
-                address: "osmo1dfg4k3jhlknlfkjdslkjkl43klnfdl".to_string(),
-            },
-            address
-        );
-
-        // Retrieve alias three and check the contract address is what we expect
-        let address_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetAddressFromAlias {
-                contract_alias: "contract_three".to_string(),
-            },
-        )
-        .unwrap();
-        let address: GetAddressFromAliasResponse = from_binary(&address_binary).unwrap();
-        assert_eq!(
-            GetAddressFromAliasResponse {
-                address: "osmo1dfgjlk4lkfklkld32fsdajknjrrgfg".to_string(),
-            },
-            address
-        );
-
-        // Attempt to retrieve an alias that doesn't exist and check that we get an error
-        let address_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetAddressFromAlias {
-                contract_alias: "invalid_contract_alias".to_string(),
-            },
-        );
-        assert!(address_binary.is_err());
-    }
-
-    #[test]
-    fn query_chain_and_channel() {
-        // Store three chain<>channel mappings
-        let mut deps = setup().unwrap();
-
-        // Retrieve osmo<>juno link and check the channel is what we expect
-        let channel_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetChannelFromChainPair {
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "juno".to_string(),
-            },
-        )
-        .unwrap();
-        let channel: String = from_binary(&channel_binary).unwrap();
-        assert_eq!("channel-42", channel);
-
-        // Check that osmosis' channel-42 is connected to juno
-        let destination_chain = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetDestinationChainFromSourceChainViaChannel {
-                on_chain: CONTRACT_CHAIN.to_string(),
-                via_channel: "channel-42".to_string(),
-            },
-        )
-        .unwrap();
-        let destination_chain: String = from_binary(&destination_chain).unwrap();
-        assert_eq!("juno", destination_chain);
-
-        // Retrieve osmo<>stars link and check the channel is what we expect
-        let channel_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetChannelFromChainPair {
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "stargaze".to_string(),
-            },
-        )
-        .unwrap();
-        let channel: String = from_binary(&channel_binary).unwrap();
-        assert_eq!("channel-75", channel);
-
-        // Check that osmosis' channel-75 is connected to stars
-        let destination_chain = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetDestinationChainFromSourceChainViaChannel {
-                on_chain: CONTRACT_CHAIN.to_string(),
-                via_channel: "channel-75".to_string(),
-            },
-        )
-        .unwrap();
-        let destination_chain: String = from_binary(&destination_chain).unwrap();
-        assert_eq!("stargaze", destination_chain);
-
-        // Retrieve stargaze<>osmosis link and check the channel is what we expect
-        let channel_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetChannelFromChainPair {
-                source_chain: "stargaze".to_string(),
-                destination_chain: CONTRACT_CHAIN.to_string(),
-            },
-        )
-        .unwrap();
-        let channel: String = from_binary(&channel_binary).unwrap();
-        assert_eq!("channel-0", channel);
-
-        // Check that stars' channel-0 is connected to osmo
-        let destination_chain = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetDestinationChainFromSourceChainViaChannel {
-                on_chain: "stargaze".to_string(),
-                via_channel: "channel-0".to_string(),
-            },
-        )
-        .unwrap();
-        let destination_chain: String = from_binary(&destination_chain).unwrap();
-        assert_eq!(CONTRACT_CHAIN, destination_chain);
-
-        // Attempt to retrieve a link that doesn't exist and check that we get an error
-        let channel_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetChannelFromChainPair {
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "cerberus".to_string(),
-            },
-        );
-        assert!(channel_binary.is_err());
-
-        // Disable the osmo<>juno link with the global admin
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: execute::FullOperation::Disable,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "JUNO".to_string(),
-                channel_id: Some("CHANNEL-42".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let info_creator = mock_info(CREATOR_ADDRESS, &[]);
-        let result = execute(deps.as_mut(), mock_env(), info_creator.clone(), msg);
-        assert!(result.is_ok());
-
-        // Retrieve osmo<>juno link again, but this time it should be disabled
-        let res = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetChannelFromChainPair {
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "juno".to_string(),
-            },
-        );
-        assert!(res.is_err());
-
-        // Enable the osmo<>juno link with the global admin
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: execute::FullOperation::Enable,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "JUNO".to_string(),
-                channel_id: Some("CHANNEL-42".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let result = execute(deps.as_mut(), mock_env(), info_creator, msg);
-        assert!(result.is_ok());
-
-        // Retrieve osmo<>juno link again, but this time it should be enabled
-        let channel_binary = query(
-            deps.as_ref(),
-            mock_env(),
-            QueryMsg::GetChannelFromChainPair {
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "juno".to_string(),
-            },
-        )
-        .unwrap();
-        let channel: String = from_binary(&channel_binary).unwrap();
-        assert_eq!("channel-42", channel);
-    }
-}
diff --git a/cosmwasm/contracts/crosschain-registry/src/error.rs b/cosmwasm/contracts/crosschain-registry/src/error.rs
deleted file mode 100644
index 8cdfc261a..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/error.rs
+++ /dev/null
@@ -1,90 +0,0 @@
-use cosmwasm_std::StdError;
-use registry::RegistryError;
-use thiserror::Error;
-
-#[derive(Error, Debug, PartialEq)]
-pub enum ContractError {
-    #[error("{0}")]
-    Std(#[from] StdError),
-
-    #[error("{0}")]
-    RegistryError(#[from] RegistryError),
-
-    #[error("{0}")]
-    Payment(#[from] cw_utils::PaymentError),
-
-    #[error("unauthorized")]
-    Unauthorized {},
-
-    #[error("chain validation not started for {chain}")]
-    ValidationNotFound { chain: String },
-
-    #[error("coin from invalid chain. It belongs to {supplied_chain} and should be from {expected_chain}")]
-    CoinFromInvalidChain {
-        supplied_chain: String,
-        expected_chain: String,
-    },
-
-    // This is only used for pfm validation. Uncomment when re-activating pfm validation
-    //
-    // #[error(
-    //     "only messages initialized by the address of this contract in another chain are allowed. Expected {expected_sender} but got {actual_sender}"
-    // )]
-    // InvalidSender {
-    //     expected_sender: String,
-    //     actual_sender: String,
-    // },
-    //
-    #[error("alias already exists: {alias:?}")]
-    AliasAlreadyExists { alias: String },
-
-    #[error("alias already exists for: {base:?}")]
-    AliasAlreadyExistsFor { base: String },
-
-    #[error("alias does not exist: {alias:?}")]
-    AliasDoesNotExist { alias: String },
-
-    #[error("alias does not exist for: {base:?}")]
-    AliasDoesNotExistFor { base: String },
-
-    #[error("existing alias {existing} does not match supplied alias: {expected}")]
-    AliasDoesNotMatch { existing: String, expected: String },
-
-    #[error("invalid alias {alias}. Must be alphanumeric")]
-    InvalidAlias { alias: String },
-
-    #[error(
-        "PFM validation already in progress for {chain:?}. Wait for the ibc lifecycle to complete"
-    )]
-    PFMValidationAlreadyInProgress { chain: String },
-
-    #[error("No initiator found this validation. The validation has already completed.")]
-    PFMNoInitiator {},
-
-    #[error("authorized address already exists for source chain: {source_chain:?}")]
-    ChainAuthorizedAddressAlreadyExists { source_chain: String },
-
-    #[error("chain channel link already exists: {source_chain:?} -> {destination_chain:?}")]
-    ChainToChainChannelLinkAlreadyExists {
-        source_chain: String,
-        destination_chain: String,
-    },
-
-    #[error("channel chain link already exists: {channel_id:?} -> {source_chain:?}")]
-    ChannelToChainChainLinkAlreadyExists {
-        channel_id: String,
-        source_chain: String,
-    },
-
-    #[error("native denom link already exists: {native_denom:?}")]
-    NativeDenomLinkAlreadyExists { native_denom: String },
-
-    #[error("input not valid: {message:?}")]
-    InvalidInput { message: String },
-
-    #[error("missing field: {field:?}")]
-    MissingField { field: String },
-
-    #[error("custom error: {msg:?}")]
-    CustomError { msg: String },
-}
diff --git a/cosmwasm/contracts/crosschain-registry/src/execute.rs b/cosmwasm/contracts/crosschain-registry/src/execute.rs
deleted file mode 100644
index 25da7b38d..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/execute.rs
+++ /dev/null
@@ -1,1922 +0,0 @@
-use crate::helpers::*;
-use crate::state::{
-    ChainPFM, Config, CHAIN_ADMIN_MAP, CHAIN_MAINTAINER_MAP, CHAIN_PFM_MAP,
-    CHAIN_TO_BECH32_PREFIX_MAP, CHAIN_TO_BECH32_PREFIX_REVERSE_MAP, CHAIN_TO_CHAIN_CHANNEL_MAP,
-    CHANNEL_ON_CHAIN_CHAIN_MAP, CONFIG, CONTRACT_ALIAS_MAP, DENOM_ALIAS_MAP,
-    DENOM_ALIAS_REVERSE_MAP, GLOBAL_ADMIN_MAP,
-};
-use cosmwasm_schema::cw_serde;
-use cosmwasm_std::{Addr, BankMsg, DepsMut, Env, MessageInfo, Response};
-use cw_storage_plus::Map;
-use registry::msg::Callback;
-use registry::{Registry, RegistryError};
-
-use crate::ContractError;
-
-// Enum to represent the operation to be performed
-#[cw_serde]
-pub enum Operation {
-    Set,
-    Change,
-    Remove,
-}
-
-// Enum to represent the operation to be performed (including enable/disable)
-#[cw_serde]
-pub enum FullOperation {
-    Set,
-    Change,
-    Remove,
-    Enable,
-    Disable,
-}
-
-// Contract Registry
-
-// Struct for input data for a single contract alias
-#[cw_serde]
-pub struct ContractAliasInput {
-    pub operation: Operation,
-    pub alias: String,
-    pub address: Option<String>,
-    pub new_alias: Option<String>,
-}
-
-// Struct for input data for a denom alias
-#[cw_serde]
-pub struct DenomAliasInput {
-    pub operation: FullOperation,
-    pub alias: String,
-    pub full_denom_path: String,
-}
-
-// Transfer ownership of this contract
-pub fn transfer_ownership(
-    deps: DepsMut,
-    sender: Addr,
-    new_owner: String,
-) -> Result<Response, ContractError> {
-    // only owner can transfer
-    if !is_owner(deps.as_ref(), &sender) {
-        return Err(ContractError::Unauthorized {});
-    }
-
-    let new_owner = deps.api.addr_validate(&new_owner)?;
-
-    CONFIG.update(
-        deps.storage,
-        |mut config| -> Result<Config, ContractError> {
-            config.owner = new_owner;
-            Ok(config)
-        },
-    )?;
-
-    Ok(Response::new().add_attribute("action", "transfer_ownership"))
-}
-
-pub fn propose_pfm(
-    ctx: (DepsMut, Env, MessageInfo),
-    chain: String,
-) -> Result<Response, ContractError> {
-    let (deps, env, info) = ctx;
-
-    // enforce lowercase
-    let chain = chain.to_lowercase();
-
-    let own_addr = env.contract.address;
-
-    // validation
-    let registry = Registry::new(deps.as_ref(), own_addr.to_string())?;
-    let coin = cw_utils::one_coin(&info)?;
-    let native_chain = registry.get_native_chain(&coin.denom)?;
-
-    if native_chain.as_ref() != chain {
-        return Err(ContractError::CoinFromInvalidChain {
-            supplied_chain: native_chain.as_ref().to_string(),
-            expected_chain: chain,
-        });
-    }
-
-    // Temporarily check that only the global admin can propose a PFM. This is
-    // due to different versions of PFM having different senders. Once all
-    // chains are on the latest PFM, we can remove this check and uncomment the
-    // code in validate_pfm
-    check_action_permission(FullOperation::Set, Permission::GlobalAdmin)?;
-
-    // check if the chain is already registered or is in progress
-    if let Some(chain_pfm) = CHAIN_PFM_MAP.may_load(deps.storage, &chain)? {
-        if chain_pfm.is_validated() {
-            // Only authorized addresses can ask for a validated PFM to be re-checked
-            // If sender is the contract governor, then they are authorized to do do this to any chain
-            // Otherwise, they must be authorized to do manage the chain they are attempting to modify
-            let user_permission =
-                check_is_authorized(deps.as_ref(), info.sender.clone(), Some(chain.clone()))?;
-            check_action_permission(FullOperation::Change, user_permission)?;
-        } else {
-            return Err(ContractError::PFMValidationAlreadyInProgress {
-                chain: chain.clone(),
-            });
-        }
-    };
-
-    // Store the chain to validate
-    CHAIN_PFM_MAP.save(deps.storage, &chain, &ChainPFM::new(info.sender))?;
-
-    // redeclaring (shadowing) registry to avoid issues with the borrow checker
-    let registry = Registry::new(deps.as_ref(), own_addr.to_string())?;
-    let ibc_transfer = registry.unwrap_coin_into(
-        coin,
-        own_addr.to_string(),
-        None,
-        own_addr.to_string(),
-        env.block.time,
-        format!(r#"{{"ibc_callback":"{own_addr}"}}"#),
-        Some(Callback {
-            contract: own_addr,
-            msg: format!(r#"{{"validate_pfm": {{"chain": "{chain}"}} }}"#).try_into()?,
-        }),
-        true,
-    )?;
-
-    Ok(Response::default().add_message(ibc_transfer))
-}
-
-pub fn validate_pfm(
-    ctx: (DepsMut, Env, MessageInfo),
-    chain: String,
-) -> Result<Response, ContractError> {
-    let (deps, _env, info) = ctx;
-
-    let chain = chain.to_lowercase();
-
-    // TODO: Uncomment this once all chains are on the latest PFM and we can
-    // properly verify the sender. We will also need to modify how
-    // derive_wasmhooks_sender works at that point
-    //
-    // let registry = Registry::default(deps.as_ref());
-    // let channel = registry.get_channel(&chain, CONTRACT_CHAIN)?;
-    // let own_addr = env.contract.address.as_str();
-    // let original_sender = registry.encode_addr_for_chain(own_addr, &chain)?;
-    // let expected_sender = registry::derive_wasmhooks_sender(&channel, &original_sender, "osmo")?;
-    // if expected_sender != info.sender {
-    //     return Err(ContractError::InvalidSender {
-    //         expected_sender,
-    //         actual_sender: info.sender.into_string(),
-    //     });
-    // }
-
-    let mut chain_pfm = CHAIN_PFM_MAP.load(deps.storage, &chain).map_err(|_| {
-        ContractError::ValidationNotFound {
-            chain: chain.clone(),
-        }
-    })?;
-
-    let initiator = match chain_pfm.initiator {
-        Some(initiator) => initiator,
-        None => return Err(ContractError::PFMNoInitiator {}),
-    };
-
-    let coin = cw_utils::one_coin(&info)?;
-    let bank_msg = BankMsg::Send {
-        to_address: initiator.to_string(),
-        amount: vec![coin],
-    };
-
-    chain_pfm.validated = true;
-    chain_pfm.initiator = None;
-
-    CHAIN_PFM_MAP.save(deps.storage, &chain, &chain_pfm)?;
-
-    Ok(Response::default().add_message(bank_msg))
-}
-
-// Set, change, or remove a contract alias to an address
-pub fn contract_alias_operations(
-    deps: DepsMut,
-    sender: Addr,
-    operations: Vec<ContractAliasInput>,
-) -> Result<Response, ContractError> {
-    // Only contract governor can call contract alias CRUD operations
-    check_is_contract_governor(deps.as_ref(), sender)?;
-
-    let response = Response::new();
-    for operation in operations {
-        match operation.operation {
-            Operation::Set => {
-                if CONTRACT_ALIAS_MAP.has(deps.storage, &operation.alias) {
-                    return Err(ContractError::AliasAlreadyExists {
-                        alias: operation.alias,
-                    });
-                }
-                CONTRACT_ALIAS_MAP.save(
-                    deps.storage,
-                    &operation.alias,
-                    &operation.address.ok_or(ContractError::MissingField {
-                        field: "address".to_string(),
-                    })?,
-                )?;
-                response
-                    .clone()
-                    .add_attribute("set_contract_alias", operation.alias.to_string());
-            }
-            Operation::Change => {
-                let address = CONTRACT_ALIAS_MAP
-                    .load(deps.storage, &operation.alias)
-                    .map_err(|_| RegistryError::AliasDoesNotExist {
-                        alias: operation.alias.clone(),
-                    })?;
-                let new_alias = operation.new_alias.clone().unwrap_or_default().to_string();
-                CONTRACT_ALIAS_MAP.save(deps.storage, &new_alias, &address)?;
-                CONTRACT_ALIAS_MAP.remove(deps.storage, &operation.alias);
-                response
-                    .clone()
-                    .add_attribute("change_contract_alias", operation.alias.to_string());
-            }
-            Operation::Remove => {
-                CONTRACT_ALIAS_MAP
-                    .load(deps.storage, &operation.alias)
-                    .map_err(|_| RegistryError::AliasDoesNotExist {
-                        alias: operation.alias.clone(),
-                    })?;
-                CONTRACT_ALIAS_MAP.remove(deps.storage, &operation.alias);
-                response
-                    .clone()
-                    .add_attribute("remove_contract_alias", operation.alias.to_string());
-            }
-        }
-    }
-    Ok(response)
-}
-
-// Set, Change, Enable, or Disable a denom alias
-pub fn denom_alias_operations(
-    deps: DepsMut,
-    sender: Addr,
-    operations: Vec<DenomAliasInput>,
-) -> Result<Response, ContractError> {
-    // Only contract governor can call denom alias CRUD operations
-    let is_owner = is_owner(deps.as_ref(), &sender);
-    let is_global_admin = is_global_admin(deps.as_ref(), &sender);
-
-    if !is_owner && !is_global_admin {
-        return Err(ContractError::Unauthorized {});
-    }
-
-    let mut response = Response::new();
-    for operation in operations {
-        let denom_alias = normalize_alias(&operation.alias)?;
-        let path = operation.full_denom_path;
-
-        match operation.operation {
-            FullOperation::Set => {
-                if DENOM_ALIAS_MAP.has(deps.storage, &path) {
-                    return Err(ContractError::AliasAlreadyExistsFor { base: path });
-                }
-                // TODO: This check is not enough, as disabled aliases could be
-                // re-set. We need to keep track of enabled/disabled in the
-                // reverse map as well
-                if DENOM_ALIAS_REVERSE_MAP.has(deps.storage, &operation.alias) {
-                    return Err(ContractError::AliasAlreadyExists { alias: denom_alias });
-                }
-
-                DENOM_ALIAS_MAP.save(deps.storage, &path, &(denom_alias.clone(), true).into())?;
-                DENOM_ALIAS_REVERSE_MAP.save(deps.storage, &denom_alias, &(&path, true).into())?;
-
-                response =
-                    response.add_attribute("set_denom_alias", format!("{denom_alias} <=> {path}"));
-            }
-            FullOperation::Change => {
-                if !is_owner {
-                    // Only the owner can change for security reasons
-                    return Err(ContractError::Unauthorized {});
-                }
-
-                // Ensure the alias exists
-                let map_entry = DENOM_ALIAS_MAP
-                    .load(deps.storage, &path)
-                    .map_err(|_| ContractError::AliasDoesNotExistFor { base: path.clone() })?;
-
-                let is_enabled = map_entry.enabled;
-                let new_alias = normalize_alias(&operation.alias)?;
-
-                if DENOM_ALIAS_REVERSE_MAP.has(deps.storage, &new_alias) {
-                    return Err(ContractError::AliasAlreadyExists { alias: new_alias });
-                }
-
-                DENOM_ALIAS_MAP.save(deps.storage, &path, &(&new_alias, is_enabled).into())?;
-                DENOM_ALIAS_REVERSE_MAP.remove(deps.storage, &map_entry.value);
-                DENOM_ALIAS_REVERSE_MAP.save(deps.storage, &new_alias, &(&path, true).into())?;
-
-                response =
-                    response.add_attribute("change_denom_alias", format!("{new_alias} <=> {path}"));
-            }
-            FullOperation::Remove => {
-                if !is_owner {
-                    // Only the owner can remove for security reasons
-                    return Err(ContractError::Unauthorized {});
-                }
-                let map_entry = DENOM_ALIAS_MAP
-                    .load(deps.storage, &path)
-                    .map_err(|_| ContractError::AliasDoesNotExistFor { base: path.clone() })?;
-                DENOM_ALIAS_MAP.remove(deps.storage, &path);
-                DENOM_ALIAS_REVERSE_MAP.remove(deps.storage, &map_entry.value);
-
-                response = response.add_attribute("remove_denom_alias", map_entry.value);
-            }
-            FullOperation::Enable => {
-                let map_entry = DENOM_ALIAS_MAP
-                    .load(deps.storage, &path)
-                    .map_err(|_| ContractError::AliasDoesNotExistFor { base: path.clone() })?;
-                DENOM_ALIAS_MAP.save(
-                    deps.storage,
-                    &path,
-                    &(map_entry.value.clone(), true).into(),
-                )?;
-                // Add to the enabled alias to the reverse map
-                DENOM_ALIAS_REVERSE_MAP.save(
-                    deps.storage,
-                    &map_entry.value,
-                    &(&path, true).into(),
-                )?;
-
-                response = response.add_attribute(
-                    "enable_denom_alias",
-                    format!("{} <=> {path}", map_entry.value),
-                );
-            }
-            FullOperation::Disable => {
-                let map_entry = DENOM_ALIAS_MAP
-                    .load(deps.storage, &path)
-                    .map_err(|_| ContractError::AliasDoesNotExistFor { base: path.clone() })?;
-                DENOM_ALIAS_MAP.save(
-                    deps.storage,
-                    &path,
-                    &(map_entry.value.clone(), false).into(),
-                )?;
-                // Disable the  alias on the reverse map
-                DENOM_ALIAS_REVERSE_MAP.save(
-                    deps.storage,
-                    &map_entry.value,
-                    &(&path, false).into(),
-                )?;
-
-                response = response
-                    .add_attribute("disable_denom_alias", format!("{denom_alias} <=> {path}"));
-            }
-        }
-    }
-    Ok(response)
-}
-
-// Chain Channel Registry
-
-// Struct for input data for a single connection
-#[cw_serde]
-pub struct ConnectionInput {
-    pub operation: FullOperation,
-    pub source_chain: String,
-    pub destination_chain: String,
-    pub channel_id: Option<String>,
-    pub new_source_chain: Option<String>,
-    pub new_destination_chain: Option<String>,
-    pub new_channel_id: Option<String>,
-}
-
-// Set, change, or remove a source chain, destination chain, and channel connection
-pub fn connection_operations(
-    deps: DepsMut,
-    sender: Addr,
-    operations: Vec<ConnectionInput>,
-) -> Result<Response, ContractError> {
-    let response = Response::new();
-    for operation in operations {
-        let source_chain = operation.source_chain.to_lowercase();
-        let destination_chain = operation.destination_chain.to_lowercase();
-        let provided_action = operation.operation.clone();
-
-        // Only authorized addresses can call connection CRUD operations
-        // If sender is the contract governor, then they are authorized to do CRUD operations on any chain
-        // Otherwise, they must be authorized to do CRUD operations on the source_chain they are attempting to modify
-        let user_permission =
-            check_is_authorized(deps.as_ref(), sender.clone(), Some(source_chain.clone()))?;
-        check_action_permission(provided_action, user_permission)?;
-
-        match operation.operation {
-            FullOperation::Set => {
-                let channel_id = operation
-                    .channel_id
-                    .ok_or_else(|| ContractError::InvalidInput {
-                        message: "channel_id is required for set operation".to_string(),
-                    })?
-                    .to_lowercase();
-                if CHAIN_TO_CHAIN_CHANNEL_MAP.has(deps.storage, (&source_chain, &destination_chain))
-                {
-                    return Err(ContractError::ChainToChainChannelLinkAlreadyExists {
-                        source_chain,
-                        destination_chain,
-                    });
-                }
-                CHAIN_TO_CHAIN_CHANNEL_MAP.save(
-                    deps.storage,
-                    (&source_chain, &destination_chain),
-                    &(channel_id.clone(), true).into(),
-                )?;
-                if CHANNEL_ON_CHAIN_CHAIN_MAP.has(deps.storage, (&channel_id, &source_chain)) {
-                    return Err(ContractError::ChannelToChainChainLinkAlreadyExists {
-                        channel_id,
-                        source_chain,
-                    });
-                }
-                CHANNEL_ON_CHAIN_CHAIN_MAP.save(
-                    deps.storage,
-                    (&channel_id, &source_chain),
-                    &(destination_chain.clone(), true).into(),
-                )?;
-                response.clone().add_attribute(
-                    "set_connection",
-                    format!("{source_chain}-{destination_chain}"),
-                );
-            }
-            FullOperation::Change => {
-                let chain_to_chain_map = CHAIN_TO_CHAIN_CHANNEL_MAP
-                    .load(deps.storage, (&source_chain, &destination_chain))
-                    .map_err(|_| RegistryError::ChainChannelLinkDoesNotExist {
-                        source_chain: source_chain.clone(),
-                        destination_chain: destination_chain.clone(),
-                    })?;
-                let channel_on_chain_map = CHANNEL_ON_CHAIN_CHAIN_MAP
-                    .load(deps.storage, (&chain_to_chain_map.value, &source_chain))
-                    .map_err(|_| RegistryError::ChannelDoesNotExistOnChain {
-                        channel_id: chain_to_chain_map.value.clone(),
-                        source_chain: source_chain.clone(),
-                    })?;
-                if let Some(new_channel_id) = operation.new_channel_id {
-                    let new_channel_id = new_channel_id.to_lowercase();
-                    CHAIN_TO_CHAIN_CHANNEL_MAP.save(
-                        deps.storage,
-                        (&source_chain, &destination_chain),
-                        &(new_channel_id.clone(), chain_to_chain_map.enabled).into(),
-                    )?;
-                    CHANNEL_ON_CHAIN_CHAIN_MAP
-                        .remove(deps.storage, (&chain_to_chain_map.value, &source_chain));
-                    CHANNEL_ON_CHAIN_CHAIN_MAP.save(
-                        deps.storage,
-                        (&new_channel_id, &source_chain),
-                        &channel_on_chain_map,
-                    )?;
-                    response.clone().add_attribute(
-                        "change_connection",
-                        format!("{source_chain}-{destination_chain}"),
-                    );
-                } else if let Some(new_destination_chain) = operation.new_destination_chain {
-                    let new_destination_chain = new_destination_chain.to_lowercase();
-                    CHAIN_TO_CHAIN_CHANNEL_MAP
-                        .remove(deps.storage, (&source_chain, &destination_chain));
-                    CHAIN_TO_CHAIN_CHANNEL_MAP.save(
-                        deps.storage,
-                        (&source_chain, &new_destination_chain),
-                        &chain_to_chain_map,
-                    )?;
-                    CHANNEL_ON_CHAIN_CHAIN_MAP
-                        .remove(deps.storage, (&chain_to_chain_map.value, &source_chain));
-                    CHANNEL_ON_CHAIN_CHAIN_MAP.save(
-                        deps.storage,
-                        (&chain_to_chain_map.value, &source_chain),
-                        &(new_destination_chain, channel_on_chain_map.enabled).into(),
-                    )?;
-                    response.clone().add_attribute(
-                        "change_connection",
-                        format!("{source_chain}-{destination_chain}"),
-                    );
-                } else if let Some(new_source_chain) = operation.new_source_chain {
-                    let new_source_chain = new_source_chain.to_lowercase();
-                    CHAIN_TO_CHAIN_CHANNEL_MAP
-                        .remove(deps.storage, (&source_chain, &destination_chain));
-                    CHAIN_TO_CHAIN_CHANNEL_MAP.save(
-                        deps.storage,
-                        (&new_source_chain, &destination_chain),
-                        &chain_to_chain_map,
-                    )?;
-                    CHANNEL_ON_CHAIN_CHAIN_MAP
-                        .remove(deps.storage, (&chain_to_chain_map.value, &source_chain));
-                    CHANNEL_ON_CHAIN_CHAIN_MAP.save(
-                        deps.storage,
-                        (&chain_to_chain_map.value, &new_source_chain),
-                        &channel_on_chain_map,
-                    )?;
-                    response.clone().add_attribute(
-                        "change_connection",
-                        format!("{source_chain}-{destination_chain}"),
-                    );
-                } else {
-                    return Err(ContractError::InvalidInput {
-                        message: "Either new_channel_id, new_destination_chain or new_source_chain must be provided for change operation".to_string(),
-                    });
-                }
-                response.clone().add_attribute(
-                    "change_connection",
-                    format!("{source_chain}-{destination_chain}"),
-                );
-            }
-            FullOperation::Remove => {
-                let chain_to_chain_map = CHAIN_TO_CHAIN_CHANNEL_MAP
-                    .load(deps.storage, (&source_chain, &destination_chain))
-                    .map_err(|_| RegistryError::ChainChannelLinkDoesNotExist {
-                        source_chain: source_chain.clone(),
-                        destination_chain: destination_chain.clone(),
-                    })?;
-                CHAIN_TO_CHAIN_CHANNEL_MAP
-                    .remove(deps.storage, (&source_chain, &destination_chain));
-                CHANNEL_ON_CHAIN_CHAIN_MAP
-                    .remove(deps.storage, (&chain_to_chain_map.value, &source_chain));
-                response.clone().add_attribute(
-                    "remove_connection",
-                    format!("{source_chain}-{destination_chain}"),
-                );
-            }
-            FullOperation::Enable => {
-                let chain_to_chain_map = CHAIN_TO_CHAIN_CHANNEL_MAP
-                    .load(deps.storage, (&source_chain, &destination_chain))
-                    .map_err(|_| RegistryError::ChainChannelLinkDoesNotExist {
-                        source_chain: source_chain.clone(),
-                        destination_chain: destination_chain.clone(),
-                    })?;
-                let channel_on_chain_map = CHANNEL_ON_CHAIN_CHAIN_MAP
-                    .load(deps.storage, (&chain_to_chain_map.value, &source_chain))
-                    .map_err(|_| RegistryError::ChannelDoesNotExistOnChain {
-                        channel_id: chain_to_chain_map.value.clone(),
-                        source_chain: source_chain.clone(),
-                    })?;
-                CHAIN_TO_CHAIN_CHANNEL_MAP.save(
-                    deps.storage,
-                    (&source_chain, &destination_chain),
-                    &(&chain_to_chain_map.value, true).into(),
-                )?;
-                CHANNEL_ON_CHAIN_CHAIN_MAP.save(
-                    deps.storage,
-                    (&chain_to_chain_map.value, &source_chain),
-                    &(channel_on_chain_map.value, true).into(),
-                )?;
-                response.clone().add_attribute(
-                    "enable_connection",
-                    format!("{source_chain}-{destination_chain}"),
-                );
-            }
-            FullOperation::Disable => {
-                let chain_to_chain_map = CHAIN_TO_CHAIN_CHANNEL_MAP
-                    .load(deps.storage, (&source_chain, &destination_chain))
-                    .map_err(|_| RegistryError::ChainChannelLinkDoesNotExist {
-                        source_chain: source_chain.clone(),
-                        destination_chain: destination_chain.clone(),
-                    })?;
-                let channel_on_chain_map = CHANNEL_ON_CHAIN_CHAIN_MAP
-                    .load(deps.storage, (&chain_to_chain_map.value, &source_chain))
-                    .map_err(|_| RegistryError::ChannelDoesNotExistOnChain {
-                        channel_id: chain_to_chain_map.value.clone(),
-                        source_chain: source_chain.clone(),
-                    })?;
-                CHAIN_TO_CHAIN_CHANNEL_MAP.save(
-                    deps.storage,
-                    (&source_chain, &destination_chain),
-                    &(&chain_to_chain_map.value, false).into(),
-                )?;
-                CHANNEL_ON_CHAIN_CHAIN_MAP.save(
-                    deps.storage,
-                    (&chain_to_chain_map.value, &source_chain),
-                    &(channel_on_chain_map.value, false).into(),
-                )?;
-                response.clone().add_attribute(
-                    "disable_connection",
-                    format!("{source_chain}-{destination_chain}"),
-                );
-            }
-        }
-    }
-    Ok(response)
-}
-
-// Struct for input data for a single chain to bech32 prefix operation
-#[cw_serde]
-pub struct ChainToBech32PrefixInput {
-    pub operation: FullOperation,
-    pub chain_name: String,
-    pub prefix: String,
-    pub new_prefix: Option<String>,
-}
-
-pub fn chain_to_prefix_operations(
-    deps: DepsMut,
-    sender: Addr,
-    operations: Vec<ChainToBech32PrefixInput>,
-) -> Result<Response, ContractError> {
-    let response = Response::new();
-    for operation in operations {
-        let chain_name = operation.chain_name.to_lowercase();
-        let provided_action = operation.operation.clone();
-
-        // Only authorized addresses can call connection CRUD operations
-        // If sender is the contract governor, then they are authorized to do CRUD operations on any chain
-        // Otherwise, they must be authorized to do CRUD operations on the source_chain they are attempting to modify
-        let user_permission =
-            check_is_authorized(deps.as_ref(), sender.clone(), Some(chain_name.clone()))?;
-        check_action_permission(provided_action, user_permission)?;
-
-        match operation.operation {
-            FullOperation::Set => {
-                if CHAIN_TO_BECH32_PREFIX_MAP.has(deps.storage, &chain_name) {
-                    return Err(ContractError::AliasAlreadyExists { alias: chain_name });
-                }
-                let prefix = operation.prefix.to_lowercase();
-                CHAIN_TO_BECH32_PREFIX_MAP.save(
-                    deps.storage,
-                    &chain_name,
-                    &(prefix.clone(), true).into(),
-                )?;
-
-                push_to_map_value(
-                    deps.storage,
-                    &CHAIN_TO_BECH32_PREFIX_REVERSE_MAP,
-                    &prefix,
-                    chain_name.clone(),
-                )?;
-
-                response
-                    .clone()
-                    .add_attribute("set_chain_to_prefix", chain_name);
-            }
-            FullOperation::Change => {
-                let map_entry = CHAIN_TO_BECH32_PREFIX_MAP
-                    .load(deps.storage, &chain_name)
-                    .map_err(|_| RegistryError::AliasDoesNotExist {
-                        alias: chain_name.clone(),
-                    })?;
-
-                let is_enabled = map_entry.enabled;
-
-                let old_prefix = operation.prefix.to_lowercase();
-                let new_prefix = operation
-                    .new_prefix
-                    .unwrap_or_default()
-                    .to_string()
-                    .to_lowercase();
-                CHAIN_TO_BECH32_PREFIX_MAP.save(
-                    deps.storage,
-                    &chain_name,
-                    &(new_prefix.clone(), is_enabled).into(),
-                )?;
-
-                // Remove from the reverse map of the old prefix
-                remove_from_map_value(
-                    deps.storage,
-                    &CHAIN_TO_BECH32_PREFIX_REVERSE_MAP,
-                    &old_prefix,
-                    chain_name.clone(),
-                )?;
-
-                // Add to the reverse map of the new prefix
-                push_to_map_value(
-                    deps.storage,
-                    &CHAIN_TO_BECH32_PREFIX_REVERSE_MAP,
-                    &new_prefix,
-                    chain_name.clone(),
-                )?;
-
-                response
-                    .clone()
-                    .add_attribute("change_chain_to_prefix", chain_name);
-            }
-            FullOperation::Remove => {
-                CONTRACT_ALIAS_MAP
-                    .load(deps.storage, &chain_name)
-                    .map_err(|_| RegistryError::AliasDoesNotExist {
-                        alias: chain_name.clone(),
-                    })?;
-                CHAIN_TO_BECH32_PREFIX_MAP.remove(deps.storage, &chain_name);
-
-                let old_prefix = operation.prefix.to_lowercase();
-                // Remove from the reverse map of the old prefix
-                remove_from_map_value(
-                    deps.storage,
-                    &CHAIN_TO_BECH32_PREFIX_REVERSE_MAP,
-                    &old_prefix,
-                    chain_name.clone(),
-                )?;
-
-                response
-                    .clone()
-                    .add_attribute("remove_chain_to_prefix", chain_name);
-            }
-            FullOperation::Enable => {
-                let map_entry = CHAIN_TO_BECH32_PREFIX_MAP
-                    .load(deps.storage, &chain_name)
-                    .map_err(|_| RegistryError::AliasDoesNotExist {
-                        alias: chain_name.clone(),
-                    })?;
-                CHAIN_TO_BECH32_PREFIX_MAP.save(
-                    deps.storage,
-                    &chain_name,
-                    &(map_entry.value.clone(), true).into(),
-                )?;
-                // Add to the reverse map of the enabled prefix
-                push_to_map_value(
-                    deps.storage,
-                    &CHAIN_TO_BECH32_PREFIX_REVERSE_MAP,
-                    &map_entry.value,
-                    chain_name.clone(),
-                )?;
-                response
-                    .clone()
-                    .add_attribute("enable_chain_to_prefix", chain_name);
-            }
-            FullOperation::Disable => {
-                let map_entry = CHAIN_TO_BECH32_PREFIX_MAP
-                    .load(deps.storage, &chain_name)
-                    .map_err(|_| RegistryError::AliasDoesNotExist {
-                        alias: chain_name.clone(),
-                    })?;
-                CHAIN_TO_BECH32_PREFIX_MAP.save(
-                    deps.storage,
-                    &chain_name,
-                    &(map_entry.value.clone(), false).into(),
-                )?;
-                // Remove from the reverse map of the disabled prefix
-                remove_from_map_value(
-                    deps.storage,
-                    &CHAIN_TO_BECH32_PREFIX_REVERSE_MAP,
-                    &map_entry.value,
-                    chain_name.clone(),
-                )?;
-
-                response
-                    .clone()
-                    .add_attribute("disable_chain_to_prefix", chain_name);
-            }
-        }
-    }
-    Ok(response)
-}
-
-// Struct for input data for a single chain to authorized address operation
-#[cw_serde]
-pub struct AuthorizedAddressInput {
-    pub operation: Operation,
-    pub source_chain: String,
-    pub addr: Addr,
-    pub permission: Option<Permission>,
-    pub new_addr: Option<Addr>,
-}
-
-#[cw_serde]
-pub enum Permission {
-    GlobalAdmin,
-    ChainAdmin,
-    ChainMaintainer,
-}
-
-fn permission_to_map(permission: &Permission) -> &Map<&str, Addr> {
-    match permission {
-        Permission::GlobalAdmin => &GLOBAL_ADMIN_MAP,
-        Permission::ChainAdmin => &CHAIN_ADMIN_MAP,
-        Permission::ChainMaintainer => &CHAIN_MAINTAINER_MAP,
-    }
-}
-
-pub fn authorized_address_operations(
-    deps: DepsMut,
-    sender: Addr,
-    operation: Vec<AuthorizedAddressInput>,
-) -> Result<Response, ContractError> {
-    let response = Response::new();
-    for operation in operation {
-        let addr = operation.addr;
-        let source_chain = operation.source_chain.to_lowercase();
-        let requested_permission = operation.permission.unwrap();
-
-        // Check if the sender is authorized to make changes to the map of addresses authorized for the given permission
-        // GlobalAdmins can add addresses to any map
-        // ChainAdmins can modify the ChainAdmin and ChainMaintainer for their own chain
-        // ChainMaintainers can only modify the ChainMaintainer for their own chain
-        let max_permission =
-            check_is_authorized(deps.as_ref(), sender.clone(), Some(source_chain.clone()))?;
-        check_permission(requested_permission.clone(), max_permission)?;
-
-        // Pull the correct map from the permission
-        let address_map = permission_to_map(&requested_permission);
-
-        match operation.operation {
-            Operation::Set => {
-                if address_map.has(deps.storage, &source_chain) {
-                    return Err(ContractError::ChainAuthorizedAddressAlreadyExists {
-                        source_chain,
-                    });
-                }
-
-                address_map.save(deps.storage, &source_chain, &addr)?;
-                response
-                    .clone()
-                    .add_attribute("set_authorized_address", format!("{source_chain}-{addr}"));
-            }
-            Operation::Change => {
-                address_map.load(deps.storage, &source_chain).map_err(|_| {
-                    RegistryError::ChainAuthorizedAddressDoesNotExist {
-                        source_chain: source_chain.clone(),
-                    }
-                })?;
-
-                let new_addr = operation.new_addr.unwrap();
-
-                address_map.remove(deps.storage, &source_chain);
-                address_map.save(deps.storage, &source_chain, &new_addr)?;
-                response.clone().add_attribute(
-                    "change_authorized_address",
-                    format!("{source_chain}-{addr}"),
-                );
-            }
-            Operation::Remove => {
-                address_map.load(deps.storage, &source_chain).map_err(|_| {
-                    RegistryError::ChainAuthorizedAddressDoesNotExist {
-                        source_chain: source_chain.clone(),
-                    }
-                })?;
-
-                address_map.remove(deps.storage, &source_chain);
-                response.clone().add_attribute(
-                    "remove_authorized_address",
-                    format!("{source_chain}-{addr}"),
-                );
-            }
-        }
-    }
-    Ok(response)
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use crate::msg::ExecuteMsg;
-    use crate::query::{query_alias_for_denom_path, query_denom_path_for_alias};
-    use crate::{contract, helpers::test::initialize_contract};
-    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
-    static CREATOR_ADDRESS: &str = "creator";
-    static CHAIN_ADMIN: &str = "chain_admin";
-    static CHAIN_MAINTAINER: &str = "chain_maintainer";
-    static UNAUTHORIZED_ADDRESS: &str = "unauthorized_address";
-    use crate::contract::CONTRACT_CHAIN;
-
-    #[test]
-    fn test_set_contract_alias() {
-        let mut deps = mock_dependencies();
-        initialize_contract(deps.as_mut());
-        let alias = "swap_router".to_string();
-        let address = "osmo12smx2wdlyttvyzvzg54y2vnqwq2qjatel8rck9".to_string();
-
-        // Set contract alias swap_router to an address
-        let msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Set,
-                alias: alias.clone(),
-                address: Some(address),
-                new_alias: None,
-            }],
-        };
-
-        let info = mock_info(CREATOR_ADDRESS, &[]);
-        let res = contract::execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();
-        assert_eq!(0, res.messages.len());
-        assert_eq!(
-            CONTRACT_ALIAS_MAP
-                .load(&deps.storage, "swap_router")
-                .unwrap(),
-            "osmo12smx2wdlyttvyzvzg54y2vnqwq2qjatel8rck9"
-        );
-
-        // Attempt to set contract alias swap_router to a different address
-        let msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Set,
-                alias: alias.clone(),
-                address: Some("osmo1fsdaf7dsfasndjklk3jndskajnfkdjsfjn3jka".to_string()),
-                new_alias: None,
-            }],
-        };
-        let res = contract::execute(deps.as_mut(), mock_env(), info, msg).unwrap_err();
-        assert_eq!(res, ContractError::AliasAlreadyExists { alias });
-
-        // Verify that the alias was not updated
-        assert_eq!(
-            CONTRACT_ALIAS_MAP
-                .load(&deps.storage, "swap_router")
-                .unwrap(),
-            "osmo12smx2wdlyttvyzvzg54y2vnqwq2qjatel8rck9"
-        );
-
-        // Attempt to set a new contract alias new_contract_alias to an address via an unauthorized address
-        let msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Set,
-                alias: "new_contract_alias".to_string(),
-                address: Some("osmo1nna7k5lywn99cd63elcfqm6p8c5c4qcuqwwflx".to_string()),
-                new_alias: None,
-            }],
-        };
-        let unauthorized_info = mock_info(UNAUTHORIZED_ADDRESS, &[]);
-        let res = contract::execute(deps.as_mut(), mock_env(), unauthorized_info, msg).unwrap_err();
-        assert_eq!(res, ContractError::Unauthorized {});
-
-        // Verify that the new alias was not set
-        assert!(!CONTRACT_ALIAS_MAP.has(&deps.storage, "new_contract_alias"));
-    }
-
-    #[test]
-    fn test_modify_contract_alias() {
-        let mut deps = mock_dependencies();
-        initialize_contract(deps.as_mut());
-
-        let creator_info = mock_info(CREATOR_ADDRESS, &[]);
-        let external_unauthorized_info = mock_info(UNAUTHORIZED_ADDRESS, &[]);
-
-        let alias = "swap_router".to_string();
-        let address = "osmo12smx2wdlyttvyzvzg54y2vnqwq2qjatel8rck9".to_string();
-        let new_alias = "new_swap_router".to_string();
-        let new_alias_unauthorized = "new_new_swap_router".to_string();
-
-        // Set the contract alias swap_router to an address
-        let set_alias_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Set,
-                alias: alias.clone(),
-                address: Some(address.clone()),
-                new_alias: None,
-            }],
-        };
-        let set_alias_result = contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            creator_info.clone(),
-            set_alias_msg,
-        );
-        assert!(set_alias_result.is_ok());
-
-        // Change the contract alias swap_router to new_swap_router
-        let change_alias_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Change,
-                alias: alias.clone(),
-                address: None,
-                new_alias: Some(new_alias.clone()),
-            }],
-        };
-        let change_alias_result = contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            creator_info.clone(),
-            change_alias_msg,
-        );
-        assert!(change_alias_result.is_ok());
-
-        // Verify that the contract alias has changed from "swap_router" to "new_swap_router"
-        assert_eq!(
-            CONTRACT_ALIAS_MAP.load(&deps.storage, &new_alias).unwrap(),
-            address
-        );
-
-        // Attempt to change an alias that does not exist
-        let invalid_alias_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Change,
-                alias: alias.clone(),
-                address: None,
-                new_alias: Some(new_alias.clone()),
-            }],
-        };
-        let invalid_alias_result =
-            contract::execute(deps.as_mut(), mock_env(), creator_info, invalid_alias_msg);
-        let expected_error = ContractError::from(RegistryError::AliasDoesNotExist { alias });
-        assert_eq!(invalid_alias_result.unwrap_err(), expected_error);
-
-        // Attempt to change an existing alias to a new alias but with an unauthorized address
-        let unauthorized_alias_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Change,
-                alias: new_alias,
-                address: None,
-                new_alias: Some(new_alias_unauthorized.clone()),
-            }],
-        };
-        let unauthorized_alias_result = contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            external_unauthorized_info,
-            unauthorized_alias_msg,
-        );
-        let expected_error = ContractError::Unauthorized {};
-        assert_eq!(unauthorized_alias_result.unwrap_err(), expected_error);
-        assert!(!CONTRACT_ALIAS_MAP.has(&deps.storage, &new_alias_unauthorized));
-    }
-
-    #[test]
-    fn test_remove_contract_alias() {
-        let mut deps = mock_dependencies();
-        initialize_contract(deps.as_mut());
-
-        let alias = "swap_router".to_string();
-        let address = "osmo12smx2wdlyttvyzvzg54y2vnqwq2qjatel8rck9".to_string();
-
-        // Set contract alias "swap_router" to an address
-        let set_alias_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Set,
-                alias: alias.clone(),
-                address: Some(address.clone()),
-                new_alias: None,
-            }],
-        };
-        let creator_info = mock_info(CREATOR_ADDRESS, &[]);
-        contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            creator_info.clone(),
-            set_alias_msg,
-        )
-        .unwrap();
-
-        // Remove the alias
-        let remove_alias_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Remove,
-                alias: alias.clone(),
-                address: Some(address.clone()),
-                new_alias: None,
-            }],
-        };
-        contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            creator_info.clone(),
-            remove_alias_msg,
-        )
-        .unwrap();
-
-        // Verify that the alias no longer exists
-        let alias_exists = CONTRACT_ALIAS_MAP
-            .may_load(&deps.storage, "swap_router")
-            .unwrap()
-            .is_some();
-        assert!(!alias_exists, "alias should not exist");
-
-        // Attempt to remove an alias that does not exist
-        let non_existing_alias_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Remove,
-                alias: "non_existing_alias".to_string(),
-                address: Some(address.clone()),
-                new_alias: None,
-            }],
-        };
-        let result = contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            creator_info.clone(),
-            non_existing_alias_msg,
-        );
-
-        let expected_error = ContractError::from(RegistryError::AliasDoesNotExist {
-            alias: "non_existing_alias".to_string(),
-        });
-        assert_eq!(result.unwrap_err(), expected_error);
-
-        // Reset the contract alias "swap_router" to an address
-        let reset_alias_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Set,
-                alias: alias.clone(),
-                address: Some(address.clone()),
-                new_alias: None,
-            }],
-        };
-        contract::execute(deps.as_mut(), mock_env(), creator_info, reset_alias_msg).unwrap();
-
-        // Attempt to remove an alias with an unauthorized address
-        let unauthorized_remove_msg = ExecuteMsg::ModifyContractAlias {
-            operations: vec![ContractAliasInput {
-                operation: Operation::Remove,
-                alias,
-                address: Some(address),
-                new_alias: None,
-            }],
-        };
-        let unauthorized_info = mock_info(UNAUTHORIZED_ADDRESS, &[]);
-        let result = contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            unauthorized_info,
-            unauthorized_remove_msg,
-        );
-
-        let expected_error = ContractError::Unauthorized {};
-        assert_eq!(result.unwrap_err(), expected_error);
-    }
-
-    #[test]
-    fn test_set_chain_channel_link() {
-        let mut deps = mock_dependencies();
-        initialize_contract(deps.as_mut());
-
-        // Set the canonical channel link between osmosis and cosmos to channel-0
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Set,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "COSMOS".to_string(),
-                channel_id: Some("CHANNEL-0".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let info = mock_info(CREATOR_ADDRESS, &[]);
-        contract::execute(deps.as_mut(), mock_env(), info, msg).unwrap();
-
-        assert_eq!(
-            CHAIN_TO_CHAIN_CHANNEL_MAP
-                .load(&deps.storage, (CONTRACT_CHAIN, "cosmos"))
-                .unwrap(),
-            ("channel-0", true).into()
-        );
-
-        // Verify that channel-0 on osmosis is linked to cosmos
-        assert_eq!(
-            CHANNEL_ON_CHAIN_CHAIN_MAP
-                .load(&deps.storage, ("channel-0", CONTRACT_CHAIN))
-                .unwrap(),
-            ("cosmos", true).into()
-        );
-
-        // Attempt to set the canonical channel link between osmosis and cosmos to channel-150
-        // This should fail because the link already exists
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Set,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "cosmos".to_string(),
-                channel_id: Some("channel-150".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let info_creator = mock_info(CREATOR_ADDRESS, &[]);
-        let result = contract::execute(deps.as_mut(), mock_env(), info_creator, msg);
-        assert!(result.is_err());
-
-        let expected_error = ContractError::ChainToChainChannelLinkAlreadyExists {
-            source_chain: CONTRACT_CHAIN.to_string(),
-            destination_chain: "cosmos".to_string(),
-        };
-        assert_eq!(result.unwrap_err(), expected_error);
-        assert_eq!(
-            CHAIN_TO_CHAIN_CHANNEL_MAP
-                .load(&deps.storage, (CONTRACT_CHAIN, "cosmos"))
-                .unwrap(),
-            ("channel-0", true).into()
-        );
-        assert_eq!(
-            CHANNEL_ON_CHAIN_CHAIN_MAP
-                .load(&deps.storage, ("channel-0", CONTRACT_CHAIN))
-                .unwrap(),
-            ("cosmos", true).into()
-        );
-
-        // Attempt to set the canonical channel link between mars and osmosis to channel-1 with an unauthorized address
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Set,
-                source_chain: "mars".to_string(),
-                destination_chain: CONTRACT_CHAIN.to_string(),
-                channel_id: Some("channel-1".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let info_unauthorized = mock_info(UNAUTHORIZED_ADDRESS, &[]);
-        let result = contract::execute(deps.as_mut(), mock_env(), info_unauthorized, msg.clone());
-        assert!(result.is_err());
-
-        let expected_error = ContractError::Unauthorized {};
-        assert_eq!(result.unwrap_err(), expected_error);
-        assert!(!CHAIN_TO_CHAIN_CHANNEL_MAP.has(&deps.storage, ("mars", CONTRACT_CHAIN)));
-
-        // Set the canonical channel link between mars and osmosis to channel-1 with a mars chain admin address
-        let chain_admin_info = mock_info(CHAIN_ADMIN, &[]);
-        contract::execute(deps.as_mut(), mock_env(), chain_admin_info.clone(), msg).unwrap();
-        assert_eq!(
-            CHAIN_TO_CHAIN_CHANNEL_MAP
-                .load(&deps.storage, ("mars", CONTRACT_CHAIN))
-                .unwrap(),
-            ("channel-1", true).into()
-        );
-        assert_eq!(
-            CHANNEL_ON_CHAIN_CHAIN_MAP
-                .load(&deps.storage, ("channel-1", "mars"))
-                .unwrap(),
-            (CONTRACT_CHAIN, true).into()
-        );
-
-        // Set the canonical channel link between juno and mars to channel-2 with a juno chain maintainer address
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Set,
-                source_chain: "juno".to_string(),
-                destination_chain: "mars".to_string(),
-                channel_id: Some("channel-2".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        // Note: the chain admin address for mars and osmo is the chain maintainer for juno
-        // This is used to test privilege escalation next
-        let chain_admin_and_maintainer_info = mock_info(CHAIN_ADMIN, &[]);
-        contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            chain_admin_and_maintainer_info.clone(),
-            msg,
-        )
-        .unwrap();
-        assert_eq!(
-            CHAIN_TO_CHAIN_CHANNEL_MAP
-                .load(&deps.storage, ("juno", "mars"))
-                .unwrap(),
-            ("channel-2", true).into()
-        );
-        assert_eq!(
-            CHANNEL_ON_CHAIN_CHAIN_MAP
-                .load(&deps.storage, ("channel-2", "juno"))
-                .unwrap(),
-            ("mars", true).into()
-        );
-
-        // Separate test to ensure that the chain maintainer for juno but a chain admin elsewhere
-        // cannot perform a chain admin action (ensure no accidental privilege escalation)
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Remove,
-                source_chain: "juno".to_string(),
-                destination_chain: "mars".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let result = contract::execute(
-            deps.as_mut(),
-            mock_env(),
-            chain_admin_and_maintainer_info,
-            msg,
-        );
-        assert!(result.is_err());
-
-        let expected_error = ContractError::Unauthorized {};
-        assert_eq!(result.unwrap_err(), expected_error);
-
-        // Attempt to set the canonical channel link between regen and mars to channel-3 with a mars chain admin address
-        // This should fail because mars should not be able to set a link for regen
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Set,
-                source_chain: "regen".to_string(),
-                destination_chain: "mars".to_string(),
-                channel_id: Some("channel-3".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let result = contract::execute(deps.as_mut(), mock_env(), chain_admin_info, msg);
-        assert!(result.is_err());
-
-        let expected_error = ContractError::Unauthorized {};
-        assert_eq!(result.unwrap_err(), expected_error);
-        assert!(!CHAIN_TO_CHAIN_CHANNEL_MAP.has(&deps.storage, ("regen", "mars")));
-    }
-
-    #[test]
-    fn test_change_chain_channel_link() {
-        let mut deps = mock_dependencies();
-        initialize_contract(deps.as_mut());
-
-        // Set the canonical channel link between osmosis and cosmos to channel-0
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Set,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "COSMOS".to_string(),
-                channel_id: Some("CHANNEL-0".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let info_creator = mock_info(CREATOR_ADDRESS, &[]);
-        let result = contract::execute(deps.as_mut(), mock_env(), info_creator.clone(), msg);
-        assert!(result.is_ok());
-
-        // Change the canonical channel link between osmosis and cosmos to channel-150 with the global admin address
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Change,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "cosmos".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: Some("channel-150".to_string()),
-            }],
-        };
-        let result = contract::execute(deps.as_mut(), mock_env(), info_creator.clone(), msg);
-        assert!(result.is_ok());
-
-        // Verify that the channel between osmosis and cosmos has changed from channel-0 to channel-150
-        assert_eq!(
-            CHAIN_TO_CHAIN_CHANNEL_MAP
-                .load(&deps.storage, (CONTRACT_CHAIN, "cosmos"))
-                .unwrap(),
-            ("channel-150", true).into()
-        );
-
-        // Attempt to change a channel link that does not exist
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Change,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "regen".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: Some("channel-1".to_string()),
-            }],
-        };
-        let result = contract::execute(deps.as_mut(), mock_env(), info_creator.clone(), msg);
-        assert!(result.is_err());
-
-        let expected_error = ContractError::from(RegistryError::ChainChannelLinkDoesNotExist {
-            source_chain: CONTRACT_CHAIN.to_string(),
-            destination_chain: "regen".to_string(),
-        });
-        assert_eq!(result.unwrap_err(), expected_error);
-
-        // Change channel-0 link of osmosis from cosmos to regen with the global admin address
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Change,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "cosmos".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: Some("regen".to_string()),
-                new_channel_id: None,
-            }],
-        };
-        let result = contract::execute(deps.as_mut(), mock_env(), info_creator, msg);
-        assert!(result.is_ok());
-
-        // Verify that channel-150 on osmosis is linked to regen
-        assert_eq!(
-            CHANNEL_ON_CHAIN_CHAIN_MAP
-                .load(&deps.storage, ("channel-150", CONTRACT_CHAIN))
-                .unwrap(),
-            ("regen", true).into()
-        );
-
-        // Attempt to change the canonical channel link between osmosis and regen to channel-2 with an unauthorized address
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Change,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "regen".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: Some("channel-2".to_string()),
-            }],
-        };
-        let info_unauthorized = mock_info(UNAUTHORIZED_ADDRESS, &[]);
-        let result = contract::execute(deps.as_mut(), mock_env(), info_unauthorized, msg.clone());
-        assert!(result.is_err());
-
-        let expected_error = ContractError::Unauthorized {};
-        assert_eq!(result.unwrap_err(), expected_error);
-
-        // Set the canonical channel link between mars and osmosis to channel-1 with a chain admin address
-        let info_chain_admin = mock_info(CHAIN_ADMIN, &[]);
-        contract::execute(deps.as_mut(), mock_env(), info_chain_admin, msg).unwrap();
-        assert_eq!(
-            CHAIN_TO_CHAIN_CHANNEL_MAP
-                .load(&deps.storage, (CONTRACT_CHAIN, "regen"))
-                .unwrap(),
-            ("channel-2", true).into()
-        );
-
-        // Attempt to change a link that does not exist
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Change,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "cosmos".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: Some("channel-0".to_string()),
-            }],
-        };
-        let info = mock_info(CREATOR_ADDRESS, &[]);
-        let result = contract::execute(deps.as_mut(), mock_env(), info, msg);
-
-        let expected_error = ContractError::from(RegistryError::ChainChannelLinkDoesNotExist {
-            source_chain: CONTRACT_CHAIN.to_string(),
-            destination_chain: "cosmos".to_string(),
-        });
-        assert_eq!(result.unwrap_err(), expected_error);
-
-        // Attempt to update a osmosis channel link with a osmosis chain maintainer address
-        // Should fail because chain maintainer is not authorized to update any channel links
-        let chain_maintainer_info = mock_info(CHAIN_MAINTAINER, &[]);
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Change,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "regen".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: Some("channel-4".to_string()),
-            }],
-        };
-        let result = contract::execute(deps.as_mut(), mock_env(), chain_maintainer_info, msg);
-        assert!(result.is_err());
-
-        let expected_error = ContractError::Unauthorized {};
-        assert_eq!(result.unwrap_err(), expected_error);
-    }
-
-    #[test]
-    fn test_remove_chain_channel_link() {
-        let mut deps = mock_dependencies();
-        initialize_contract(deps.as_mut());
-
-        // Set up channels
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![
-                ConnectionInput {
-                    operation: FullOperation::Set,
-                    source_chain: CONTRACT_CHAIN.to_string(),
-                    destination_chain: "COSMOS".to_string(),
-                    channel_id: Some("CHANNEL-0".to_string()),
-                    new_source_chain: None,
-                    new_destination_chain: None,
-                    new_channel_id: None,
-                },
-                ConnectionInput {
-                    operation: FullOperation::Set,
-                    source_chain: CONTRACT_CHAIN.to_string(),
-                    destination_chain: "REGEN".to_string(),
-                    channel_id: Some("CHANNEL-1".to_string()),
-                    new_source_chain: None,
-                    new_destination_chain: None,
-                    new_channel_id: None,
-                },
-            ],
-        };
-        let info = mock_info(CREATOR_ADDRESS, &[]);
-        contract::execute(deps.as_mut(), mock_env(), info, msg).unwrap();
-
-        // Remove the osmosis cosmos link with a global admin address
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Remove,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "cosmos".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let info = mock_info(CREATOR_ADDRESS, &[]);
-        contract::execute(deps.as_mut(), mock_env(), info, msg.clone()).unwrap();
-
-        // Verify that the link no longer exists
-        assert!(!CHAIN_TO_CHAIN_CHANNEL_MAP.has(&deps.storage, (CONTRACT_CHAIN, "cosmos")));
-
-        let info = mock_info(CREATOR_ADDRESS, &[]);
-        let result = contract::execute(deps.as_mut(), mock_env(), info, msg);
-
-        let expected_error = ContractError::from(RegistryError::ChainChannelLinkDoesNotExist {
-            source_chain: CONTRACT_CHAIN.to_string(),
-            destination_chain: "cosmos".to_string(),
-        });
-        assert_eq!(result.unwrap_err(), expected_error);
-
-        // Attempt to remove the osmosis regen link with a osmosis chain maintainer address
-        // Should fail because chain maintainer is not authorized to remove any channel links
-        let chain_maintainer_info = mock_info(CHAIN_MAINTAINER, &[]);
-        let msg = ExecuteMsg::ModifyChainChannelLinks {
-            operations: vec![ConnectionInput {
-                operation: FullOperation::Remove,
-                source_chain: CONTRACT_CHAIN.to_string(),
-                destination_chain: "regen".to_string(),
-                channel_id: None,
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            }],
-        };
-        let result = contract::execute(deps.as_mut(), mock_env(), chain_maintainer_info, msg);
-        assert!(result.is_err());
-
-        let expected_error = ContractError::Unauthorized {};
-        assert_eq!(result.unwrap_err(), expected_error);
-    }
-
-    #[test]
-    fn test_set_bech32_prefix_to_chain() {
-        let mut deps = mock_dependencies();
-        initialize_contract(deps.as_mut());
-
-        // Set the canonical channel link between osmosis and cosmos to channel-0
-        let msg = ExecuteMsg::ModifyBech32Prefixes {
-            operations: vec![ChainToBech32PrefixInput {
-                operation: FullOperation::Set,
-                chain_name: CONTRACT_CHAIN.to_string(),
-                prefix: "OSMO".to_string(),
-                new_prefix: None,
-            }],
-        };
-        let info = mock_info(CREATOR_ADDRESS, &[]);
-        contract::execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();
-
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_MAP
-                .load(&deps.storage, CONTRACT_CHAIN)
-                .unwrap(),
-            ("osmo", true).into()
-        );
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_REVERSE_MAP
-                .load(&deps.storage, "osmo")
-                .unwrap(),
-            vec![CONTRACT_CHAIN]
-        );
-
-        // Set another chain with the same prefix
-        let msg = ExecuteMsg::ModifyBech32Prefixes {
-            operations: vec![ChainToBech32PrefixInput {
-                operation: FullOperation::Set,
-                chain_name: "ISMISIS".to_string(),
-                prefix: "OSMO".to_string(),
-                new_prefix: None,
-            }],
-        };
-        contract::execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();
-
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_MAP
-                .load(&deps.storage, "ismisis")
-                .unwrap(),
-            ("osmo", true).into()
-        );
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_REVERSE_MAP
-                .load(&deps.storage, "osmo")
-                .unwrap(),
-            vec![CONTRACT_CHAIN, "ismisis"]
-        );
-
-        // Set another chain with the same prefix
-        let msg = ExecuteMsg::ModifyBech32Prefixes {
-            operations: vec![ChainToBech32PrefixInput {
-                operation: FullOperation::Disable,
-                chain_name: CONTRACT_CHAIN.to_string(),
-                prefix: "OSMO".to_string(),
-                new_prefix: None,
-            }],
-        };
-        contract::execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_MAP
-                .load(&deps.storage, CONTRACT_CHAIN)
-                .unwrap(),
-            ("osmo", false).into()
-        );
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_REVERSE_MAP
-                .load(&deps.storage, "osmo")
-                .unwrap(),
-            vec!["ismisis"]
-        );
-
-        // Set another chain with the same prefix
-        let msg = ExecuteMsg::ModifyBech32Prefixes {
-            operations: vec![ChainToBech32PrefixInput {
-                operation: FullOperation::Enable,
-                chain_name: CONTRACT_CHAIN.to_string(),
-                prefix: "OSMO".to_string(),
-                new_prefix: None,
-            }],
-        };
-        contract::execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_MAP
-                .load(&deps.storage, CONTRACT_CHAIN)
-                .unwrap(),
-            ("osmo", true).into()
-        );
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_REVERSE_MAP
-                .load(&deps.storage, "osmo")
-                .unwrap(),
-            vec!["ismisis", CONTRACT_CHAIN]
-        );
-
-        // Set another chain with the same prefix
-        let msg = ExecuteMsg::ModifyBech32Prefixes {
-            operations: vec![ChainToBech32PrefixInput {
-                operation: FullOperation::Remove,
-                chain_name: CONTRACT_CHAIN.to_string(),
-                prefix: "OSMO".to_string(),
-                new_prefix: None,
-            }],
-        };
-        contract::execute(deps.as_mut(), mock_env(), info, msg).unwrap();
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_MAP
-                .load(&deps.storage, "ismisis")
-                .unwrap(),
-            ("osmo", true).into()
-        );
-        assert_eq!(
-            CHAIN_TO_BECH32_PREFIX_REVERSE_MAP
-                .load(&deps.storage, "osmo")
-                .unwrap(),
-            vec!["ismisis"]
-        );
-
-        CHAIN_TO_BECH32_PREFIX_MAP
-            .load(&deps.storage, CONTRACT_CHAIN)
-            .unwrap_err();
-    }
-
-    #[test]
-    fn test_denom_alias_operations() {
-        let mut deps = mock_dependencies();
-
-        initialize_contract(deps.as_mut());
-
-        let path1 = "transfer/channel-0/1denom";
-
-        let msg = ExecuteMsg::ModifyDenomAlias {
-            operations: vec![DenomAliasInput {
-                operation: FullOperation::Set,
-                full_denom_path: path1.to_string(),
-                alias: "alias1".to_string(),
-            }],
-        };
-
-        // Test case: Set an alias
-        let info = mock_info(CREATOR_ADDRESS, &[]);
-        let res = contract::execute(deps.as_mut(), mock_env(), info, msg).unwrap();
-
-        assert_eq!(
-            DENOM_ALIAS_MAP
-                .may_load(deps.as_ref().storage, path1)
-                .unwrap(),
-            Some(("alias1".to_string(), true).into())
-        );
-        assert_eq!(
-            DENOM_ALIAS_REVERSE_MAP
-                .may_load(deps.as_ref().storage, "alias1")
-                .unwrap(),
-            Some((path1.to_string(), true).into())
-        );
-        assert_eq!(
-            res.attributes,
-            vec![("set_denom_alias".to_string(), format!("alias1 <=> {path1}"))]
-        );
-
-        // Check queries
-        assert_eq!(
-            query_denom_path_for_alias(deps.as_ref(), "alias1").unwrap(),
-            path1
-        );
-        assert_eq!(
-            query_alias_for_denom_path(deps.as_ref(), path1).unwrap(),
-            "alias1"
-        );
-
-        // Test case: Change an alias
-        let change_msg = ExecuteMsg::ModifyDenomAlias {
-            operations: vec![DenomAliasInput {
-                operation: FullOperation::Change,
-                full_denom_path: path1.to_string(),
-                alias: "newalias1".to_string(),
-            }],
-        };
-
-        let change_info = mock_info(CREATOR_ADDRESS, &[]);
-
-        let change_res =
-            contract::execute(deps.as_mut(), mock_env(), change_info, change_msg).unwrap();
-
-        assert_eq!(
-            DENOM_ALIAS_MAP
-                .may_load(deps.as_ref().storage, path1)
-                .unwrap(),
-            Some(("newalias1".to_string(), true).into())
-        );
-        assert_eq!(
-            DENOM_ALIAS_REVERSE_MAP
-                .may_load(deps.as_ref().storage, "alias1")
-                .unwrap(),
-            None
-        );
-        assert_eq!(
-            DENOM_ALIAS_REVERSE_MAP
-                .may_load(deps.as_ref().storage, "newalias1")
-                .unwrap(),
-            Some((path1.to_string(), true).into())
-        );
-
-        assert_eq!(
-            change_res.attributes,
-            vec![(
-                "change_denom_alias".to_string(),
-                format!("newalias1 <=> {path1}")
-            )]
-        );
-
-        // Check queries
-        query_denom_path_for_alias(deps.as_ref(), "alias1").unwrap_err();
-        assert_eq!(
-            query_denom_path_for_alias(deps.as_ref(), "newalias1").unwrap(),
-            path1
-        );
-        assert_eq!(
-            query_alias_for_denom_path(deps.as_ref(), path1).unwrap(),
-            "newalias1"
-        );
-
-        // Test case: Disable an alias
-        let disable_msg = ExecuteMsg::ModifyDenomAlias {
-            operations: vec![DenomAliasInput {
-                operation: FullOperation::Disable,
-                full_denom_path: path1.to_string(),
-                alias: "newalias1".to_string(),
-            }],
-        };
-
-        let disable_info = mock_info(CREATOR_ADDRESS, &[]);
-        let disable_res =
-            contract::execute(deps.as_mut(), mock_env(), disable_info, disable_msg).unwrap();
-
-        assert_eq!(
-            DENOM_ALIAS_MAP
-                .may_load(deps.as_ref().storage, path1)
-                .unwrap(),
-            Some(("newalias1".to_string(), false).into())
-        );
-        assert_eq!(
-            DENOM_ALIAS_REVERSE_MAP
-                .may_load(deps.as_ref().storage, "newalias1")
-                .unwrap(),
-            Some((path1.to_string(), false).into())
-        );
-
-        assert_eq!(
-            disable_res.attributes,
-            vec![(
-                "disable_denom_alias".to_string(),
-                format!("newalias1 <=> {path1}")
-            )]
-        );
-
-        // Check queries
-        query_denom_path_for_alias(deps.as_ref(), "newalias1").unwrap_err();
-        query_alias_for_denom_path(deps.as_ref(), path1).unwrap_err();
-
-        // Re-enable the alias
-        let enable_msg = ExecuteMsg::ModifyDenomAlias {
-            operations: vec![DenomAliasInput {
-                operation: FullOperation::Enable,
-                full_denom_path: path1.to_string(),
-                alias: "doesntmatter".to_string(),
-            }],
-        };
-
-        let enable_info = mock_info(CREATOR_ADDRESS, &[]);
-        let enable_res =
-            contract::execute(deps.as_mut(), mock_env(), enable_info, enable_msg).unwrap();
-
-        assert_eq!(
-            DENOM_ALIAS_MAP
-                .may_load(deps.as_ref().storage, path1)
-                .unwrap(),
-            Some(("newalias1", true).into())
-        );
-        assert_eq!(
-            DENOM_ALIAS_REVERSE_MAP
-                .may_load(deps.as_ref().storage, "newalias1")
-                .unwrap(),
-            Some((path1.to_string(), true).into())
-        );
-
-        assert_eq!(
-            enable_res.attributes,
-            vec![(
-                "enable_denom_alias".to_string(),
-                format!("newalias1 <=> {path1}")
-            )]
-        );
-
-        assert_eq!(
-            query_denom_path_for_alias(deps.as_ref(), "newalias1").unwrap(),
-            path1
-        );
-        assert_eq!(
-            query_alias_for_denom_path(deps.as_ref(), path1).unwrap(),
-            "newalias1"
-        );
-
-        // Test case: Remove an alias
-        let remove_msg = ExecuteMsg::ModifyDenomAlias {
-            operations: vec![DenomAliasInput {
-                operation: FullOperation::Remove,
-                full_denom_path: path1.to_string(),
-                alias: "unusedaliascanbeanything".to_string(),
-            }],
-        };
-
-        let remove_info = mock_info(CREATOR_ADDRESS, &[]);
-        let remove_res =
-            contract::execute(deps.as_mut(), mock_env(), remove_info, remove_msg).unwrap();
-
-        assert_eq!(
-            DENOM_ALIAS_MAP
-                .may_load(deps.as_ref().storage, path1)
-                .unwrap(),
-            None
-        );
-        assert_eq!(
-            DENOM_ALIAS_REVERSE_MAP
-                .may_load(deps.as_ref().storage, "new_alias1")
-                .unwrap(),
-            None
-        );
-
-        assert_eq!(
-            remove_res.attributes,
-            vec![("remove_denom_alias".to_string(), "newalias1".to_string())]
-        );
-
-        query_denom_path_for_alias(deps.as_ref(), "newalias1").unwrap_err();
-        query_alias_for_denom_path(deps.as_ref(), path1).unwrap_err();
-    }
-
-    #[test]
-    fn transfer_ownership() {
-        let mut deps = mock_dependencies();
-
-        let owner = initialize_contract(deps.as_mut());
-        let owner_info = mock_info(owner.as_str(), &vec![] as &Vec<cosmwasm_std::Coin>);
-
-        let new_owner = "new_owner".to_string();
-        // The owner can transfer ownership
-        let msg = ExecuteMsg::TransferOwnership {
-            new_owner: new_owner.clone(),
-        };
-        contract::execute(deps.as_mut(), mock_env(), owner_info, msg).unwrap();
-
-        let config = CONFIG.load(&deps.storage).unwrap();
-        assert_eq!(new_owner, config.owner);
-    }
-
-    #[test]
-    fn transfer_ownership_unauthorized() {
-        let mut deps = mock_dependencies();
-
-        let owner = initialize_contract(deps.as_mut());
-
-        let other_info = mock_info("other_sender", &vec![] as &Vec<cosmwasm_std::Coin>);
-
-        // An unauthorized user cannot transfer ownership
-        let msg = ExecuteMsg::TransferOwnership {
-            new_owner: "new_owner".to_string(),
-        };
-        contract::execute(deps.as_mut(), mock_env(), other_info, msg).unwrap_err();
-
-        let config = CONFIG.load(&deps.storage).unwrap();
-        assert_eq!(owner, config.owner);
-    }
-}
diff --git a/cosmwasm/contracts/crosschain-registry/src/exports.rs b/cosmwasm/contracts/crosschain-registry/src/exports.rs
deleted file mode 100644
index 8b1378917..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/exports.rs
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/cosmwasm/contracts/crosschain-registry/src/helpers.rs b/cosmwasm/contracts/crosschain-registry/src/helpers.rs
deleted file mode 100644
index 8a85b863e..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/helpers.rs
+++ /dev/null
@@ -1,355 +0,0 @@
-use cosmwasm_std::{Addr, Deps};
-use cw_storage_plus::Map;
-
-use crate::execute::{FullOperation, Permission};
-use crate::state::{CHAIN_ADMIN_MAP, CHAIN_MAINTAINER_MAP, CONFIG, GLOBAL_ADMIN_MAP};
-use crate::ContractError;
-
-// check_is_contract_governor is used for functions that can only be called by the contract governor
-pub fn check_is_contract_governor(deps: Deps, sender: Addr) -> Result<(), ContractError> {
-    let config = CONFIG.load(deps.storage).unwrap();
-    if config.owner != sender {
-        Err(ContractError::Unauthorized {})
-    } else {
-        Ok(())
-    }
-}
-
-// check_permission checks if an account with the provided permission has _at least_ the requested permission level
-pub fn check_permission(
-    requested_permission: Permission,
-    user_permission: Permission,
-) -> Result<(), ContractError> {
-    if user_permission == Permission::GlobalAdmin {
-        return Ok(());
-    }
-    if user_permission == Permission::ChainAdmin
-        && (requested_permission == Permission::ChainAdmin
-            || requested_permission == Permission::ChainMaintainer)
-    {
-        return Ok(());
-    }
-    if user_permission == Permission::ChainMaintainer
-        && requested_permission == Permission::ChainMaintainer
-    {
-        return Ok(());
-    }
-    Err(ContractError::Unauthorized {})
-}
-
-// check_action_permission checks if an account with the provided permission is authorized to perform the action requested
-pub fn check_action_permission(
-    provided_action: FullOperation,
-    user_permission: Permission,
-) -> Result<(), ContractError> {
-    if user_permission == Permission::GlobalAdmin || user_permission == Permission::ChainAdmin {
-        return Ok(());
-    }
-    if user_permission == Permission::ChainMaintainer
-        && (provided_action == FullOperation::Set
-            || provided_action == FullOperation::Disable
-            || provided_action == FullOperation::Enable)
-    {
-        return Ok(());
-    }
-    Err(ContractError::Unauthorized {})
-}
-
-pub fn is_owner(deps: Deps, sender: &Addr) -> bool {
-    CONFIG
-        .load(deps.storage)
-        .map(|config| config.owner == sender)
-        .map_err(|_| false)
-        .unwrap_or(false)
-}
-
-pub fn is_global_admin(deps: Deps, sender: &Addr) -> bool {
-    GLOBAL_ADMIN_MAP
-        .load(deps.storage, "osmosis")
-        .map(|global_admin| global_admin == sender)
-        .map_err(|_| false)
-        .unwrap_or(false)
-}
-
-pub fn check_is_authorized(
-    deps: Deps,
-    sender: Addr,
-    source_chain: Option<String>,
-) -> Result<Permission, ContractError> {
-    if check_is_global_admin(deps, sender.clone()).is_ok() {
-        return Ok(Permission::GlobalAdmin);
-    }
-    if check_is_chain_admin(deps, sender.clone(), source_chain.clone()).is_ok() {
-        return Ok(Permission::ChainAdmin);
-    }
-    check_is_chain_maintainer(deps, sender, source_chain)?;
-    Ok(Permission::ChainMaintainer)
-}
-
-// check_is_global_admin is used for functions that can only be called by the contract governor
-pub fn check_is_global_admin(deps: Deps, sender: Addr) -> Result<(), ContractError> {
-    let config = CONFIG.load(deps.storage).unwrap();
-    // If the sender is the contract governor, they are authorized to make changes
-    if config.owner == sender {
-        return Ok(());
-    }
-
-    // If the sender an authorized address, they are authorized to make changes
-    let authorized_addr = GLOBAL_ADMIN_MAP
-        .may_load(deps.storage, "osmosis")
-        .unwrap_or_default();
-    if authorized_addr.eq(&Some(sender)) {
-        return Ok(());
-    }
-
-    Err(ContractError::Unauthorized {})
-}
-
-// check_is_chain_admin checks if the sender is the contract governor or if the sender is
-// authorized to make changes to the provided source chain
-pub fn check_is_chain_admin(
-    deps: Deps,
-    sender: Addr,
-    source_chain: Option<String>,
-) -> Result<(), ContractError> {
-    // If the sender is the authorized address for the source chain, they are authorized to make changes
-    if let Some(source_chain) = source_chain {
-        let authorized_addr = CHAIN_ADMIN_MAP
-            .may_load(deps.storage, &source_chain.to_lowercase())
-            .unwrap_or_default();
-        if authorized_addr.eq(&Some(sender)) {
-            return Ok(());
-        }
-    }
-    Err(ContractError::Unauthorized {})
-}
-
-// check_is_chain_maintainer checks if the sender is the contract governor or if the sender is
-// authorized to make changes to the provided source chain
-pub fn check_is_chain_maintainer(
-    deps: Deps,
-    sender: Addr,
-    source_chain: Option<String>,
-) -> Result<(), ContractError> {
-    // If the sender is the authorized address for the source chain, they are authorized to make changes
-    if let Some(source_chain) = source_chain {
-        let authorized_addr = CHAIN_MAINTAINER_MAP
-            .may_load(deps.storage, &source_chain.to_lowercase())
-            .unwrap_or_default();
-        if authorized_addr.eq(&Some(sender)) {
-            return Ok(());
-        }
-    }
-    Err(ContractError::Unauthorized {})
-}
-
-fn is_alphanumeric(string: &str) -> bool {
-    string.chars().all(|c| c.is_alphanumeric())
-}
-
-pub fn normalize_alias(alias: &str) -> Result<String, ContractError> {
-    if !is_alphanumeric(alias) {
-        return Err(ContractError::InvalidAlias {
-            alias: alias.into(),
-        });
-    }
-    if alias.is_empty() {
-        return Err(ContractError::MissingField {
-            field: "new_alias".to_string(),
-        });
-    }
-    Ok(alias.to_lowercase())
-}
-
-// Helper functions to deal with Vec values in cosmwasm maps
-pub fn push_to_map_value<'a, K, T>(
-    storage: &mut dyn cosmwasm_std::Storage,
-    map: &Map<'a, K, Vec<T>>,
-    key: K,
-    value: T,
-) -> Result<(), ContractError>
-where
-    T: serde::Serialize + serde::de::DeserializeOwned + Clone,
-    K: cw_storage_plus::PrimaryKey<'a>,
-{
-    map.update(storage, key, |existing| -> Result<_, ContractError> {
-        match existing {
-            Some(mut v) => {
-                v.push(value);
-                Ok(v)
-            }
-            None => Ok(vec![value]),
-        }
-    })?;
-    Ok(())
-}
-
-pub fn remove_from_map_value<'a, K, T>(
-    storage: &mut dyn cosmwasm_std::Storage,
-    map: &Map<'a, K, Vec<T>>,
-    key: K,
-    value: T,
-) -> Result<(), ContractError>
-where
-    T: serde::Serialize + serde::de::DeserializeOwned + Clone + PartialEq,
-    K: cw_storage_plus::PrimaryKey<'a>,
-{
-    map.update(storage, key, |existing| -> Result<_, ContractError> {
-        match existing {
-            Some(mut v) => {
-                v.retain(|val| *val != value);
-                Ok(v)
-            }
-            None => Ok(vec![value]),
-        }
-    })?;
-    Ok(())
-}
-
-#[cfg(test)]
-pub mod test {
-    use crate::execute;
-    use crate::execute::AuthorizedAddressInput;
-    use crate::msg;
-    use crate::ContractError;
-    use crate::{contract, msg::InstantiateMsg};
-    use cosmwasm_std::testing::{
-        mock_dependencies, mock_env, mock_info, MockApi, MockQuerier, MockStorage,
-    };
-    use cosmwasm_std::{Addr, DepsMut, OwnedDeps};
-
-    static CREATOR_ADDRESS: &str = "creator";
-    static CHAIN_ADMIN: &str = "chain_admin";
-    static CHAIN_MAINTAINER: &str = "chain_maintainer";
-
-    pub fn initialize_contract(mut deps: DepsMut) -> Addr {
-        let msg = InstantiateMsg {
-            owner: String::from(CREATOR_ADDRESS),
-        };
-        let creator_info = mock_info(CREATOR_ADDRESS, &[]);
-
-        contract::instantiate(deps.branch(), mock_env(), creator_info.clone(), msg).unwrap();
-
-        // Set the CHAIN_ADMIN address as the osmosis and mars chain admin
-        let msg = msg::ExecuteMsg::ModifyAuthorizedAddresses {
-            operations: vec![
-                AuthorizedAddressInput {
-                    operation: execute::Operation::Set,
-                    source_chain: "osmosis".to_string(),
-                    permission: Some(execute::Permission::ChainAdmin),
-                    addr: Addr::unchecked(CHAIN_ADMIN.to_string()),
-                    new_addr: None,
-                },
-                AuthorizedAddressInput {
-                    operation: execute::Operation::Set,
-                    source_chain: "mars".to_string(),
-                    permission: Some(execute::Permission::ChainAdmin),
-                    addr: Addr::unchecked(CHAIN_ADMIN.to_string()),
-                    new_addr: None,
-                },
-            ],
-        };
-        contract::execute(deps.branch(), mock_env(), creator_info.clone(), msg).unwrap();
-
-        // Set the CHAIN_MAINTAINER address as the osmosis and mars chain maintainer with the chain admin
-        let msg = msg::ExecuteMsg::ModifyAuthorizedAddresses {
-            operations: vec![
-                AuthorizedAddressInput {
-                    operation: execute::Operation::Set,
-                    source_chain: "osmosis".to_string(),
-                    permission: Some(execute::Permission::ChainMaintainer),
-                    addr: Addr::unchecked(CHAIN_MAINTAINER.to_string()),
-                    new_addr: None,
-                },
-                AuthorizedAddressInput {
-                    operation: execute::Operation::Set,
-                    source_chain: "mars".to_string(),
-                    permission: Some(execute::Permission::ChainMaintainer),
-                    addr: Addr::unchecked(CHAIN_MAINTAINER.to_string()),
-                    new_addr: None,
-                },
-            ],
-        };
-        let chain_admin_info = mock_info(CHAIN_ADMIN, &[]);
-        contract::execute(deps.branch(), mock_env(), chain_admin_info, msg).unwrap();
-
-        // Set the CHAIN_ADMIN address as the juno chain maintainer
-        // This is used to ensure that permissions don't bleed over from one chain to another
-        let msg = msg::ExecuteMsg::ModifyAuthorizedAddresses {
-            operations: vec![AuthorizedAddressInput {
-                operation: execute::Operation::Set,
-                source_chain: "juno".to_string(),
-                permission: Some(execute::Permission::ChainMaintainer),
-                addr: Addr::unchecked(CHAIN_ADMIN.to_string()),
-                new_addr: None,
-            }],
-        };
-        contract::execute(deps, mock_env(), creator_info.clone(), msg).unwrap();
-
-        creator_info.sender
-    }
-
-    pub fn setup() -> Result<OwnedDeps<MockStorage, MockApi, MockQuerier>, ContractError> {
-        let mut deps = mock_dependencies();
-        let governor = initialize_contract(deps.as_mut());
-        let info = mock_info(governor.as_str(), &[]);
-
-        // Set up the contract aliases
-        let operation = vec![
-            execute::ContractAliasInput {
-                operation: execute::Operation::Set,
-                alias: "contract_one".to_string(),
-                address: Some("osmo1dfaselkjh32hnkljw3nlklk2lknmes".to_string()),
-                new_alias: None,
-            },
-            execute::ContractAliasInput {
-                operation: execute::Operation::Set,
-                alias: "contract_two".to_string(),
-                address: Some("osmo1dfg4k3jhlknlfkjdslkjkl43klnfdl".to_string()),
-                new_alias: None,
-            },
-            execute::ContractAliasInput {
-                operation: execute::Operation::Set,
-                alias: "contract_three".to_string(),
-                address: Some("osmo1dfgjlk4lkfklkld32fsdajknjrrgfg".to_string()),
-                new_alias: None,
-            },
-        ];
-
-        execute::contract_alias_operations(deps.as_mut(), info.sender.clone(), operation)?;
-
-        // Set up the chain channels
-        let operations = vec![
-            execute::ConnectionInput {
-                operation: execute::FullOperation::Set,
-                source_chain: "osmosis".to_string(),
-                destination_chain: "juno".to_string(),
-                channel_id: Some("channel-42".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            },
-            execute::ConnectionInput {
-                operation: execute::FullOperation::Set,
-                source_chain: "osmosis".to_string(),
-                destination_chain: "stargaze".to_string(),
-                channel_id: Some("channel-75".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            },
-            execute::ConnectionInput {
-                operation: execute::FullOperation::Set,
-                source_chain: "stargaze".to_string(),
-                destination_chain: "osmosis".to_string(),
-                channel_id: Some("channel-0".to_string()),
-                new_source_chain: None,
-                new_destination_chain: None,
-                new_channel_id: None,
-            },
-        ];
-        execute::connection_operations(deps.as_mut(), info.sender, operations)?;
-
-        Ok(deps)
-    }
-}
diff --git a/cosmwasm/contracts/crosschain-registry/src/ibc_lifecycle.rs b/cosmwasm/contracts/crosschain-registry/src/ibc_lifecycle.rs
deleted file mode 100644
index 7e43d3b70..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/ibc_lifecycle.rs
+++ /dev/null
@@ -1,46 +0,0 @@
-use cosmwasm_std::{DepsMut, Response};
-use registry::Registry;
-
-use crate::{contract::CONTRACT_CHAIN, state::CHAIN_PFM_MAP, ContractError};
-
-pub fn receive_ack(
-    deps: DepsMut,
-    registry_address: String,
-    source_channel: String,
-    _sequence: u64,
-    _ack: String,
-    success: bool,
-) -> Result<Response, ContractError> {
-    deps.api.debug(&format!("receive_ack: {registry_address}"));
-    let registry = Registry::new(deps.as_ref(), registry_address)?;
-    let chain = registry.get_connected_chain(CONTRACT_CHAIN, source_channel.as_str())?;
-    let mut chain_pfm = CHAIN_PFM_MAP.load(deps.storage, &chain).map_err(|_| {
-        ContractError::ValidationNotFound {
-            chain: chain.clone(),
-        }
-    })?;
-
-    if success {
-        chain_pfm.acknowledged = true;
-        CHAIN_PFM_MAP.save(deps.storage, &chain, &chain_pfm)?;
-    } else {
-        CHAIN_PFM_MAP.remove(deps.storage, &chain);
-    }
-
-    Ok(Response::default())
-}
-
-pub fn receive_timeout(
-    deps: DepsMut,
-    registry_address: String,
-    source_channel: String,
-    _sequence: u64,
-) -> Result<Response, ContractError> {
-    deps.api
-        .debug(&format!("receive_timeout: {registry_address}"));
-    let registry = Registry::new(deps.as_ref(), registry_address)?;
-    let chain = registry.get_connected_chain(CONTRACT_CHAIN, source_channel.as_str())?;
-    CHAIN_PFM_MAP.remove(deps.storage, &chain);
-
-    Ok(Response::default())
-}
diff --git a/cosmwasm/contracts/crosschain-registry/src/lib.rs b/cosmwasm/contracts/crosschain-registry/src/lib.rs
deleted file mode 100644
index c00aae18b..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/lib.rs
+++ /dev/null
@@ -1,11 +0,0 @@
-pub mod contract;
-mod error;
-pub mod execute;
-mod exports;
-pub mod helpers;
-mod ibc_lifecycle;
-pub mod msg;
-pub mod query;
-pub mod state;
-
-pub use crate::error::ContractError;
diff --git a/cosmwasm/contracts/crosschain-registry/src/msg.rs b/cosmwasm/contracts/crosschain-registry/src/msg.rs
deleted file mode 100644
index 5769dbdd1..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/msg.rs
+++ /dev/null
@@ -1,94 +0,0 @@
-use cosmwasm_schema::cw_serde;
-
-use crate::execute;
-
-#[cw_serde]
-pub struct InstantiateMsg {
-    pub owner: String,
-}
-
-#[cw_serde]
-pub enum ExecuteMsg {
-    // Contract Registry
-    ModifyDenomAlias {
-        operations: Vec<execute::DenomAliasInput>,
-    },
-
-    ModifyContractAlias {
-        operations: Vec<execute::ContractAliasInput>,
-    },
-
-    // Chain to Chain Channel Registry
-    ModifyChainChannelLinks {
-        operations: Vec<execute::ConnectionInput>,
-    },
-
-    // Bech32 Prefix Registry
-    ModifyBech32Prefixes {
-        operations: Vec<execute::ChainToBech32PrefixInput>,
-    },
-
-    // Authorized Address Registry
-    ModifyAuthorizedAddresses {
-        operations: Vec<execute::AuthorizedAddressInput>,
-    },
-
-    // Transfer Ownership
-    TransferOwnership {
-        new_owner: String,
-    },
-
-    // Add PFM to the registry
-    #[serde(rename = "propose_pfm")]
-    ProposePFM {
-        chain: String,
-    },
-    #[serde(rename = "validate_pfm")]
-    ValidatePFM {
-        chain: String,
-    },
-
-    UnwrapCoin {
-        receiver: String,
-        into_chain: Option<String>,
-        #[serde(default = "String::new")]
-        with_memo: String,
-    },
-}
-
-// Import the queries from the package to avoid cyclic dependencies
-pub use registry::msg::QueryMsg;
-pub use registry::msg::{
-    GetAddressFromAliasResponse, GetChannelFromChainPairResponse,
-    GetDestinationChainFromSourceChainViaChannelResponse,
-    QueryGetBech32PrefixFromChainNameResponse,
-};
-
-#[cw_serde]
-pub enum IBCLifecycleComplete {
-    #[serde(rename = "ibc_ack")]
-    IBCAck {
-        /// The source channel (osmosis side) of the IBC packet
-        channel: String,
-        /// The sequence number that the packet was sent with
-        sequence: u64,
-        /// String encoded version of the ack as seen by OnAcknowledgementPacket(..)
-        ack: String,
-        /// Whether an ack is a success of failure according to the transfer spec
-        success: bool,
-    },
-    #[serde(rename = "ibc_timeout")]
-    IBCTimeout {
-        /// The source channel (osmosis side) of the IBC packet
-        channel: String,
-        /// The sequence number that the packet was sent with
-        sequence: u64,
-    },
-}
-
-/// Message type for `sudo` entry_point
-#[cw_serde]
-pub enum SudoMsg {
-    #[serde(rename = "ibc_lifecycle_complete")]
-    IBCLifecycleComplete(IBCLifecycleComplete),
-}
diff --git a/cosmwasm/contracts/crosschain-registry/src/query.rs b/cosmwasm/contracts/crosschain-registry/src/query.rs
deleted file mode 100644
index 0d58aad32..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/query.rs
+++ /dev/null
@@ -1,130 +0,0 @@
-use crate::state::{
-    CHAIN_PFM_MAP, CHAIN_TO_BECH32_PREFIX_MAP, CHAIN_TO_BECH32_PREFIX_REVERSE_MAP,
-    CHAIN_TO_CHAIN_CHANNEL_MAP, CHANNEL_ON_CHAIN_CHAIN_MAP, DENOM_ALIAS_MAP,
-    DENOM_ALIAS_REVERSE_MAP,
-};
-
-use cosmwasm_std::{Deps, StdError};
-use registry::proto::{DenomTrace, QueryDenomTraceRequest};
-
-pub fn query_denom_trace_from_ibc_denom(
-    deps: Deps,
-    ibc_denom: String,
-) -> Result<DenomTrace, StdError> {
-    let res = QueryDenomTraceRequest { hash: ibc_denom }.query(&deps.querier)?;
-
-    match res.denom_trace {
-        Some(denom_trace) => Ok(denom_trace),
-        None => Err(StdError::generic_err("No denom trace found")),
-    }
-}
-
-pub fn query_bech32_prefix_from_chain_name(
-    deps: Deps,
-    chain_name: String,
-) -> Result<String, StdError> {
-    let chain_to_bech32_prefix_map = CHAIN_TO_BECH32_PREFIX_MAP.load(deps.storage, &chain_name)?;
-
-    if !chain_to_bech32_prefix_map.enabled {
-        return Err(StdError::generic_err(format!(
-            "Chain {chain_name} to bech32 prefix mapping is disabled"
-        )));
-    }
-
-    Ok(chain_to_bech32_prefix_map.value)
-}
-
-pub fn query_chain_name_from_bech32_prefix(deps: Deps, prefix: String) -> Result<String, StdError> {
-    let chains = CHAIN_TO_BECH32_PREFIX_REVERSE_MAP.load(deps.storage, &prefix)?;
-    if chains.len() > 1 {
-        return Err(StdError::generic_err(format!(
-            "Bech32 prefix {prefix} is not unique"
-        )));
-    }
-
-    match chains.first() {
-        Some(chain) => Ok(chain.to_string()),
-        None => Err(StdError::generic_err(format!(
-            "Bech32 prefix {prefix} is not found"
-        ))),
-    }
-}
-
-pub fn query_channel_from_chain_pair(
-    deps: Deps,
-    source_chain: String,
-    destination_chain: String,
-) -> Result<String, StdError> {
-    let channel = CHAIN_TO_CHAIN_CHANNEL_MAP.load(
-        deps.storage,
-        (
-            &source_chain.to_lowercase(),
-            &destination_chain.to_lowercase(),
-        ),
-    )?;
-
-    if !channel.enabled {
-        return Err(StdError::generic_err(format!(
-            "Channel from {source_chain} to {destination_chain} mapping is disabled"
-        )));
-    }
-
-    Ok(channel.value)
-}
-
-pub fn query_chain_from_channel_chain_pair(
-    deps: Deps,
-    on_chain: String,
-    via_channel: String,
-) -> Result<String, StdError> {
-    let chain = CHANNEL_ON_CHAIN_CHAIN_MAP.load(
-        deps.storage,
-        (&via_channel.to_lowercase(), &on_chain.to_lowercase()),
-    )?;
-
-    if !chain.enabled {
-        return Err(StdError::generic_err(format!(
-            "Destination chain from channel {on_chain} on source chain {via_channel} mapping is disabled"
-        )));
-    }
-
-    Ok(chain.value)
-}
-
-pub fn query_chain_has_pfm(deps: Deps, chain: String) -> bool {
-    let chain = chain.to_lowercase();
-    if let Ok(chain_pfm) = CHAIN_PFM_MAP.load(deps.storage, &chain) {
-        deps.api.debug(&format!("{chain_pfm:?}"));
-        chain_pfm.is_validated()
-    } else {
-        false
-    }
-}
-
-pub fn query_denom_path_for_alias(deps: Deps, alias: &str) -> Result<String, StdError> {
-    let path = DENOM_ALIAS_REVERSE_MAP
-        .load(deps.storage, alias)
-        .map_err(|_| StdError::GenericErr {
-            msg: format!("alias {alias} cannot be found"),
-        })?;
-
-    if !path.enabled {
-        return Err(StdError::GenericErr {
-            msg: format!("alias {alias} is disabled"),
-        });
-    }
-
-    Ok(path.value)
-}
-
-pub fn query_alias_for_denom_path(deps: Deps, denom_path: &str) -> Result<String, StdError> {
-    let alias = DENOM_ALIAS_MAP.load(deps.storage, denom_path)?;
-
-    if !alias.enabled {
-        return Err(StdError::generic_err(format!(
-            "alias for path {denom_path} is disabled"
-        )));
-    }
-
-    Ok(alias.value)
-}
diff --git a/cosmwasm/contracts/crosschain-registry/src/state.rs b/cosmwasm/contracts/crosschain-registry/src/state.rs
deleted file mode 100644
index 3586336df..000000000
--- a/cosmwasm/contracts/crosschain-registry/src/state.rs
+++ /dev/null
@@ -1,142 +0,0 @@
-use cosmwasm_schema::cw_serde;
-use cosmwasm_std::Addr;
-use cw_storage_plus::{Item, Map};
-
-// Enum to map short strings to storage keys
-enum StorageKey {
-    ContractAliasMap,
-    ChainToChainChannelMap,
-    ChannelOnChainChainMap,
-    ChainToBech32PrefixMap,
-    ChainToBech32PrefixReverseMap,
-    Config,
-    GlobalAdminMap,
-    ChainAdminMap,
-    ChainMaintainerMap,
-    HasPacketForwardMiddleware,
-    DenomAliasMap,
-    DenomAliasReverseMap,
-}
-
-// Implement the `StorageKey` enum to a string conversion.
-impl StorageKey {
-    const fn to_string(&self) -> &'static str {
-        match self {
-            StorageKey::ContractAliasMap => "cam",
-            StorageKey::ChainToChainChannelMap => "ctccm",
-            StorageKey::ChannelOnChainChainMap => "cotccm",
-            StorageKey::ChainToBech32PrefixMap => "ctbpm",
-            StorageKey::ChainToBech32PrefixReverseMap => "ctbprm",
-            StorageKey::Config => "cfg",
-            StorageKey::GlobalAdminMap => "gam",
-            StorageKey::ChainAdminMap => "cam",
-            StorageKey::ChainMaintainerMap => "cmm",
-            StorageKey::HasPacketForwardMiddleware => "hpfm",
-            StorageKey::DenomAliasMap => "dam",
-            StorageKey::DenomAliasReverseMap => "darm",
-        }
-    }
-}
-
-#[cw_serde]
-pub struct RegistryValue {
-    pub value: String,
-    pub enabled: bool,
-}
-
-impl<T: AsRef<str>> From<(T, bool)> for RegistryValue {
-    fn from((value, enabled): (T, bool)) -> Self {
-        Self {
-            value: value.as_ref().to_string(),
-            enabled,
-        }
-    }
-}
-
-/// ChainPFM stores the state of the packet forward middleware for a chain. Anyone can request
-/// to enable the packet forward middleware for a chain, but the contract will verify that  
-/// packets can properly be forwarded by the chain
-#[cw_serde]
-#[derive(Default)]
-pub struct ChainPFM {
-    /// The verification packet has been received by the chain, forwarded, and the ack has been received
-    pub acknowledged: bool,
-    /// The contract has validated that the received packet is as expected
-    pub validated: bool,
-    /// The address that initiated the propose_pfm flow
-    pub initiator: Option<Addr>,
-}
-
-impl ChainPFM {
-    /// Both acknowledged and validated must be true for the pfm to be enabled. This is to avoid
-    /// situations in which the chain calls the contract to set validated to true but that call is
-    /// not from the same packet that was forwarded by this contract.
-    pub fn is_validated(&self) -> bool {
-        self.acknowledged && self.validated
-    }
-
-    pub fn new(initiator: Addr) -> Self {
-        Self {
-            acknowledged: false,
-            validated: false,
-            initiator: Some(initiator),
-        }
-    }
-}
-
-// CONTRACT_ALIAS_MAP is a map from a contract alias to a contract address
-pub const CONTRACT_ALIAS_MAP: Map<&str, String> =
-    Map::new(StorageKey::ContractAliasMap.to_string());
-
-// CHAIN_TO_CHAIN_CHANNEL_MAP is a map from source<>destination chain pair to its respective channel id.
-// The boolean value indicates whether the mapping is enabled or not.
-// (SOURCE_CHAIN_ID, DESTINATION_CHAIN_ID) -> (CHANNEL_ID, ENABLED)
-pub const CHAIN_TO_CHAIN_CHANNEL_MAP: Map<(&str, &str), RegistryValue> =
-    Map::new(StorageKey::ChainToChainChannelMap.to_string());
-
-// CHANNEL_TO_CHAIN_CHAIN_MAP is a map from a channel id on a source chain to its respective destination chain.
-// The boolean value indicates whether the mapping is enabled or not.
-// (CHANNEL_ID, SOURCE_CHAIN_ID) -> (DESTINATION_CHAIN_ID, ENABLED)
-pub const CHANNEL_ON_CHAIN_CHAIN_MAP: Map<(&str, &str), RegistryValue> =
-    Map::new(StorageKey::ChannelOnChainChainMap.to_string());
-
-// CHAIN_TO_BECH32_PREFIX_MAP is a map from a chain id to its respective bech32 prefix.
-// The boolean value indicates whether the mapping is enabled or not.
-// CHAIN_ID -> (BECH32_PREFIX, ENABLED)
-pub const CHAIN_TO_BECH32_PREFIX_MAP: Map<&str, RegistryValue> =
-    Map::new(StorageKey::ChainToBech32PrefixMap.to_string());
-
-// CHAIN_TO_BECH32_PREFIX_REVERSE_MAP is a map from a bech32 prefix to the chains that use that prefix
-pub const CHAIN_TO_BECH32_PREFIX_REVERSE_MAP: Map<&str, Vec<String>> =
-    Map::new(StorageKey::ChainToBech32PrefixReverseMap.to_string());
-
-// CONFIG stores the contract owner
-pub const CONFIG: Item<Config> = Item::new(StorageKey::Config.to_string());
-
-// CHAIN_ADMIN_MAP is a map from a source chain to the address that is authorized to add, update, or remove channels for that source chain
-// TODO: why isn't this an item?
-pub const GLOBAL_ADMIN_MAP: Map<&str, Addr> = Map::new(StorageKey::GlobalAdminMap.to_string());
-
-// CHAIN_ADMIN_MAP is a map from a source chain to the address that is authorized to add, update, or remove channels for that source chain
-pub const CHAIN_ADMIN_MAP: Map<&str, Addr> = Map::new(StorageKey::ChainAdminMap.to_string());
-
-// CHAIN_MAINTAINER_MAP is a map from a source chain to the address that is authorized add, enable, or disable channels for that source chain
-pub const CHAIN_MAINTAINER_MAP: Map<&str, Addr> =
-    Map::new(StorageKey::ChainMaintainerMap.to_string());
-
-// CHAIN_PFM_MAP stores whether a chain supports the Packet Forward Middleware interface for forwarding IBC packets
-pub const CHAIN_PFM_MAP: Map<&str, ChainPFM> =
-    Map::new(StorageKey::HasPacketForwardMiddleware.to_string());
-
-// DENOM_ALIAS_MAP is a map from a denom path to a denom alias
-pub const DENOM_ALIAS_MAP: Map<&str, RegistryValue> =
-    Map::new(StorageKey::DenomAliasMap.to_string());
-
-// DENOM_ALIAS_REVERSE_MAP is a map from a denom alias to a denom path
-pub const DENOM_ALIAS_REVERSE_MAP: Map<&str, RegistryValue> =
-    Map::new(StorageKey::DenomAliasReverseMap.to_string());
-
-#[cw_serde]
-pub struct Config {
-    pub owner: Addr,
-}
diff --git a/cosmwasm/contracts/crosschain-registry/xcs_regsitry_permission_chart.jpeg b/cosmwasm/contracts/crosschain-registry/xcs_regsitry_permission_chart.jpeg
deleted file mode 100644
index fc4d1b66d..000000000
Binary files a/cosmwasm/contracts/crosschain-registry/xcs_regsitry_permission_chart.jpeg and /dev/null differ
diff --git a/cosmwasm/contracts/crosschain-swaps/Cargo.toml b/cosmwasm/contracts/crosschain-swaps/Cargo.toml
index a88e6bb11..1697a960c 100644
--- a/cosmwasm/contracts/crosschain-swaps/Cargo.toml
+++ b/cosmwasm/contracts/crosschain-swaps/Cargo.toml
@@ -47,6 +47,7 @@ path = "build-schema/schema.rs"
 [dependencies]
 cosmwasm-schema =  { workspace = true }
 cosmwasm-std =  { workspace = true }
+cosmwasm-storage = { workspace = true }
 cw-storage-plus = { workspace = true }
 cw2 = { workspace = true }
 schemars = { workspace = true }
@@ -57,14 +58,12 @@ serde-json-wasm = { workspace = true }
 serde-cw-value = { workspace = true }
 bech32 = { workspace = true }
 cw-utils = { workspace = true }
-itertools = {workspace = true}
 
 swaprouter = { path = "../swaprouter", features = ["imported"]}
-registry = { path = "../../packages/registry"}
 prost = {version = "0.11.2", default-features = false, features = ["prost-derive"]}
+osmosis-std-derive = "0.13.2"
 enum-repr = "0.2.6"
 
 [dev-dependencies]
 cw-multi-test = { workspace = true }
-osmosis-test-tube = { workspace = true }
-crosschain-registry = { path = "../crosschain-registry", features = ["imported"]}
\ No newline at end of file
+osmosis-testing = { workspace = true }
diff --git a/cosmwasm/contracts/crosschain-swaps/README.md b/cosmwasm/contracts/crosschain-swaps/README.md
index 01a30105e..65ac7f2c4 100644
--- a/cosmwasm/contracts/crosschain-swaps/README.md
+++ b/cosmwasm/contracts/crosschain-swaps/README.md
@@ -7,30 +7,17 @@ The goal is to use this contract to provide *crosschain swaps*: sending an ICS20
 transfer on chain A, receiving it on osmosis, swapping for a different token,
 and forwarding to a different chain.
 
-## XCS v1 vs XCS v2
-
-There are two versions of the crosschain swaps contract. The first version allows users
-to swap via instructions in the memo as described above. This is enough to do swaps with
-arbitrary complexity but still requires users to build the memo manually, which implies
-knowing about the channels used to transfer the tokens in each intermediate hop, the canonical
-ibc denoms of tokens on osmosis, and when to use packet forward middleware vs callbacks.
-
-The second version of the contract simplifies this for users by keeping registries with the 
-necessary information and doing the token unwinding automatically. 
-
-This documentation is for the latest version of the contract. For v1, see the [previous docs](https://github.com/osmosis-labs/osmosis/tree/v15.x/cosmwasm/contracts/crosschain-swaps)
-
 ## Instantiation
 
 To instantiate the contract, you need to specify the following parameters:
 
  * swap_contract: the swaprouter contract to be used
- * governor: The address that will be allowed to manage which swap_contract to use 
+ * channels: a list of (bech32 prefix, channel_id) that the contract will allow. 
 
 ### Example instantiation message
 
 ``` json
-{"swap_contract": "osmo1thiscontract", "governor": "osmo1..."}
+{"swap_contract": "osmo1thiscontract", "channels": [["cosmos", "channel-0"], ["juno", "channel-42"]]}
 ```
 
 ## Usage
@@ -55,8 +42,6 @@ of an IBC transfer to do crosschain swaps would look as follows:
 }}
 ```
 
-TODO: Expand documentation on how to specify receivers
-
 Channels are determined by the prefixes specified in the contract during
 instantiation, so the user needs to provide a receiver with the supported
 prefix. This will probably change in the future 
@@ -85,32 +70,6 @@ Any JSON object is accepted as a valid memo, as long as it doesn't contain the
 key "ibc_callback". That key is used internally for the contract to track the 
 success or failure of the packet delivery.
 
-
-### Error handling
-
-This is general high level description of failures happen during cross chain swaps.
-
-When doing cross chain transfers and swaps it is important to know where funds will end up in case of inability to transfer tokens, swap tokens, or some generic infrastructure failures.
-
-We will consider the scenario where a user transfers tokens from chain A to Osmosis, swaps, and transfers the result further to chain B.
-
-When user sends tokens for XCS, in case of packet timeout or failure, the transaction on Osmosis is never settled and the user is returned all his tokens.
-It is important to consider who the sender is here. If the sender is a contract (like the `outpost` contract, which is a thin wrapper around IBC sends),
-the contract is considered the sender and tokens will be refunded to it. It is the contract's responsibility to allow the original user to recover these funds.
-The outpost contract does not currently provide this functionality as it is currently mostly used as an example for integrators. If tokens were to get stuck on
-the outpost contract, the user would need either a contract migration or help from governance to recover them.
-
-In the case of multi-hop sends, the behaviour may vary (and depends on the versions of packet forward middleware 
-implemented in the intermediate chains. In the latest version of pfm, the tx will fail and the tokens will be refunded to the sender.
-on XCSv1, if the intermediate chain does not implement PFM, the tokens will be stuck on the intermediate chain; XCSv2, however, 
-implements a registry of which chains that support PFM and will not allow sending tokens to chains that don't support it.  
-
-In case of success of swap, swapped tokens are forwarded to chain B.  If for any reason delivery to chain B fails, 
-the tokens are retained on the `crosschain-swaps` contract and can be recovered by the failed delivery address if specified.
-Failed delivery addresses are an osmosis account. The owner of that account needs to be able to use it to call the contract 
-and the recovered tokens will be sent to that account.  
-Osmosis ensures that both timeout and failures of IBC packets attempted to be delivered to B work like that.
-
 #### Response
 
 The contract will return the following response:
@@ -130,203 +89,6 @@ or as json:
 {"sent_amount": "818", "denom": "token0", "channel_id": "channel-42", "receiver": "juno1receiver", "packet_sequence": 17}
 ```
 
-## Usage examples
-
-Here are some usage examples of sending tokens on the live versions of the contracts:
-
-### XCS v1
-
-#### Native to Native
-
-To swap from a chain's native token to another chain's native token. 
-
-For this example we will swap JUNO stored in the Juno, for ATOM and send it to Gaia. 
-
-To do that you can execute an IBC transfer on the first chain (juno) with a memo like the following:
-
-```json
-{
-  "wasm": {
-    "contract": "osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs",  // XCS contract
-    "msg": {
-      "osmosis_swap": {
-        "output_denom": "ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2",  // ATOM on osmosis
-        "slippage": {
-          "twap": {
-            "slippage_percentage": "20",
-            "window_seconds": 10
-          }
-        },
-        "receiver": "cosmos1tfu4j7nzfhtex2wyp946rm02748zxu8w0kvt87",  // Address on gaia
-        "on_failed_delivery": "do_nothing"
-      }
-    }
-  }
-}
-```
-
-The full command to execute this is:
-
-```bash
-junod  --node https://rpc.cosmos.directory:443/juno tx ibc-transfer transfer transfer channel-0 osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs 100ujuno   \
---from testaccount -y --gas auto --gas-prices 0.1ujuno --gas-adjustment 1.3 \
---memo '{"wasm":{"contract":"osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs","msg":{"osmosis_swap":{"output_denom":"ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2","slippage":{"twap":{"slippage_percentage":"20","window_seconds":10}},"receiver":"cosmos1tfu4j7nzfhtex2wyp946rm02748zxu8w0kvt87","on_failed_delivery":"do_nothing"}}}}'
-```
-
-TODO: Add an example in TS
-
-#### Native to Osmosis native
-
-Similarly, if you wanted to swap for a token that is native to osmosis (osmo, ion, or tokenfactory tokens) you can use a 
-memo like the one above but with the appropriate values for the token and receiver.
-
-```json
-{
-  "wasm": {
-    "contract": "osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs",
-    "msg": {
-      "osmosis_swap": {
-        "output_denom": "uosmo",  // Osmosis native token
-        "slippage": {
-          "twap": {
-            "slippage_percentage": "20",
-            "window_seconds": 10
-          }
-        },
-        "receiver": "juno1tfu4j7nzfhtex2wyp946rm02748zxu8wey0sqz",  // The receiver is now on juno
-        "on_failed_delivery": "do_nothing"
-      }
-    }
-  }
-}
-```
-
-
-```bash
-junod  --node https://rpc.cosmos.directory:443/juno tx ibc-transfer transfer transfer channel-0 osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs 100738ujuno   \
---from testaccount -y --gas auto --gas-prices 0.1ujuno --gas-adjustment 1.3 \
---memo '{"wasm":{"contract":"osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs","msg":{"osmosis_swap":{"output_denom":"uosmo","slippage":{"twap":{"slippage_percentage":"20","window_seconds":10}},"receiver":"juno1tfu4j7nzfhtex2wyp946rm02748zxu8wey0sqz","on_failed_delivery":"do_nothing"}}}}'
-```
-
-TODO: Add an example in TS
-
-
-#### Native to Non-Native
-
-Sometimes, the token you want to receive is neither native to the chain initiating the swap, nor to osmosis.
-
-In this case we will need to unwind the path of this token using the packet forward middleware (which needs
-to be supported by the intermediate chain).
-
-For this example, we will swap OSMO stored in juno to ATOM and send it back to juno. 
-
-If we did this like the previous examples we would end up with a token that isn't recognized 
-as ATOM on juno. This is because the pools on osmosis use ATOM sent directly from gaia
-and not via juno (i.e.: osmosis(ATOM) != osmosis(juno(ATOM))).
-
-To fix this, we will use the packet forward middleware to unwind the path of the token. The final memo would be:
-
-```json
-{
-    "wasm": {
-        "contract": "osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs",
-        "msg": {
-            "osmosis_swap": {
-                "output_denom": "ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2",  // ATOM on osmosis
-                "receiver": "cosmos1tfu4j7nzfhtex2wyp946rm02748zxu8w0kvt87",  // Intermediate receiver
-                "slippage": {
-                   "twap": {
-                      "slippage_percentage": "20",
-                      "window_seconds": 10
-                   }
-                },
-                "next_memo": {
-                    "forward": {
-                        "receiver": "juno1tfu4j7nzfhtex2wyp946rm02748zxu8wey0sqz",  // Final receiver
-                        "port": "transfer",
-                        "channel": "channel-207"  // Juno's channel on gaia
-                    }
-                },
-               "on_failed_delivery": "do_nothing"
-            }
-        }
-    }
-}
-```
-
-Note that in this example we are using OSMO stored in juno, so the token we send is 
-`ibc/ED07A3391A112B175915CD8FAF43A2DA8E4790EDE12566649D0C2F97716B8518` and not `ujuno` like in previous examples.
-
-```bash
-junod  --node https://rpc.cosmos.directory:443/juno tx ibc-transfer transfer transfer channel-0 osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs 100ibc/ED07A3391A112B175915CD8FAF43A2DA8E4790EDE12566649D0C2F97716B8518   \
---from testaccount -y --gas auto --gas-prices 0.1ujuno --gas-adjustment 1.3 \
---memo '{"wasm":{"contract":"osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs","msg":{"osmosis_swap":{"output_denom":"ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2","receiver":"cosmos1tfu4j7nzfhtex2wyp946rm02748zxu8w0kvt87","slippage":{"twap":{"slippage_percentage":"20","window_seconds":10}},"next_memo":{"forward":{"receiver":"juno1tfu4j7nzfhtex2wyp946rm02748zxu8wey0sqz","port":"transfer","channel":"channel-207"}},"on_failed_delivery":"do_nothing"}}}}'
-```
-
-#### Non-Native to Non-Native
-
-Similarly to the above example, if the token we want to send send for swapping is not the native to the sender or 
-to osmosis, then we need to do the denom path unwinding as part of the IBC packet sent. 
-
-For this example, we will use ATOM stored on juno, swap it for JUNO and send it to gaia.
-
-
-```json
-{
-    "forward": {
-        "receiver": "osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs",  // XCS contract
-        "port": "transfer",
-        "channel": "channel-141",  // Osmosis channel on gaia
-        "next": {
-            "wasm": {
-                "contract": "osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs",  // XCS contract
-                "msg": {
-                    "osmosis_swap": {
-                        "output_denom": "ibc/46B44899322F3CD854D2D46DEEF881958467CDD4B3B10086DA49296BBED94BED",  // Juno denom on osmosis
-                        "receiver": "juno1tfu4j7nzfhtex2wyp946rm02748zxu8wey0sqz",  // temp receiver
-                        "slippage": {
-                           "twap": {
-                              "slippage_percentage": "20",
-                              "window_seconds": 10
-                           }
-                        },
-                        "next_memo": {
-                            "forward": {
-                                "receiver": "cosmos1tfu4j7nzfhtex2wyp946rm02748zxu8w0kvt87",  // final receiver
-                                "port": "transfer",
-                                "channel": "channel-1"  // gaia's channel on juno
-                            }
-                        },
-                       "on_failed_delivery": "do_nothing"
-                    }
-                }
-            }
-        }
-    }
-}
-```
-The full command is:
-
-```bash
-junod  --node https://rpc.cosmos.directory:443/juno tx ibc-transfer transfer transfer channel-1 cosmos1tfu4j7nzfhtex2wyp946rm02748zxu8w0kvt87 1ibc/C4CFF46FD6DE35CA4CF4CE031E643C8FDC9BA4B99AE598E9B0ED98FE3A2319F9   \
---from testaccount -y --gas auto --gas-prices 0.1ujuno --gas-adjustment 1.3 \
---memo '{"forward":{"receiver":"osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs","port":"transfer","channel":"channel-141","next":{"wasm":{"contract":"osmo1uwk8xc6q0s6t5qcpr6rht3sczu6du83xq8pwxjua0hfj5hzcnh3sqxwvxs","msg":{"osmosis_swap":{"output_denom":"ibc/46B44899322F3CD854D2D46DEEF881958467CDD4B3B10086DA49296BBED94BED","receiver":"juno1tfu4j7nzfhtex2wyp946rm02748zxu8wey0sqz","slippage":{"twap":{"slippage_percentage":"20","window_seconds":10}},"next_memo":{"forward":{"receiver":"cosmos1tfu4j7nzfhtex2wyp946rm02748zxu8w0kvt87","port":"transfer","channel":"channel-1"}},"on_failed_delivery":"do_nothing"}}}}}}'
-```
-
-Note that as opposed to the previous example, we send the tokens to gaia first, so the channel we use 
-is channel-1 (gaia) and the  (temporary) receiver is a cosmos1 address. Similarly, the token we send is
-`ibc/C4CFF46FD6DE35CA4CF4CE031E643C8FDC9BA4B99AE598E9B0ED98FE3A2319F9` which is 
-ATOM on juno.
-
-
-
-### XCS v2
-
-XCSv2 should take care of the complexities of unwrapping tokens and sending them to the correct chain. When that 
-is finished, we should document it here.
-
-TODO: Add examples when the contracts are ready and deployed
-
 
 ## Requirements
 
@@ -356,16 +118,6 @@ osmosis testnets and a relayer between them.
 
 #### Setup
 
-Compile the contracts using the Rust workspace optimizer:
-
-```bash
-cd osmosis/cosmwasm
-docker run --rm -v "$(pwd)":/code \
-      --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
-      --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
-      cosmwasm/workspace-optimizer-arm64:0.12.13
-```
-
 Create an alias for chainA and chainB commands that will be used throughout the guide:
 
 ```bash
@@ -376,9 +128,9 @@ alias chainB="osmosisd --node http://localhost:36657 --chain-id localosmosis-b"
 Prepare other variables that we will use across the test:
 
 ```bash
-VALIDATOR=$(osmosisd keys show validator -a --keyring-backend test)
+VALIDATOR=$(osmosisd keys show validator -a)
 CHANNEL_ID="channel-0"
-args="--keyring-backend test --gas auto --gas-prices 0.1uosmo --gas-adjustment 2 --broadcast-mode block --yes"
+args="--keyring-backend test --gas auto --gas-prices 0.1uosmo --gas-adjustment 1.3 --broadcast-mode block --yes"
 TX_FLAGS=($args)
 ```
 
@@ -394,8 +146,8 @@ This will generate two keys, validator and faucet and will be used to send money
 #### Fund accounts on both chains
 
 ```bash
-chainA tx bank send faucet "$VALIDATOR" 3000000000uosmo "${TX_FLAGS[@]}"
-chainB tx bank send faucet "$VALIDATOR" 3000000000uosmo "${TX_FLAGS[@]}"
+chainA tx bank send faucet "$VALIDATOR" 1000000000uosmo "${TX_FLAGS[@]}"
+chainB tx bank send faucet "$VALIDATOR" 1000000000uosmo "${TX_FLAGS[@]}"
 ```
 We will use the validator account as our main account for this test. This sends 1000000000uosmo from the faucet that account.
 
@@ -435,7 +187,7 @@ EOF
 Create the pool:
 
 ```bash
-chainB tx gamm create-pool --pool-file sample_pool.json --from validator  "${TX_FLAGS[@]}"
+chainB tx gamm create-pool --pool-file sample_pool.json --from validator --yes  -b block
 ```
 
 export the pool id:
@@ -449,7 +201,7 @@ export POOL_ID=$(chainB query gamm pools -o json | jq -r '.pools[-1].id')
 Store the contract:
 
 ```bash
-chainB tx wasm store ./artifacts/swaprouter.wasm --from validator "${TX_FLAGS[@]}"
+chainB tx wasm store ./bytecode/swaprouter.wasm --from validator "${TX_FLAGS[@]}"
 ```
 
 Get the code id:
@@ -462,20 +214,20 @@ Instantiate the contract:
 
 ```bash
 MSG=$(jenv -c '{"owner": $VALIDATOR}')
-chainB tx wasm instantiate "$SWAPROUTER_CODE_ID" "$MSG" --from validator --admin $VALIDATOR --label swaprouter --yes  -b block --keyring-backend test "${TX_FLAGS[@]}"
+chainB tx wasm instantiate "$SWAPROUTER_CODE_ID" "$MSG" --from validator --admin $VALIDATOR --label swaprouter --yes  -b block
 ```
 
 Export the swaprouter contract address:
 
 ```bash
-export SWAPROUTER_ADDRESS=$(chainB query wasm list-contract-by-code "$SWAPROUTER_CODE_ID" -o json | jq -r '.contracts[-1]')
+export SWAPROUTER_ADDRESS=$(chainB query wasm list-contract-by-code "$SWAPROUTER_CODE_ID" -o json | jq -r '.contracts[-1].address')
 ```
 
 #### Add the pool to the swaprouter
 
 ```bash
 MSG=$(jenv -c '{"set_route":{"input_denom":$DENOM,"output_denom":"uosmo","pool_route":[{"pool_id":$POOL_ID,"token_out_denom":"uosmo"}]}}')
-chainB tx wasm execute "$SWAPROUTER_ADDRESS" "$MSG" --from validator -y --keyring-backend test "${TX_FLAGS[@]}"
+chainB tx wasm execute "$SWAPROUTER_ADDRESS" "$MSG" --from validator -y
 ```
 
 #### Store and instantiate the crosschain swaps contract
@@ -483,20 +235,20 @@ chainB tx wasm execute "$SWAPROUTER_ADDRESS" "$MSG" --from validator -y --keyrin
 Store the contract:
 
 ```bash
-chainB tx wasm store ./artifacts/crosschain_swaps.wasm --from validator "${TX_FLAGS[@]}"
+chainB tx wasm store ./bytecode/crosschainswaps.wasm --from validator "${TX_FLAGS[@]}"
 ```
 
 Get the code id:
 
 ```bash
-CROSSCHAINSWAPS_CODE_ID=$(chainB query wasm list-code -o json | jq -r '.code_infos[-1].code_id')
+CROSSCHAINSWAPS_CODE_ID=$(chainA query wasm list-code -o json | jq -r '.code_infos[-1].code_id')
 ```
 
 Instantiate the contract:
 
 ```bash
-MSG=$(jenv -c '{"swap_contract": $SWAPROUTER_ADDRESS, "channels": [["osmo", $CHANNEL_ID]], "governor": $VALIDATOR}')
-chainB tx wasm instantiate "$CROSSCHAINSWAPS_CODE_ID" "$MSG" --from validator --admin $VALIDATOR --label=crosschain_swaps --yes -b block --keyring-backend test "${TX_FLAGS[@]}"
+MSG=$(jenv -c '{"swap_contract": $SWAPROUTER_ADDRESS, "channels": [["osmo", $CHANNEL_ID]]}')
+chainB tx wasm instantiate "$CROSSCHAIN_SWAPS_CODE_ID" "$MSG" --from validator --admin $VALIDATOR --label=crosschain_swaps --yes  -b block
 ```
 
 The channels here describe the allowed channels that the cross chain swap contract will accept for the receiver.
@@ -508,7 +260,7 @@ No other bech32 prefixes are allowed in this example.
 
 
 ```bash
-export CROSSCHAIN_SWAPS_ADDRESS=$(chainB query wasm list-contract-by-code "$CROSSCHAINSWAPS_CODE_ID" -o json | jq -r '.contracts | [last][0]')
+export CROSSCHAIN_SWAPS_ADDRESS=$(chainB query wasm list-contract-by-code "$CROSSCHAIN_SWAPS_CODE_ID" -o json | jq -r '.contracts | [last][0]')
 ```
 
 #### Prepare to perform the crosschain swap
@@ -563,17 +315,17 @@ sequenceDiagram
     actor Alice
     actor Alice
     Alice->>ChainA: Send Transfer M1
-    Note over ChainA,Relayer: Block committed. 
+    Note over ChainA,Relayer: Block commited. 
     Relayer-->>ChainB: Relay M1
     critical Execute Contract
             ChainB->>ChainB: Swap tokens
             ChainB->>ChainB: Send IBC tx M2
     end
-    Note over ChainB,Relayer: Block committed. 
+    Note over ChainB,Relayer: Block commited. 
     Relayer-->>ChainA: Ack M1
     Relayer-->>ChainA: Relay M2
     ChainA->>Alice: Send Swapped Tokens
-    Note over ChainA,Relayer: Block committed. 
+    Note over ChainA,Relayer: Block commited. 
     Relayer-->>ChainB: Ack M2
 ```
 
diff --git a/cosmwasm/contracts/crosschain-swaps/src/checks.rs b/cosmwasm/contracts/crosschain-swaps/src/checks.rs
index 5b99ce967..dcc3eebef 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/checks.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/checks.rs
@@ -1,15 +1,9 @@
 use cosmwasm_std::{Addr, Deps};
-use itertools::{self, Itertools};
-use registry::Registry;
 
-use crate::state::CONFIG;
-use crate::ContractError;
-
-pub fn get_registry(deps: Deps) -> Result<Registry, ContractError> {
-    let registry_addr = CONFIG.load(deps.storage)?.registry_contract.to_string();
-    deps.api.debug(&format!("get_registry {registry_addr:?}"));
-    Ok(Registry::new(deps, registry_addr)?)
-}
+use crate::{
+    state::{CHANNEL_MAP, CONFIG, DISABLED_PREFIXES},
+    ContractError,
+};
 
 pub fn check_is_contract_governor(deps: Deps, sender: Addr) -> Result<(), ContractError> {
     let config = CONFIG.load(deps.storage).unwrap();
@@ -22,7 +16,7 @@ pub fn check_is_contract_governor(deps: Deps, sender: Addr) -> Result<(), Contra
 
 /// If the specified receiver is an explicit channel+addr, extract the parts
 /// and use the strings as provided
-fn validate_explicit_receiver(deps: Deps, receiver: &str) -> Result<(String, Addr), ContractError> {
+fn validate_explicit_receiver(receiver: &str) -> Result<(String, Addr), ContractError> {
     let (channel, address) = receiver
         .strip_prefix("ibc:")
         .and_then(|s| s.split_once('/'))
@@ -37,45 +31,46 @@ fn validate_explicit_receiver(deps: Deps, receiver: &str) -> Result<(String, Add
             receiver: receiver.to_string(),
         });
     }
+    let channel_id = &channel[8..];
+    if channel_id.is_empty() || channel_id.parse::<u64>().is_err() {
+        return Err(ContractError::InvalidReceiver {
+            receiver: receiver.to_string(),
+        });
+    };
 
     let Ok(_) = bech32::decode(&address) else {
         return Err(ContractError::InvalidReceiver { receiver: receiver.to_string() })
     };
 
-    let registry = get_registry(deps)?;
-    let chain = registry.get_connected_chain("osmosis", &channel)?;
-    // TODO: validate that the prefix of the receiver matches the chain
-
-    Ok((chain, Addr::unchecked(address)))
+    Ok((channel.to_string(), Addr::unchecked(address)))
 }
 
 /// If the specified receiver is not explicit, validate that the receiver
 /// address is a valid address for the destination chain. This will prevent IBC
 /// transfers from failing after forwarding
-fn validate_bech32_receiver(deps: Deps, receiver: &str) -> Result<(String, Addr), ContractError> {
+fn validate_simplified_receiver(
+    deps: Deps,
+    receiver: &str,
+) -> Result<(String, Addr), ContractError> {
     let Ok((prefix, _, _)) = bech32::decode(receiver) else {
         return Err(ContractError::InvalidReceiver { receiver: receiver.to_string() })
     };
 
-    let registry = get_registry(deps)?;
-    let chain = registry.get_chain_for_bech32_prefix(&prefix)?;
-
-    Ok((chain, Addr::unchecked(receiver)))
-}
-
-fn validate_chain_receiver(deps: Deps, receiver: &str) -> Result<(String, Addr), ContractError> {
-    let Some((chain, addr)) = receiver.split('/').collect_tuple() else {
-        return Err(ContractError::InvalidReceiver { receiver: receiver.to_string() })
+    // Check if the prefix has been disabled
+    if DISABLED_PREFIXES.has(deps.storage, &prefix) {
+        return Err(ContractError::InvalidReceiver {
+            receiver: receiver.to_string(),
+        });
     };
 
-    // TODO: validate that the prefix of the receiver matches the chain
-    let _registry = get_registry(deps)?;
+    let channel =
+        CHANNEL_MAP
+            .load(deps.storage, &prefix)
+            .map_err(|_| ContractError::InvalidReceiver {
+                receiver: receiver.to_string(),
+            })?;
 
-    let Ok(_) = bech32::decode(addr) else {
-        return Err(ContractError::InvalidReceiver { receiver: receiver.to_string() })
-    };
-
-    Ok((chain.to_string(), Addr::unchecked(addr)))
+    Ok((channel, Addr::unchecked(receiver)))
 }
 
 /// The receiver can be specified explicitly (ibc:channel-n/osmo1...) or in a
@@ -89,20 +84,24 @@ fn validate_chain_receiver(deps: Deps, receiver: &str) -> Result<(String, Addr),
 /// appropriate channel for the addr
 pub fn validate_receiver(deps: Deps, receiver: &str) -> Result<(String, Addr), ContractError> {
     if receiver.starts_with("ibc:channel-") {
-        validate_explicit_receiver(deps, receiver)
-    } else if receiver.contains('/') {
-        validate_chain_receiver(deps, receiver)
+        validate_explicit_receiver(receiver)
     } else {
-        validate_bech32_receiver(deps, receiver)
+        validate_simplified_receiver(deps, receiver)
     }
 }
 
+fn stringify(json: &serde_cw_value::Value) -> Result<String, ContractError> {
+    serde_json_wasm::to_string(&json).map_err(|_| ContractError::CustomError {
+        msg: "invalid value".to_string(), // This shouldn't happen.
+    })
+}
+
 pub fn ensure_map(json: &serde_cw_value::Value) -> Result<(), ContractError> {
     match json {
         serde_cw_value::Value::Map(_) => Ok(()),
         _ => Err(ContractError::InvalidJson {
             error: format!("invalid json: expected an object"),
-            json: registry::utils::stringify(json)?,
+            json: stringify(json)?,
         }),
     }
 }
@@ -121,7 +120,7 @@ pub fn ensure_key_missing(
     {
         Err(ContractError::InvalidJson {
             error: format!("invalid json: {key} key not allowed"),
-            json: registry::utils::stringify(json_object)?,
+            json: stringify(json_object)?,
         })
     } else {
         Ok(())
@@ -140,7 +139,6 @@ mod tests {
         let config = Config {
             governor: Addr::unchecked("governor"),
             swap_contract: Addr::unchecked("governor"),
-            registry_contract: Addr::unchecked("registry"),
         };
         CONFIG.save(deps.as_mut().storage, &config).unwrap();
         let sender = Addr::unchecked("governor");
diff --git a/cosmwasm/contracts/crosschain-swaps/src/consts.rs b/cosmwasm/contracts/crosschain-swaps/src/consts.rs
index ba7ecfb57..b4938b11f 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/consts.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/consts.rs
@@ -7,5 +7,8 @@ pub enum MsgReplyID {
     Forward = 2,
 }
 
+// IBC timeout
+pub const PACKET_LIFETIME: u64 = 604_800u64; // One week in seconds
+
 // Callback key
 pub const CALLBACK_KEY: &str = "ibc_callback";
diff --git a/cosmwasm/contracts/crosschain-swaps/src/contract.rs b/cosmwasm/contracts/crosschain-swaps/src/contract.rs
index 8d89d36c1..dbefb1876 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/contract.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/contract.rs
@@ -8,7 +8,7 @@ use cw2::set_contract_version;
 use crate::consts::MsgReplyID;
 use crate::error::ContractError;
 use crate::msg::{ExecuteMsg, IBCLifecycleComplete, InstantiateMsg, MigrateMsg, QueryMsg, SudoMsg};
-use crate::state::{Config, CONFIG, RECOVERY_STATES};
+use crate::state::{Config, CHANNEL_MAP, CONFIG, RECOVERY_STATES};
 use crate::{execute, ibc_lifecycle};
 
 // version info for migration info
@@ -28,13 +28,14 @@ pub fn instantiate(
     // validate swaprouter contract and owner addresses and save to config
     let swap_contract = deps.api.addr_validate(&msg.swap_contract)?;
     let governor = deps.api.addr_validate(&msg.governor)?;
-    let registry_contract = deps.api.addr_validate(&msg.registry_contract)?;
     let state = Config {
         swap_contract,
         governor,
-        registry_contract,
     };
     CONFIG.save(deps.storage, &state)?;
+    for (prefix, channel) in msg.channels.into_iter() {
+        CHANNEL_MAP.save(deps.storage, &prefix, &channel)?;
+    }
 
     Ok(Response::new().add_attribute("method", "instantiate"))
 }
@@ -60,17 +61,28 @@ pub fn execute(
             slippage,
             next_memo,
             on_failed_delivery,
-            route,
-        } => execute::unwrap_or_swap_and_forward(
-            (deps, env, info),
-            output_denom,
-            slippage,
-            &receiver,
-            next_memo,
-            on_failed_delivery,
-            route,
-        ),
+        } => {
+            let swap_coin = cw_utils::one_coin(&info)?;
+            execute::swap_and_forward(
+                deps,
+                env.block.time,
+                env.contract.address,
+                swap_coin,
+                output_denom,
+                slippage,
+                &receiver,
+                next_memo,
+                on_failed_delivery,
+            )
+        }
         ExecuteMsg::Recover {} => execute::recover(deps, info.sender),
+        ExecuteMsg::SetChannel { prefix, channel } => {
+            execute::set_channel(deps, info.sender, prefix, channel)
+        }
+        ExecuteMsg::DisablePrefix { prefix } => execute::disable_prefix(deps, info.sender, prefix),
+        ExecuteMsg::ReEnablePrefix { prefix } => {
+            execute::re_enable_prefix(deps, info.sender, prefix)
+        }
         ExecuteMsg::TransferOwnership { new_governor } => {
             execute::transfer_ownership(deps, info.sender, new_governor)
         }
@@ -108,11 +120,11 @@ pub fn sudo(deps: DepsMut, _env: Env, msg: SudoMsg) -> Result<Response, Contract
 }
 
 #[cfg_attr(not(feature = "imported"), entry_point)]
-pub fn reply(deps: DepsMut, env: Env, reply: Reply) -> Result<Response, ContractError> {
+pub fn reply(deps: DepsMut, _env: Env, reply: Reply) -> Result<Response, ContractError> {
     deps.api
         .debug(&format!("executing crosschain reply: {reply:?}"));
     match MsgReplyID::from_repr(reply.id) {
-        Some(MsgReplyID::Swap) => execute::handle_swap_reply(deps, env, reply),
+        Some(MsgReplyID::Swap) => execute::handle_swap_reply(deps, reply),
         Some(MsgReplyID::Forward) => execute::handle_forward_reply(deps, reply),
         None => Err(ContractError::InvalidReplyID { id: reply.id }),
     }
diff --git a/cosmwasm/contracts/crosschain-swaps/src/error.rs b/cosmwasm/contracts/crosschain-swaps/src/error.rs
index eed6b3a3c..921677f50 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/error.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/error.rs
@@ -1,26 +1,11 @@
 use cosmwasm_std::StdError;
-use registry::RegistryError;
 use thiserror::Error;
 
-use crate::FailedDeliveryAction;
-
 #[derive(Error, Debug)]
 pub enum ContractError {
     #[error("{0}")]
     Std(#[from] StdError),
 
-    #[error("{0}")]
-    JsonSerialization(#[from] serde_json_wasm::ser::Error),
-
-    #[error("{0}")]
-    JsonDeserialization(#[from] serde_json_wasm::de::Error),
-
-    #[error("{0}")]
-    ValueSerialization(#[from] serde_cw_value::SerializerError),
-
-    #[error("{0}")]
-    RegistryError(#[from] RegistryError),
-
     #[error("{0}")]
     Payment(#[from] cw_utils::PaymentError),
 
@@ -33,11 +18,6 @@ pub enum ContractError {
     #[error("invalid receiver: {receiver}")]
     InvalidReceiver { receiver: String },
 
-    #[error("invalid recovery action: {recovery_action:?}")]
-    InvalidRecoveryAction {
-        recovery_action: FailedDeliveryAction,
-    },
-
     #[error("invalid json: {error}. Got: {json}")]
     InvalidJson { error: String, json: String },
 
diff --git a/cosmwasm/contracts/crosschain-swaps/src/execute.rs b/cosmwasm/contracts/crosschain-swaps/src/execute.rs
index 1058236c9..36614007c 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/execute.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/execute.rs
@@ -1,191 +1,56 @@
-use cosmwasm_std::{coins, to_binary, wasm_execute, BankMsg, Env, MessageInfo};
+use cosmwasm_std::{coins, to_binary, wasm_execute, BankMsg, Empty, Timestamp};
 use cosmwasm_std::{Addr, Coin, DepsMut, Response, SubMsg, SubMsgResponse, SubMsgResult};
-use osmosis_std::types::osmosis::poolmanager::v1beta1::SwapAmountInRoute;
-use registry::msg::{Callback, SerializableJson};
-use registry::RegistryError;
 use swaprouter::msg::ExecuteMsg as SwapRouterExecute;
 
-use crate::checks::{
-    check_is_contract_governor, ensure_key_missing, get_registry, validate_receiver,
-};
-use crate::consts::{MsgReplyID, CALLBACK_KEY};
-use crate::msg::{CrosschainSwapResponse, FailedDeliveryAction};
-use registry::proto::MsgTransferResponse;
+use crate::checks::{check_is_contract_governor, ensure_key_missing, validate_receiver};
+use crate::consts::{MsgReplyID, CALLBACK_KEY, PACKET_LIFETIME};
+use crate::ibc::{MsgTransfer, MsgTransferResponse};
+use crate::msg::{CrosschainSwapResponse, FailedDeliveryAction, SerializableJson};
 
+use crate::state::{self, Config, CHANNEL_MAP, DISABLED_PREFIXES};
 use crate::state::{
-    Config, ForwardMsgReplyState, ForwardTo, SwapMsgReplyState, CONFIG, FORWARD_REPLY_STATE,
+    ForwardMsgReplyState, ForwardTo, SwapMsgReplyState, CONFIG, FORWARD_REPLY_STATE,
     INFLIGHT_PACKETS, RECOVERY_STATES, SWAP_REPLY_STATE,
 };
 use crate::utils::{build_memo, parse_swaprouter_reply};
 use crate::ContractError;
-use crate::{state, ExecuteMsg};
-
-use std::fmt::Debug;
-
-// Helper to add consistent events on ibc message submission
-fn ibc_message_event<T: Debug>(context: &str, message: T) -> cosmwasm_std::Event {
-    cosmwasm_std::Event::new("ibc_message_added")
-        .add_attribute("context", context)
-        .add_attribute("ibc_message", format!("{message:?}"))
-}
-
-/// This function takes any token. If it's already something we can work with
-/// (either native to osmosis or native to a chain connected to osmosis via a
-/// valid channel), it will just proceed to swap and forward. If it's not, then
-/// it will send an IBC message to unwrap it first and provide a callback to
-/// ensure the right swap_and_forward gets called after the unwrap succeeds
-pub fn unwrap_or_swap_and_forward(
-    ctx: (DepsMut, Env, MessageInfo),
-    output_denom: String,
-    slippage: swaprouter::Slippage,
-    receiver: &str,
-    next_memo: Option<SerializableJson>,
-    failed_delivery_action: FailedDeliveryAction,
-    route: Option<Vec<SwapAmountInRoute>>,
-) -> Result<Response, ContractError> {
-    let (deps, env, info) = ctx;
-    let swap_coin = cw_utils::one_coin(&info)?;
-
-    deps.api
-        .debug(&format!("executing unwrap or swap and forward"));
-    let registry = get_registry(deps.as_ref())?;
-
-    // Check the path that the coin took to get to the current chain.
-    // Each element in the path is an IBC hop.
-    let path = registry.unwrap_denom_path(&swap_coin.denom)?;
-    if path.is_empty() {
-        return Err(RegistryError::InvalidDenomTracePath {
-            path: String::new(),
-            denom: swap_coin.denom,
-        }
-        .into());
-    }
-
-    let amount: u128 = swap_coin.amount.into();
-
-    // If the path is larger than 2, we need to unwrap this token first
-    if path.len() > 2 {
-        let registry = get_registry(deps.as_ref())?;
-        let ibc_transfer = registry.unwrap_coin_into(
-            swap_coin,
-            env.contract.address.to_string(),
-            None,
-            env.contract.address.to_string(),
-            env.block.time,
-            build_memo(None, env.contract.address.as_str())?,
-            Some(Callback {
-                contract: env.contract.address.clone(),
-                msg: serde_cw_value::to_value(&ExecuteMsg::OsmosisSwap {
-                    output_denom,
-                    receiver: receiver.to_string(),
-                    slippage,
-                    next_memo,
-                    on_failed_delivery: failed_delivery_action.clone(),
-                    route,
-                })?
-                .into(),
-            }),
-            false,
-        )?;
-
-        // Ensure the state is properly setup to handle a reply from the ibc_message
-        save_forward_reply_state(
-            deps,
-            ForwardMsgReplyState {
-                channel_id: ibc_transfer.source_channel.clone(),
-                to_address: env.contract.address.to_string(),
-                amount,
-                denom: String::new(),
-                on_failed_delivery: failed_delivery_action,
-                is_swap: false,
-            },
-        )?;
-
-        // Here we should add a response for the sender with the packet
-        // sequence, but that would require habdling the reply. This will be
-        // unncecessary once async acks lands, so we should wait for that
-        return Ok(Response::new()
-            //.set_data(data)
-            .add_attribute("action", "unwrap_before_swap")
-            .add_event(ibc_message_event(
-                "pre-swap unwinding ibc message created",
-                &ibc_transfer,
-            ))
-            .add_submessage(SubMsg::reply_on_success(
-                ibc_transfer,
-                MsgReplyID::Forward.repr(),
-            )));
-    }
 
-    // If the denom is either native or only one hop, we swap it directly
-    swap_and_forward(
-        (deps, env, info),
-        swap_coin,
-        output_denom,
-        slippage,
-        receiver,
-        next_memo,
-        failed_delivery_action,
-        route,
-    )
-}
-
-/// This function takes token "known to the chain", swaps it, and then forwards
-/// the result to the receiver.
+/// This is the main execute call of this contract.
 ///
+/// It's objective is to trigger a swap between the supplied pairs
 ///
 #[allow(clippy::too_many_arguments)]
 pub fn swap_and_forward(
-    ctx: (DepsMut, Env, MessageInfo),
+    deps: DepsMut,
+    block_time: Timestamp,
+    contract_addr: Addr,
     swap_coin: Coin,
     output_denom: String,
     slippage: swaprouter::Slippage,
     receiver: &str,
     next_memo: Option<SerializableJson>,
     failed_delivery_action: FailedDeliveryAction,
-    route: Option<Vec<SwapAmountInRoute>>,
 ) -> Result<Response, ContractError> {
-    let (deps, env, _) = ctx;
-
     deps.api.debug(&format!("executing swap and forward"));
     let config = CONFIG.load(deps.storage)?;
 
-    // Check that the received is valid and retrieve its channel
-    let (valid_chain, valid_receiver) = validate_receiver(deps.as_ref(), receiver)?;
-    // If there is a memo, check that it is valid (i.e. a valud json object that
-    // doesn't contain the key that we will insert later)
-    let memo = if let Some(memo) = &next_memo {
-        // Ensure the json is an object ({...}) and that it does not contain the CALLBACK_KEY
-        deps.api.debug(&format!("checking memo: {memo:?}"));
-        ensure_key_missing(memo.as_value(), CALLBACK_KEY)?;
-        serde_json_wasm::to_string(&memo)?
-    } else {
-        String::new()
-    };
-
-    // Validate that the swapped token can be unwrapped. If it can't, abort
-    // early to avoid swapping unnecessarily
-    let registry = get_registry(deps.as_ref())?;
-    registry.unwrap_coin_into(
-        Coin::new(1, output_denom.clone()),
-        valid_receiver.to_string(),
-        Some(&valid_chain),
-        env.contract.address.to_string(),
-        env.block.time,
-        memo,
-        None,
-        false,
-    )?;
-
     // Message to swap tokens in the underlying swaprouter contract
     let swap_msg = SwapRouterExecute::Swap {
         input_coin: swap_coin.clone(),
         output_denom,
         slippage,
-        route,
     };
     let msg = wasm_execute(config.swap_contract, &swap_msg, vec![swap_coin])?;
 
+    // Check that the received is valid and retrieve its channel
+    let (valid_channel, valid_receiver) = validate_receiver(deps.as_ref(), receiver)?;
+    // If there is a memo, check that it is valid (i.e. a valud json object that
+    // doesn't contain the key that we will insert later)
+    if let Some(memo) = &next_memo {
+        // Ensure the json is an object ({...}) and that it does not contain the CALLBACK_KEY
+        ensure_key_missing(memo.as_value(), CALLBACK_KEY)?;
+    }
+
     // Check that there isn't anything stored in SWAP_REPLY_STATES. If there is,
     // it means that the contract is already waiting for a reply and should not
     // override the stored state. This should only happen if a contract we call
@@ -202,10 +67,10 @@ pub fn swap_and_forward(
         deps.storage,
         &SwapMsgReplyState {
             swap_msg,
-            block_time: env.block.time,
-            contract_addr: env.contract.address,
+            block_time,
+            contract_addr,
             forward_to: ForwardTo {
-                chain: valid_chain,
+                channel: valid_channel,
                 receiver: valid_receiver,
                 next_memo,
                 on_failed_delivery: failed_delivery_action,
@@ -213,37 +78,15 @@ pub fn swap_and_forward(
         },
     )?;
 
-    Ok(Response::new()
-        .add_attribute("action", "swap_and_forward")
-        .add_submessage(SubMsg::reply_on_success(msg, MsgReplyID::Swap.repr())))
-}
-
-fn save_forward_reply_state(
-    deps: DepsMut,
-    forward_reply_state: ForwardMsgReplyState,
-) -> Result<(), ContractError> {
-    // Check that there isn't anything stored in FORWARD_REPLY_STATES. If there
-    // is, it means that the contract is already waiting for a reply and should
-    // not override the stored state. This should never happen here, but adding
-    // the check for safety. If this happens there is likely a malicious attempt
-    // modify the contract's state before it has replied.
-    if FORWARD_REPLY_STATE.may_load(deps.storage)?.is_some() {
-        return Err(ContractError::ContractLocked {
-            msg: "Already waiting for a reply".to_string(),
-        });
-    }
-    // Store the ibc send information and the user's failed delivery preference
-    // so that it can be handled by the response
-    FORWARD_REPLY_STATE.save(deps.storage, &forward_reply_state)?;
-    Ok(())
+    Ok(Response::new().add_submessage(SubMsg::reply_on_success(msg, MsgReplyID::Swap.repr())))
 }
 
 // The swap has succeeded and we need to generate the forward IBC transfer
 pub fn handle_swap_reply(
     deps: DepsMut,
-    env: Env,
     msg: cosmwasm_std::Reply,
 ) -> Result<Response, ContractError> {
+    deps.api.debug(&format!("handle_swap_reply"));
     let swap_msg_state = SWAP_REPLY_STATE.load(deps.storage)?;
     SWAP_REPLY_STATE.remove(deps.storage);
 
@@ -252,46 +95,58 @@ pub fn handle_swap_reply(
 
     // Build an IBC packet to forward the swap.
     let contract_addr = &swap_msg_state.contract_addr;
+    let ts = swap_msg_state.block_time.plus_seconds(PACKET_LIFETIME);
 
     // If the memo is provided we want to include it in the IBC message. If not,
     // we default to an empty object. The resulting memo will always include the
     // callback so this contract can track the IBC send
     let memo = build_memo(swap_msg_state.forward_to.next_memo, contract_addr.as_str())?;
 
-    let registry = get_registry(deps.as_ref())?;
-    let ibc_transfer = registry.unwrap_coin_into(
-        Coin::new(
-            swap_response.amount.into(),
-            swap_response.token_out_denom.clone(),
+    // Cosmwasm's  IBCMsg::Transfer  does not support memo.
+    // To build and send the packet properly, we need to send it using stargate messages.
+    // See https://github.com/CosmWasm/cosmwasm/issues/1477
+    let ibc_transfer = MsgTransfer {
+        source_port: "transfer".to_string(),
+        source_channel: swap_msg_state.forward_to.channel.clone(),
+        token: Some(
+            Coin::new(
+                swap_response.amount.into(),
+                swap_response.token_out_denom.clone(),
+            )
+            .into(),
         ),
-        swap_msg_state.forward_to.receiver.clone().to_string(),
-        Some(&swap_msg_state.forward_to.chain),
-        env.contract.address.to_string(),
-        env.block.time,
+        sender: contract_addr.to_string(),
+        receiver: swap_msg_state.forward_to.receiver.clone().into(),
+        timeout_height: None,
+        timeout_timestamp: Some(ts.nanos()),
         memo,
-        None,
-        false,
-    )?;
-    deps.api.debug(&format!("IBC transfer: {ibc_transfer:?}"));
+    };
 
     // Base response
     let response = Response::new()
-        .add_attribute("action", "handle_swap_reply")
-        .add_event(ibc_message_event(
-            "forward ibc message added",
-            &ibc_transfer,
-        ));
-
-    // Ensure the state is properly setup to handle a reply from the ibc_message
-    save_forward_reply_state(
-        deps,
-        ForwardMsgReplyState {
-            channel_id: ibc_transfer.source_channel.clone(),
+        .add_attribute("status", "ibc_message_created")
+        .add_attribute("ibc_message", format!("{:?}", ibc_transfer));
+
+    // Check that there isn't anything stored in FORWARD_REPLY_STATES. If there
+    // is, it means that the contract is already waiting for a reply and should
+    // not override the stored state. This should never happen here, but adding
+    // the check for safety. If this happens there is likely a malicious attempt
+    // modify the contract's state before it has replied.
+    if FORWARD_REPLY_STATE.may_load(deps.storage)?.is_some() {
+        return Err(ContractError::ContractLocked {
+            msg: "Already waiting for a reply".to_string(),
+        });
+    }
+    // Store the ibc send information and the user's failed delivery preference
+    // so that it can be handled by the response
+    FORWARD_REPLY_STATE.save(
+        deps.storage,
+        &ForwardMsgReplyState {
+            channel_id: swap_msg_state.forward_to.channel,
             to_address: swap_msg_state.forward_to.receiver.into(),
             amount: swap_response.amount.into(),
             denom: swap_response.token_out_denom,
             on_failed_delivery: swap_msg_state.forward_to.on_failed_delivery,
-            is_swap: true,
         },
     )?;
 
@@ -311,7 +166,6 @@ pub fn handle_forward_reply(
     deps: DepsMut,
     msg: cosmwasm_std::Reply,
 ) -> Result<Response, ContractError> {
-    deps.api.debug(&format!("handle_forward_reply"));
     // Parse the result from the underlying chain call (IBC send)
     let SubMsgResult::Ok(SubMsgResponse { data: Some(b), .. }) = msg.result else {
         return Err(ContractError::FailedIBCTransfer { msg: format!("failed reply: {:?}", msg.result) })
@@ -320,7 +174,7 @@ pub fn handle_forward_reply(
     // The response contains the packet sequence. This is needed to be able to
     // ensure that, if there is a delivery failure, the packet that failed is
     // the same one that we stored recovery information for
-    let transfer_response =
+    let response =
         MsgTransferResponse::decode(&b[..]).map_err(|_e| ContractError::FailedIBCTransfer {
             msg: format!("could not decode response: {b}"),
         })?;
@@ -331,7 +185,6 @@ pub fn handle_forward_reply(
         amount,
         denom,
         on_failed_delivery: failed_delivery_action,
-        is_swap,
     } = FORWARD_REPLY_STATE.load(deps.storage)?;
     FORWARD_REPLY_STATE.remove(deps.storage);
 
@@ -343,62 +196,81 @@ pub fn handle_forward_reply(
             let recovery = state::ibc::IBCTransfer {
                 recovery_addr,
                 channel_id: channel_id.clone(),
-                sequence: transfer_response.sequence,
+                sequence: response.sequence,
                 amount,
                 denom: denom.clone(),
                 status: state::ibc::PacketLifecycleStatus::Sent,
             };
 
             // Save as in-flight to be able to manipulate when the ack/timeout is received
-            INFLIGHT_PACKETS.save(
-                deps.storage,
-                (&channel_id, transfer_response.sequence),
-                &recovery,
-            )?;
+            INFLIGHT_PACKETS.save(deps.storage, (&channel_id, response.sequence), &recovery)?;
         }
     }
 
-    let response = Response::new()
-        .add_attribute("action", "handle_forward_reply")
-        .add_attribute("status", "ibc_message_successfully_submitted")
-        .add_attribute("channel", &channel_id)
-        .add_attribute("receiver", &to_address)
-        .add_attribute(
-            "packet_sequence",
-            format!("{:?}", transfer_response.sequence),
-        );
+    // The response data
+    let response_data =
+        CrosschainSwapResponse::new(amount, &denom, &channel_id, &to_address, response.sequence);
 
-    if !is_swap {
-        return Ok(response);
-    }
-
-    // Add the information about the swap
-    let response_data = CrosschainSwapResponse::new(
-        amount,
-        &denom,
-        &channel_id,
-        &to_address,
-        transfer_response.sequence,
-    );
-
-    Ok(response
+    Ok(Response::new()
         .set_data(to_binary(&response_data)?)
+        .add_attribute("status", "ibc_message_created")
         .add_attribute("amount", amount.to_string())
-        .add_attribute("denom", denom))
+        .add_attribute("denom", denom)
+        .add_attribute("channel", channel_id)
+        .add_attribute("receiver", to_address))
 }
 
 /// Transfers any tokens stored in RECOVERY_STATES[sender] to the sender.
 pub fn recover(deps: DepsMut, sender: Addr) -> Result<Response, ContractError> {
     let recoveries = RECOVERY_STATES.load(deps.storage, &sender)?;
-    // Remove the recoveries from the store. If the sends fail, the whole tx should be reverted.
-    RECOVERY_STATES.remove(deps.storage, &sender);
     let msgs = recoveries.into_iter().map(|r| BankMsg::Send {
-        to_address: r.recovery_addr.into_string(),
+        to_address: r.recovery_addr.into(),
         amount: coins(r.amount, r.denom),
     });
-    Ok(Response::new()
-        .add_attribute("action", "recover")
-        .add_messages(msgs))
+    Ok(Response::new().add_messages(msgs))
+}
+
+/// Set a prefix->channel map in the registry
+pub fn set_channel(
+    deps: DepsMut,
+    sender: Addr,
+    prefix: String,
+    channel: String,
+) -> Result<Response, ContractError> {
+    check_is_contract_governor(deps.as_ref(), sender)?;
+    if CHANNEL_MAP.has(deps.storage, &prefix) {
+        return Err(ContractError::PrefixAlreadyExists { prefix });
+    }
+    CHANNEL_MAP.save(deps.storage, &prefix, &channel)?;
+    Ok(Response::new().add_attribute("method", "set_channel"))
+}
+
+/// Disable a prefix
+pub fn disable_prefix(
+    deps: DepsMut,
+    sender: Addr,
+    prefix: String,
+) -> Result<Response, ContractError> {
+    check_is_contract_governor(deps.as_ref(), sender)?;
+    if !CHANNEL_MAP.has(deps.storage, &prefix) {
+        return Err(ContractError::PrefixDoesNotExist { prefix });
+    }
+    DISABLED_PREFIXES.save(deps.storage, &prefix, &Empty {})?;
+    Ok(Response::new().add_attribute("method", "disable_prefix"))
+}
+
+/// Re-enable a prefix
+pub fn re_enable_prefix(
+    deps: DepsMut,
+    sender: Addr,
+    prefix: String,
+) -> Result<Response, ContractError> {
+    check_is_contract_governor(deps.as_ref(), sender)?;
+    if !DISABLED_PREFIXES.has(deps.storage, &prefix) {
+        return Err(ContractError::PrefixNotDisabled { prefix });
+    }
+    DISABLED_PREFIXES.remove(deps.storage, &prefix);
+    Ok(Response::new().add_attribute("method", "re_enable_prefix"))
 }
 
 // Transfer ownership of this contract
@@ -439,7 +311,7 @@ pub fn set_swap_contract(
         },
     )?;
 
-    Ok(Response::new().add_attribute("action", "set_swaps_contract"))
+    Ok(Response::new().add_attribute("method", "set_swaps_contract"))
 }
 
 #[cfg(test)]
@@ -451,7 +323,9 @@ mod tests {
 
     static CREATOR_ADDRESS: &str = "creator";
     static SWAPCONTRACT_ADDRESS: &str = "swapcontract";
-    static REGISTRY_ADDRESS: &str = "registrycontract";
+
+    static RECEIVER_ADDRESS1: &str = "prefix12smx2wdlyttvyzvzg54y2vnqwq2qjatel8rck9";
+    static RECEIVER_ADDRESS2: &str = "other12smx2wdlyttvyzvzg54y2vnqwq2qjatere840z";
 
     // test helper
     #[allow(unused_assignments)]
@@ -459,7 +333,7 @@ mod tests {
         let msg = InstantiateMsg {
             governor: String::from(CREATOR_ADDRESS),
             swap_contract: String::from(SWAPCONTRACT_ADDRESS),
-            registry_contract: String::from(REGISTRY_ADDRESS),
+            channels: vec![("prefix".to_string(), "channel1".to_string())],
         };
         let info = mock_info(CREATOR_ADDRESS, &[]);
 
@@ -475,6 +349,10 @@ mod tests {
         let governor = initialize_contract(deps.as_mut());
         let config = CONFIG.load(&deps.storage).unwrap();
         assert_eq!(config.governor, governor);
+        assert_eq!(
+            CHANNEL_MAP.load(&deps.storage, "prefix").unwrap(),
+            "channel1"
+        );
     }
 
     #[test]
@@ -513,6 +391,92 @@ mod tests {
         assert_eq!(governor, config.governor);
     }
 
+    #[test]
+    fn modify_channel_registry() {
+        let mut deps = mock_dependencies();
+
+        let governor = initialize_contract(deps.as_mut());
+        let governor_info = mock_info(governor.as_str(), &vec![] as &Vec<Coin>);
+        validate_receiver(deps.as_ref(), RECEIVER_ADDRESS1).unwrap();
+
+        // and new channel
+        let msg = ExecuteMsg::SetChannel {
+            prefix: "other".to_string(),
+            channel: "channel2".to_string(),
+        };
+        contract::execute(deps.as_mut(), mock_env(), governor_info.clone(), msg).unwrap();
+
+        assert_eq!(
+            CHANNEL_MAP.load(&deps.storage, "prefix").unwrap(),
+            "channel1"
+        );
+        assert_eq!(
+            CHANNEL_MAP.load(&deps.storage, "other").unwrap(),
+            "channel2"
+        );
+        validate_receiver(deps.as_ref(), RECEIVER_ADDRESS1).unwrap();
+        validate_receiver(deps.as_ref(), RECEIVER_ADDRESS2).unwrap();
+
+        // Can't override an existing channel
+        let msg = ExecuteMsg::SetChannel {
+            prefix: "prefix".to_string(),
+            channel: "new_channel".to_string(),
+        };
+        contract::execute(deps.as_mut(), mock_env(), governor_info.clone(), msg).unwrap_err();
+
+        assert_eq!(
+            CHANNEL_MAP.load(&deps.storage, "prefix").unwrap(),
+            "channel1"
+        );
+
+        // remove channel
+        let msg = ExecuteMsg::DisablePrefix {
+            prefix: "prefix".to_string(),
+        };
+        contract::execute(deps.as_mut(), mock_env(), governor_info.clone(), msg).unwrap();
+
+        assert!(DISABLED_PREFIXES.load(&deps.storage, "prefix").is_ok());
+        // The prefix no longer validates
+        validate_receiver(deps.as_ref(), RECEIVER_ADDRESS1).unwrap_err();
+
+        // Re enable the prefix
+        let msg = ExecuteMsg::ReEnablePrefix {
+            prefix: "prefix".to_string(),
+        };
+        contract::execute(deps.as_mut(), mock_env(), governor_info.clone(), msg).unwrap();
+        assert!(DISABLED_PREFIXES.load(&deps.storage, "prefix").is_err());
+
+        // The prefix is allowed again
+        validate_receiver(deps.as_ref(), RECEIVER_ADDRESS1).unwrap();
+    }
+
+    #[test]
+    fn modify_channel_registry_unauthorized() {
+        let mut deps = mock_dependencies();
+        initialize_contract(deps.as_mut());
+
+        // A user other than the owner cannot modify the channel registry
+        let other_info = mock_info("other_sender", &vec![] as &Vec<Coin>);
+        let msg = ExecuteMsg::SetChannel {
+            prefix: "other".to_string(),
+            channel: "something_else".to_string(),
+        };
+        contract::execute(deps.as_mut(), mock_env(), other_info.clone(), msg).unwrap_err();
+        assert_eq!(
+            CHANNEL_MAP.load(&deps.storage, "prefix").unwrap(),
+            "channel1"
+        );
+
+        let msg = ExecuteMsg::DisablePrefix {
+            prefix: "prefix".to_string(),
+        };
+        contract::execute(deps.as_mut(), mock_env(), other_info, msg).unwrap_err();
+        assert_eq!(
+            CHANNEL_MAP.load(&deps.storage, "prefix").unwrap(),
+            "channel1"
+        );
+    }
+
     #[test]
     fn set_swap_contract() {
         let mut deps = mock_dependencies();
@@ -524,7 +488,7 @@ mod tests {
         let msg = ExecuteMsg::SetSwapContract {
             new_contract: "new_swap_contract".to_string(),
         };
-        contract::execute(deps.as_mut(), mock_env(), governor_info, msg).unwrap();
+        contract::execute(deps.as_mut(), mock_env(), governor_info.clone(), msg).unwrap();
 
         let config = CONFIG.load(&deps.storage).unwrap();
         assert_eq!(config.swap_contract, "new_swap_contract".to_string());
diff --git a/cosmwasm/contracts/crosschain-swaps/src/ibc_lifecycle.rs b/cosmwasm/contracts/crosschain-swaps/src/ibc_lifecycle.rs
index f80e71764..7ac33dcd6 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/ibc_lifecycle.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/ibc_lifecycle.rs
@@ -55,7 +55,7 @@ pub fn receive_ack(
     success: bool,
 ) -> Result<Response, ContractError> {
     // deps.api.debug(&format!(
-    //     "received ack for packet {source_channel:?} {sequence:?}: {ack:?}, {success:?}"
+    //     "received ack for packet {channel:?} {sequence:?}: {ack:?}, {success:?}"
     // ));
     let response = Response::new()
         .add_attribute("contract", "crosschain_swaps")
@@ -72,7 +72,7 @@ pub fn receive_ack(
 
     if success {
         // If the acc is successful, there is nothing else to do and the crosschain swap has been completed
-        return Ok(response.add_attribute("msg", "packet successfully delivered"));
+        return Ok(response.add_attribute("msg", "packet successfully delviered"));
     }
 
     // If the ack is a failure, we create a recovery for the original sender of the packet.
@@ -84,7 +84,7 @@ pub fn receive_ack(
 
     Ok(response
         .add_attribute("msg", "recovery stored")
-        .add_attribute("recovery_addr", recovery_addr))
+        .add_attribute("reecovery_addr", recovery_addr))
 }
 
 // This is very similar to the handling of acks, but it always creates a
diff --git a/cosmwasm/contracts/crosschain-swaps/src/lib.rs b/cosmwasm/contracts/crosschain-swaps/src/lib.rs
index 3db805673..09a2d8227 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/lib.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/lib.rs
@@ -5,6 +5,7 @@ pub mod consts;
 pub mod contract;
 mod error;
 mod execute;
+pub mod ibc;
 mod ibc_lifecycle;
 pub mod msg;
 pub mod state;
diff --git a/cosmwasm/contracts/crosschain-swaps/src/msg.rs b/cosmwasm/contracts/crosschain-swaps/src/msg.rs
index e678fef62..d1f3c8cb3 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/msg.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/msg.rs
@@ -1,20 +1,21 @@
 use cosmwasm_schema::{cw_serde, QueryResponses};
 use cosmwasm_std::{Addr, Uint128};
-use osmosis_std::types::osmosis::poolmanager::v1beta1::SwapAmountInRoute;
-use registry::msg::SerializableJson;
+use schemars::JsonSchema;
 use swaprouter::msg::Slippage;
 
 /// Message type for `instantiate` entry_point
 #[cw_serde]
 pub struct InstantiateMsg {
-    /// The address that will be allowed to manage which swap_contract to use
+    /// The address that will be allowed to manage the channel registry
     pub governor: String,
 
     /// This should be an instance of the Osmosis swaprouter contract
     pub swap_contract: String,
 
-    /// This should be an instance of the Osmosis registry contract
-    pub registry_contract: String,
+    /// These are the channels that will be accepted by the contract. This is
+    /// needed to avoid sending packets to addresses not supported by the
+    /// receiving chain. The channels are specified as (bech32_prefix, channel_id)
+    pub channels: Vec<(String, String)>,
 }
 
 /// An enum specifying what resolution the user expects in the case of a bad IBC
@@ -25,18 +26,36 @@ pub enum FailedDeliveryAction {
     /// An osmosis addres used to recover any tokens that get stuck in the
     /// contract due to IBC failures
     LocalRecoveryAddr(Addr),
-    //
     // Here we could potentially add new actions in the future
     // example: SendBackToSender, SwapBackAndReturn, etc
-    //
-    // If a failure occures, any tokens belonging (either before or after a
-    // swap) to the user will be sent to `SendTo.address` on `SendTo.chain`.
-    // If that send fails, the tokens will be recoverable by `SendTo.emergency_recover_addr`
-    // SendTo {
-    //     chain: String,
-    //     address: String,
-    //     emergency_recovery_addr: String,
-    // },
+}
+
+// Value does not implement JsonSchema, so we wrap it here. This can be removed
+// if https://github.com/CosmWasm/serde-cw-value/pull/3 gets merged
+#[derive(
+    ::cosmwasm_schema::serde::Serialize,
+    ::cosmwasm_schema::serde::Deserialize,
+    ::std::clone::Clone,
+    ::std::fmt::Debug,
+    PartialEq,
+    Eq,
+)]
+pub struct SerializableJson(pub serde_cw_value::Value);
+
+impl JsonSchema for SerializableJson {
+    fn schema_name() -> String {
+        "JSON".to_string()
+    }
+
+    fn json_schema(_gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
+        schemars::schema::Schema::from(true)
+    }
+}
+
+impl SerializableJson {
+    pub fn as_value(&self) -> &serde_cw_value::Value {
+        &self.0
+    }
 }
 
 /// message type for `execute` entry_point
@@ -58,8 +77,6 @@ pub enum ExecuteMsg {
         /// "recovery address" that can clain the funds on osmosis after a
         /// confirmed failure.
         on_failed_delivery: FailedDeliveryAction,
-        /// Users can optionally specify which route to use for the swap
-        route: Option<Vec<SwapAmountInRoute>>,
     },
     /// Executing a recover will transfer any recoverable tokens that the sender
     /// has in this contract to its account.
@@ -73,6 +90,16 @@ pub enum ExecuteMsg {
     Recover {},
 
     // Contract Management
+    SetChannel {
+        prefix: String,
+        channel: String,
+    },
+    DisablePrefix {
+        prefix: String,
+    },
+    ReEnablePrefix {
+        prefix: String,
+    },
     TransferOwnership {
         new_governor: String,
     },
diff --git a/cosmwasm/contracts/crosschain-swaps/src/state.rs b/cosmwasm/contracts/crosschain-swaps/src/state.rs
index cacb0ed6e..16bfb2033 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/state.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/state.rs
@@ -1,21 +1,19 @@
 use cosmwasm_schema::cw_serde;
-use cosmwasm_std::{Addr, Timestamp};
+use cosmwasm_std::{Addr, Empty, Timestamp};
 use cw_storage_plus::{Item, Map};
-use registry::msg::SerializableJson;
 use swaprouter::msg::ExecuteMsg as SwapRouterExecute;
 
-use crate::msg::FailedDeliveryAction;
+use crate::msg::{FailedDeliveryAction, SerializableJson};
 
 #[cw_serde]
 pub struct Config {
     pub governor: Addr,
     pub swap_contract: Addr,
-    pub registry_contract: Addr,
 }
 
 #[cw_serde]
 pub struct ForwardTo {
-    pub chain: String,
+    pub channel: String,
     pub receiver: Addr,
     pub next_memo: Option<SerializableJson>,
     pub on_failed_delivery: FailedDeliveryAction,
@@ -36,7 +34,6 @@ pub struct ForwardMsgReplyState {
     pub amount: u128,
     pub denom: String,
     pub on_failed_delivery: FailedDeliveryAction,
-    pub is_swap: bool,
 }
 
 pub mod ibc {
@@ -72,3 +69,7 @@ pub const INFLIGHT_PACKETS: Map<(&str, u64), ibc::IBCTransfer> = Map::new("infli
 
 /// Recovery. This tracks any recovery that an addr can execute.
 pub const RECOVERY_STATES: Map<&Addr, Vec<ibc::IBCTransfer>> = Map::new("recovery");
+
+/// A mapping of knwon IBC channels accepted by the contract. bech32_prefix => channel
+pub const CHANNEL_MAP: Map<&str, String> = Map::new("chain_map");
+pub const DISABLED_PREFIXES: Map<&str, Empty> = Map::new("disabled_prefixes");
diff --git a/cosmwasm/contracts/crosschain-swaps/src/utils.rs b/cosmwasm/contracts/crosschain-swaps/src/utils.rs
index 7390f9b74..49dad15e2 100644
--- a/cosmwasm/contracts/crosschain-swaps/src/utils.rs
+++ b/cosmwasm/contracts/crosschain-swaps/src/utils.rs
@@ -1,20 +1,14 @@
 use cosmwasm_std::{from_binary, Reply, SubMsgResponse, SubMsgResult};
-use registry::msg::SerializableJson;
 use swaprouter::msg::SwapResponse;
 
-use crate::{consts::CALLBACK_KEY, ContractError};
+use crate::{consts::CALLBACK_KEY, msg::SerializableJson, ContractError};
 
 /// Extract the relevant response from the swaprouter reply
 pub fn parse_swaprouter_reply(msg: Reply) -> Result<SwapResponse, ContractError> {
-    // If the swaprouter faiuled with a known error, return that
-    if let SubMsgResult::Err(e) = msg.result {
-        return Err(ContractError::FailedSwap { msg: e });
-    };
-
-    // If the swaprouter swap failed otherwise (no data), return an error
+    // If the swaprouter swap failed, return an error
     let SubMsgResult::Ok(SubMsgResponse { data: Some(b), .. }) = msg.result else {
         return Err(ContractError::FailedSwap {
-            msg: format!("No data in swaprouter reply"),
+            msg: format!("No data"),
         })
     };
 
@@ -54,7 +48,7 @@ pub fn build_memo(
     let mut memo_str =
         serde_json_wasm::to_string(&memo).map_err(|_e| ContractError::InvalidMemo {
             error: "could not serialize".to_string(),
-            memo: format!("{memo:?}"),
+            memo: format!("{:?}", memo),
         })?;
 
     // This is redundant, as the ibc_callback_key will always exist. We leave it
diff --git a/cosmwasm/contracts/crosschain-swaps/tests/crosschain_swap_test.rs b/cosmwasm/contracts/crosschain-swaps/tests/crosschain_swap_test.rs
index d197e63ab..d1c9360da 100644
--- a/cosmwasm/contracts/crosschain-swaps/tests/crosschain_swap_test.rs
+++ b/cosmwasm/contracts/crosschain-swaps/tests/crosschain_swap_test.rs
@@ -5,11 +5,11 @@ mod test_env;
 use std::str::FromStr;
 
 use cosmwasm_std::{Addr, Coin, Decimal};
-use osmosis_std::types::osmosis::poolmanager::v1beta1::SwapAmountInRoute;
-use osmosis_test_tube::osmosis_std::types::cosmos::bank::v1beta1::QueryAllBalancesRequest;
+use osmosis_std::types::osmosis::gamm::v1beta1::SwapAmountInRoute;
+use osmosis_testing::cosmrs::proto::cosmos::bank::v1beta1::QueryAllBalancesRequest;
 
 use crosschain_swaps::msg::{ExecuteMsg as CrossChainExecute, FailedDeliveryAction};
-use osmosis_test_tube::{Account, Bank, Module, Wasm};
+use osmosis_testing::{Account, Bank, Module, Wasm};
 use swaprouter::msg::{ExecuteMsg as SwapRouterExecute, Slippage};
 use test_env::*;
 
@@ -67,7 +67,6 @@ fn crosschain_swap() {
         receiver: "osmo1l4u56l7cvx8n0n6c7w650k02vz67qudjlcut89".to_string(),
         on_failed_delivery: FailedDeliveryAction::DoNothing,
         next_memo: None,
-        route: None,
     };
     let funds: &[Coin] = &[Coin::new(10000, "uosmo")];
     println!("{}", serde_json_wasm::to_string(&msg).unwrap());
@@ -98,7 +97,7 @@ fn crosschain_swap() {
 }
 
 fn get_amount(
-    balances: &Vec<osmosis_test_tube::osmosis_std::types::cosmos::base::v1beta1::Coin>,
+    balances: &Vec<osmosis_testing::cosmrs::proto::cosmos::base::v1beta1::Coin>,
     denom: &str,
 ) -> u128 {
     balances
diff --git a/cosmwasm/contracts/crosschain-swaps/tests/test_env.rs b/cosmwasm/contracts/crosschain-swaps/tests/test_env.rs
index 46c916f8e..0784d5736 100644
--- a/cosmwasm/contracts/crosschain-swaps/tests/test_env.rs
+++ b/cosmwasm/contracts/crosschain-swaps/tests/test_env.rs
@@ -1,10 +1,9 @@
 use std::path::PathBuf;
 
 use cosmwasm_std::Coin;
-use crosschain_registry::msg::InstantiateMsg as RegistryInstantiate;
 use crosschain_swaps::msg::InstantiateMsg as CrosschainInstantiate;
-use osmosis_test_tube::{Account, OsmosisTestApp, SigningAccount};
-use osmosis_test_tube::{Gamm, Module, Wasm};
+use osmosis_testing::{Account, OsmosisTestApp, SigningAccount};
+use osmosis_testing::{Gamm, Module, Wasm};
 use serde::Serialize;
 use swaprouter::msg::InstantiateMsg as SwapRouterInstantiate;
 
@@ -65,16 +64,6 @@ impl TestEnv {
             },
         );
 
-        // Deploy the registry
-        let (_, registry_address) = deploy_contract(
-            &wasm,
-            &owner,
-            get_registry_wasm(),
-            &RegistryInstantiate {
-                owner: owner.address(),
-            },
-        );
-
         println!("Deploying the crosschain swaps contract");
         let (_, crosschain_address) = deploy_contract(
             &wasm,
@@ -82,8 +71,8 @@ impl TestEnv {
             get_crosschain_swaps_wasm(),
             &CrosschainInstantiate {
                 swap_contract: swaprouter_address.clone(),
+                channels: vec![("osmo".to_string(), "channel-0".to_string())],
                 governor: owner.address(),
-                registry_contract: registry_address,
             },
         );
 
@@ -147,16 +136,3 @@ fn get_crosschain_swaps_wasm() -> Vec<u8> {
     println!("reading crosschain swaps wasm: {wasm_path:?}");
     std::fs::read(wasm_path).unwrap()
 }
-
-fn get_registry_wasm() -> Vec<u8> {
-    let wasm_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
-        .join("..")
-        .join("..")
-        .join("..")
-        .join("tests")
-        .join("ibc-hooks")
-        .join("bytecode")
-        .join("crosschain_registry.wasm");
-    println!("reading crosschain registry wasm: {wasm_path:?}");
-    std::fs::read(wasm_path).unwrap()
-}
diff --git a/cosmwasm/contracts/outpost/Cargo.toml b/cosmwasm/contracts/outpost/Cargo.toml
index 190ad2b2e..c8e669b31 100644
--- a/cosmwasm/contracts/outpost/Cargo.toml
+++ b/cosmwasm/contracts/outpost/Cargo.toml
@@ -44,17 +44,20 @@ path = "build-schema/schema.rs"
 [dependencies]
 cosmwasm-schema =  { workspace = true }
 cosmwasm-std =  { workspace = true }
+cosmwasm-storage = { workspace = true }
 cw-storage-plus = { workspace = true }
 cw2 = { workspace = true }
+schemars = { workspace = true }
+serde = { workspace = true }
 thiserror = { workspace = true }
+osmosis-std = { workspace = true }
 serde-json-wasm = { workspace = true }
+serde-cw-value = { workspace = true }
 bech32 = { workspace = true }
 cw-utils = { workspace = true }
-osmosis-std = { workspace = true }
 
 swaprouter = { path = "../swaprouter", features = ["imported"]}
 crosschain-swaps = { path = "../crosschain-swaps", features = ["imported"]}
-registry = { path = "../../packages/registry"}
 
 [dev-dependencies]
 cw-multi-test = { workspace = true }
diff --git a/cosmwasm/contracts/outpost/src/error.rs b/cosmwasm/contracts/outpost/src/error.rs
index 6c1c0f2e1..ce8e3ce8b 100644
--- a/cosmwasm/contracts/outpost/src/error.rs
+++ b/cosmwasm/contracts/outpost/src/error.rs
@@ -1,5 +1,4 @@
 use cosmwasm_std::{Coin, StdError};
-use registry::RegistryError;
 use thiserror::Error;
 
 #[derive(Error, Debug)]
@@ -7,15 +6,9 @@ pub enum ContractError {
     #[error("{0}")]
     Std(#[from] StdError),
 
-    #[error("{0}")]
-    RegistryError(#[from] RegistryError),
-
     #[error("{0}")]
     Payment(#[from] cw_utils::PaymentError),
 
-    #[error("{0}")]
-    CrosschainSwaps(#[from] crosschain_swaps::ContractError),
-
     #[error("Unauthorized")]
     Unauthorized {},
 
@@ -28,7 +21,7 @@ pub enum ContractError {
     #[error("SwapAmountTooHigh: got {received}, max allowed: {max}")]
     SwapAmountTooHigh { received: u128, max: u128 },
 
-    #[error("Invalid Crosschain Swaps Contract: {contract}")]
+    #[error("Invalid Crosschain Swpas Contract: {contract}")]
     InvalidCrosschainSwapsContract { contract: String },
 
     #[error("Custom Error val: {val:?}")]
diff --git a/cosmwasm/contracts/outpost/src/execute.rs b/cosmwasm/contracts/outpost/src/execute.rs
index 91e1aaf40..db5e38723 100644
--- a/cosmwasm/contracts/outpost/src/execute.rs
+++ b/cosmwasm/contracts/outpost/src/execute.rs
@@ -1,10 +1,9 @@
 use crate::{
-    msg::{ExecuteMsg, Wasm, WasmHookExecute},
+    msg::{Callback, ExecuteMsg, Wasm, WasmHookExecute},
     state::CONFIG,
     ContractError,
 };
 use cosmwasm_std::{Addr, Coin, DepsMut, Response, Timestamp};
-use registry::msg::{Callback, SerializableJson};
 
 // IBC timeout
 pub const PACKET_LIFETIME: u64 = 604_800u64; // One week in seconds
@@ -12,7 +11,7 @@ pub const PACKET_LIFETIME: u64 = 604_800u64; // One week in seconds
 //#[cfg(feature = "callbacks")]
 fn build_callback_memo(
     callback: Option<Callback>,
-) -> Result<Option<SerializableJson>, ContractError> {
+) -> Result<Option<crosschain_swaps::msg::SerializableJson>, ContractError> {
     match callback {
         Some(callback) => Ok(Some(callback.to_json()?)),
         None => Ok(None),
@@ -33,7 +32,6 @@ pub fn execute_swap(
         on_failed_delivery,
         #[cfg(feature = "callbacks")]
         callback,
-        route,
     } = user_msg;
     let config = CONFIG.load(deps.storage)?;
 
@@ -53,7 +51,6 @@ pub fn execute_swap(
         slippage,
         next_memo,
         on_failed_delivery,
-        route,
     };
 
     let msg = WasmHookExecute {
@@ -66,7 +63,7 @@ pub fn execute_swap(
         error: e.to_string(),
     })?;
 
-    let ibc_transfer_msg = registry::proto::MsgTransfer {
+    let ibc_transfer_msg = crosschain_swaps::ibc::MsgTransfer {
         source_port: "transfer".to_string(),
         source_channel: "channel-0".to_string(),
         token: Some(Coin::new(coin.amount.into(), coin.denom).into()),
diff --git a/cosmwasm/contracts/outpost/src/msg.rs b/cosmwasm/contracts/outpost/src/msg.rs
index 268f71d0a..ff8777032 100644
--- a/cosmwasm/contracts/outpost/src/msg.rs
+++ b/cosmwasm/contracts/outpost/src/msg.rs
@@ -1,5 +1,7 @@
 use cosmwasm_schema::{cw_serde, QueryResponses};
-use osmosis_std::types::osmosis::poolmanager::v1beta1::SwapAmountInRoute;
+use cosmwasm_std::Addr;
+
+use crate::ContractError;
 
 /// Message type for `instantiate` entry_point
 #[cw_serde]
@@ -20,6 +22,31 @@ pub struct Wasm {
     pub msg: crosschain_swaps::ExecuteMsg,
 }
 
+/// Information about which contract to call when the crosschain swap finishes
+#[cw_serde]
+pub struct Callback {
+    pub contract: Addr,
+    pub msg: crosschain_swaps::msg::SerializableJson,
+}
+
+impl Callback {
+    pub fn try_string(&self) -> Result<String, ContractError> {
+        serde_json_wasm::to_string(self).map_err(|e| ContractError::InvalidJson {
+            error: e.to_string(),
+        })
+    }
+
+    pub fn to_json(&self) -> Result<crosschain_swaps::msg::SerializableJson, ContractError> {
+        Ok(crosschain_swaps::msg::SerializableJson(
+            serde_json_wasm::from_str(&self.try_string()?).map_err(|e| {
+                ContractError::InvalidJson {
+                    error: e.to_string(),
+                }
+            })?,
+        ))
+    }
+}
+
 /// Message type for `execute` entry_point
 #[cw_serde]
 pub enum ExecuteMsg {
@@ -40,10 +67,7 @@ pub enum ExecuteMsg {
         /// Execute a contract when the crosschain swaps has finished.
         /// This is only avaibale on chains that support wasm hooks
         #[cfg(feature = "callbacks")]
-        callback: Option<crosschain_swaps::msg::Callback>,
-
-        // Optional Route specification
-        route: Option<Vec<SwapAmountInRoute>>,
+        callback: Option<Callback>,
     },
 }
 
diff --git a/cosmwasm/contracts/swaprouter/Cargo.toml b/cosmwasm/contracts/swaprouter/Cargo.toml
index 6d6f017b4..cc25f873b 100644
--- a/cosmwasm/contracts/swaprouter/Cargo.toml
+++ b/cosmwasm/contracts/swaprouter/Cargo.toml
@@ -47,6 +47,7 @@ path = "build-schema/schema.rs"
 [dependencies]
 cosmwasm-schema =  { workspace = true }
 cosmwasm-std =  { workspace = true }
+cosmwasm-storage = { workspace = true }
 cw-storage-plus = { workspace = true }
 cw2 = { workspace = true }
 schemars = { workspace = true }
@@ -55,4 +56,4 @@ serde = { workspace = true }
 thiserror = { workspace = true }
 
 [dev-dependencies]
-osmosis-test-tube = { workspace = true }
+osmosis-testing = { workspace = true }
diff --git a/cosmwasm/contracts/swaprouter/src/contract.rs b/cosmwasm/contracts/swaprouter/src/contract.rs
index 09da4bbe0..7fd59ee34 100644
--- a/cosmwasm/contracts/swaprouter/src/contract.rs
+++ b/cosmwasm/contracts/swaprouter/src/contract.rs
@@ -54,8 +54,7 @@ pub fn execute(
             input_coin,
             output_denom,
             slippage,
-            route,
-        } => trade_with_slippage_limit(deps, env, info, input_coin, output_denom, slippage, route),
+        } => trade_with_slippage_limit(deps, env, info, input_coin, output_denom, slippage),
         ExecuteMsg::TransferOwnership { new_owner } => transfer_ownership(deps, info, new_owner),
     }
 }
diff --git a/cosmwasm/contracts/swaprouter/src/execute.rs b/cosmwasm/contracts/swaprouter/src/execute.rs
index 85d63ddd1..5086616a2 100644
--- a/cosmwasm/contracts/swaprouter/src/execute.rs
+++ b/cosmwasm/contracts/swaprouter/src/execute.rs
@@ -5,9 +5,7 @@ use cosmwasm_std::{
     coin, coins, has_coins, to_binary, BankMsg, Coin, DepsMut, Env, MessageInfo, Reply, Response,
     SubMsg, SubMsgResponse, SubMsgResult, Uint128,
 };
-use osmosis_std::types::osmosis::poolmanager::v1beta1::{
-    MsgSwapExactAmountInResponse, SwapAmountInRoute,
-};
+use osmosis_std::types::osmosis::gamm::v1beta1::{MsgSwapExactAmountInResponse, SwapAmountInRoute};
 
 use crate::contract::SWAP_REPLY_ID;
 use crate::error::ContractError;
@@ -63,7 +61,6 @@ pub fn trade_with_slippage_limit(
     input_token: Coin,
     output_denom: String,
     slippage: Slippage,
-    route: Option<Vec<SwapAmountInRoute>>,
 ) -> Result<Response, ContractError> {
     if !has_coins(&info.funds, &input_token) {
         return Err(ContractError::InsufficientFunds {});
@@ -80,7 +77,6 @@ pub fn trade_with_slippage_limit(
             env.block.time,
             window_seconds,
             slippage_percentage,
-            route.clone(),
         )?,
         Slippage::MinOutputAmount(minimum_output_amount) => {
             coin(minimum_output_amount.u128(), output_denom)
@@ -93,7 +89,6 @@ pub fn trade_with_slippage_limit(
         env.contract.address,
         input_token,
         min_output_token,
-        route,
     )?;
 
     // save intermediate state for reply
diff --git a/cosmwasm/contracts/swaprouter/src/helpers.rs b/cosmwasm/contracts/swaprouter/src/helpers.rs
index 00a97704e..691c1a5cb 100644
--- a/cosmwasm/contracts/swaprouter/src/helpers.rs
+++ b/cosmwasm/contracts/swaprouter/src/helpers.rs
@@ -2,8 +2,8 @@ use std::ops::{Div, Mul};
 
 use cosmwasm_std::{Addr, Coin, Decimal, Deps, Timestamp, Uint128};
 use osmosis_std::shim::Timestamp as OsmosisTimestamp;
-use osmosis_std::types::osmosis::poolmanager::v1beta1::{
-    MsgSwapExactAmountIn, SwapAmountInRoute, TotalPoolLiquidityRequest,
+use osmosis_std::types::osmosis::gamm::v1beta1::{
+    MsgSwapExactAmountIn, QueryTotalPoolLiquidityRequest, SwapAmountInRoute,
 };
 use osmosis_std::types::osmosis::twap::v1beta1::TwapQuerier;
 
@@ -33,15 +33,12 @@ pub fn validate_pool_route(
 
     // make sure that this route actually works
     for route_part in &pool_route {
-        let liquidity = TotalPoolLiquidityRequest {
+        let liquidity = QueryTotalPoolLiquidityRequest {
             pool_id: route_part.pool_id,
         }
         .query(&deps.querier)
-        .map_err(|e| {
-            deps.api.debug(&format!("{:?}", e));
-            ContractError::QueryError {
-                val: format!("Couldn't query liquidity for pool {}", route_part.pool_id),
-            }
+        .map_err(|_e| ContractError::QueryError {
+            val: format!("Couldn't query liquidity for pool {}", route_part.pool_id),
         })?
         .liquidity;
 
@@ -61,7 +58,7 @@ pub fn validate_pool_route(
             return Result::Err(ContractError::InvalidPoolRoute {
                 reason: format!(
                     "denom {} is not in pool id {}",
-                    route_part.token_out_denom, route_part.pool_id
+                    current_denom, route_part.pool_id
                 ),
             });
         }
@@ -84,15 +81,9 @@ pub fn generate_swap_msg(
     sender: Addr,
     input_token: Coin,
     min_output_token: Coin,
-    route: Option<Vec<SwapAmountInRoute>>,
 ) -> Result<MsgSwapExactAmountIn, ContractError> {
-    let route = match route {
-        Some(route) => route,
-        None => {
-            // get trade route
-            ROUTING_TABLE.load(deps.storage, (&input_token.denom, &min_output_token.denom))?
-        }
-    };
+    // get trade route
+    let route = ROUTING_TABLE.load(deps.storage, (&input_token.denom, &min_output_token.denom))?;
     Ok(MsgSwapExactAmountIn {
         sender: sender.into_string(),
         routes: route,
@@ -108,22 +99,14 @@ pub fn calculate_min_output_from_twap(
     now: Timestamp,
     window: Option<u64>,
     percentage_impact: Decimal,
-    route: Option<Vec<SwapAmountInRoute>>,
 ) -> Result<Coin, ContractError> {
     // get trade route
-    let route = match route {
-        Some(route) => route,
-        None => {
-            // get trade route
-            ROUTING_TABLE
-                .load(deps.storage, (&input_token.denom, &output_denom))
-                .unwrap_or_default()
-        }
-    };
-
+    let route = ROUTING_TABLE
+        .load(deps.storage, (&input_token.denom, &output_denom))
+        .unwrap_or_default();
     if route.is_empty() {
         return Err(ContractError::InvalidPoolRoute {
-            reason: format!("No route found for {} -> {output_denom}", input_token.denom),
+            reason: format!("No route foung for {} -> {output_denom}", input_token.denom),
         });
     }
 
diff --git a/cosmwasm/contracts/swaprouter/src/msg.rs b/cosmwasm/contracts/swaprouter/src/msg.rs
index 7767f9eba..c420cc474 100644
--- a/cosmwasm/contracts/swaprouter/src/msg.rs
+++ b/cosmwasm/contracts/swaprouter/src/msg.rs
@@ -1,6 +1,6 @@
 use cosmwasm_schema::{cw_serde, QueryResponses};
 use cosmwasm_std::{Coin, Decimal, Uint128};
-use osmosis_std::types::osmosis::poolmanager::v1beta1::SwapAmountInRoute;
+use osmosis_std::types::osmosis::gamm::v1beta1::SwapAmountInRoute;
 
 #[cw_serde]
 pub struct InstantiateMsg {
@@ -30,7 +30,6 @@ pub enum ExecuteMsg {
         input_coin: Coin,
         output_denom: String,
         slippage: Slippage,
-        route: Option<Vec<SwapAmountInRoute>>,
     },
 }
 
diff --git a/cosmwasm/contracts/swaprouter/src/state.rs b/cosmwasm/contracts/swaprouter/src/state.rs
index 1233a801b..f51d8cbae 100644
--- a/cosmwasm/contracts/swaprouter/src/state.rs
+++ b/cosmwasm/contracts/swaprouter/src/state.rs
@@ -1,4 +1,4 @@
-use osmosis_std::types::osmosis::poolmanager::v1beta1::{MsgSwapExactAmountIn, SwapAmountInRoute};
+use osmosis_std::types::osmosis::gamm::v1beta1::{MsgSwapExactAmountIn, SwapAmountInRoute};
 use schemars::JsonSchema;
 use serde::{Deserialize, Serialize};
 
diff --git a/cosmwasm/contracts/swaprouter/tests/set_route_test.rs b/cosmwasm/contracts/swaprouter/tests/set_route_test.rs
index 4f8f8d422..53ba82102 100644
--- a/cosmwasm/contracts/swaprouter/tests/set_route_test.rs
+++ b/cosmwasm/contracts/swaprouter/tests/set_route_test.rs
@@ -1,7 +1,7 @@
 mod test_env;
 use cosmwasm_std::Coin;
-use osmosis_std::types::osmosis::poolmanager::v1beta1::SwapAmountInRoute;
-use osmosis_test_tube::{Module, RunnerError, Wasm};
+use osmosis_std::types::osmosis::gamm::v1beta1::SwapAmountInRoute;
+use osmosis_testing::{Module, RunnerError, Wasm};
 use swaprouter::msg::{ExecuteMsg, GetRouteResponse, QueryMsg};
 use test_env::*;
 
@@ -96,7 +96,10 @@ test_set_route!(
 test_set_route!(
     pool_does_not_have_output_asset
     should failed_with
-    r#"Invalid Pool Route: "denom uatom is not in pool id 1": execute wasm contract failed"#,
+    r#"Invalid Pool Route: "denom uosmo is not in pool id 1": execute wasm contract failed"#,
+    // confusing error message from chain, should state that:
+    // > `denom uatom is not in pool id 1": execute wasm contract failed`
+    // instead.
 
     sender = Owner,
     msg = ExecuteMsg::SetRoute {
@@ -114,7 +117,10 @@ test_set_route!(
 test_set_route!(
     intermediary_pool_does_not_have_output_asset
     should failed_with
-    r#"Invalid Pool Route: "denom foocoin is not in pool id 1": execute wasm contract failed"#,
+    r#"Invalid Pool Route: "denom uosmo is not in pool id 1": execute wasm contract failed"#,
+    // confusing error message from chain, should state that:
+    // > `denom foocoin is not in pool id 1": execute wasm contract failed`
+    // instead.
 
     sender = Owner,
     msg = ExecuteMsg::SetRoute {
@@ -256,10 +262,12 @@ fn test_set_route_failed_case(sender: Sender, msg: ExecuteMsg, expected_error: &
 
     // assert on error message
     if let RunnerError::ExecuteError { msg } = &err {
-        let expected_err =
-            &format!("failed to execute message; message index: 0: {expected_error}");
+        let expected_err = &format!(
+            "failed to execute message; message index: 0: {}",
+            expected_error
+        );
         assert_eq!(msg, expected_err);
     } else {
-        panic!("unexpected error: {err:?}");
+        panic!("unexpected error: {:?}", err);
     }
 }
diff --git a/cosmwasm/contracts/swaprouter/tests/swap_test.rs b/cosmwasm/contracts/swaprouter/tests/swap_test.rs
index 7b8947719..82ce16d02 100644
--- a/cosmwasm/contracts/swaprouter/tests/swap_test.rs
+++ b/cosmwasm/contracts/swaprouter/tests/swap_test.rs
@@ -2,11 +2,10 @@ mod test_env;
 use std::str::FromStr;
 
 use cosmwasm_std::{Coin, Decimal};
-
-use osmosis_std::types::osmosis::poolmanager::v1beta1::SwapAmountInRoute;
-use osmosis_test_tube::osmosis_std::types::cosmos::bank::v1beta1::QueryAllBalancesRequest;
-use osmosis_test_tube::osmosis_std::types::cosmwasm::wasm::v1::MsgExecuteContractResponse;
-use osmosis_test_tube::{
+use osmosis_std::types::osmosis::gamm::v1beta1::SwapAmountInRoute;
+use osmosis_testing::cosmrs::proto::cosmos::bank::v1beta1::QueryAllBalancesRequest;
+use osmosis_testing::cosmrs::proto::cosmwasm::wasm::v1::MsgExecuteContractResponse;
+use osmosis_testing::{
     Account, Bank, Module, OsmosisTestApp, RunnerError, RunnerExecuteResult, SigningAccount, Wasm,
 };
 use swaprouter::msg::{ExecuteMsg, Slippage};
@@ -20,7 +19,6 @@ test_swap!(
         input_coin: Coin::new(1000, "uosmo"),
         output_denom: "uion".to_string(),
         slippage: Slippage::MinOutputAmount(1u128.into()),
-        route: None,
     },
     funds: [
         Coin::new(1000, "uosmo")
@@ -35,7 +33,6 @@ test_swap!(
         input_coin: Coin::new(1000, "uosmo"),
         output_denom: "uion".to_string(),
         slippage: Slippage::MinOutputAmount(1u128.into()),
-        route: None,
     },
     funds: [
         Coin::new(10, "uosmo")
@@ -50,7 +47,6 @@ test_swap!(
         input_coin: Coin::new(1000, "uosmo"),
         output_denom: "uion".to_string(),
         slippage: Slippage::MinOutputAmount(1u128.into()),
-        route: None,
     },
     funds: [
         Coin::new(10, "uion")
@@ -65,7 +61,6 @@ test_swap!(
         input_coin: Coin::new(1000, "uosmo"),
         output_denom: "uion".to_string(),
         slippage: Slippage::MinOutputAmount(1000000000000000000000000u128.into()),
-        route: None,
     },
     funds: [
         Coin::new(1000, "uosmo")
@@ -74,13 +69,12 @@ test_swap!(
 
 test_swap!(
     non_existant_route should failed_with
-    "alloc::vec::Vec<osmosis_std::types::osmosis::poolmanager::v1beta1::SwapAmountInRoute> not found: execute wasm contract failed",
+    "alloc::vec::Vec<osmosis_std::types::osmosis::gamm::v1beta1::SwapAmountInRoute> not found: execute wasm contract failed",
 
     msg = ExecuteMsg::Swap {
         input_coin: Coin::new(1000, "uion"),
         output_denom: "uosmo".to_string(),
         slippage: Slippage::MinOutputAmount(1000000000000000000000000u128.into()),
-        route: None,
     },
     funds: [
         Coin::new(1000, "uion")
@@ -94,7 +88,6 @@ test_swap!(
         input_coin: Coin::new(1000, "uosmo"),
         output_denom: "uion".to_string(),
         slippage: Slippage::Twap{ window_seconds: Some(1), slippage_percentage: Decimal::from_str("5").unwrap() },
-        route: None,
     },
     funds: [
         Coin::new(10000, "uosmo")
@@ -134,7 +127,10 @@ fn test_swap_failed_case(msg: ExecuteMsg, funds: &[Coin], expected_error: &str)
     assert_eq!(
         err,
         RunnerError::ExecuteError {
-            msg: format!("failed to execute message; message index: 0: {expected_error}")
+            msg: format!(
+                "failed to execute message; message index: 0: {}",
+                expected_error
+            )
         }
     );
 }
@@ -230,7 +226,7 @@ fn assert_input_decreased_and_output_increased(
 }
 
 fn get_amount(
-    balances: &Vec<osmosis_test_tube::osmosis_std::types::cosmos::base::v1beta1::Coin>,
+    balances: &Vec<osmosis_testing::cosmrs::proto::cosmos::base::v1beta1::Coin>,
     denom: &str,
 ) -> u128 {
     balances
diff --git a/cosmwasm/contracts/swaprouter/tests/test_env.rs b/cosmwasm/contracts/swaprouter/tests/test_env.rs
index 39027fb10..6f9b1c794 100644
--- a/cosmwasm/contracts/swaprouter/tests/test_env.rs
+++ b/cosmwasm/contracts/swaprouter/tests/test_env.rs
@@ -1,8 +1,8 @@
 use std::path::PathBuf;
 
 use cosmwasm_std::Coin;
-use osmosis_test_tube::{Account, OsmosisTestApp, SigningAccount};
-use osmosis_test_tube::{Gamm, Module, Wasm};
+use osmosis_testing::{Account, OsmosisTestApp, SigningAccount};
+use osmosis_testing::{Gamm, Module, Wasm};
 use swaprouter::msg::InstantiateMsg;
 
 pub struct TestEnv {
diff --git a/cosmwasm/packages/registry/Cargo.toml b/cosmwasm/packages/registry/Cargo.toml
deleted file mode 100644
index bf82b4042..000000000
--- a/cosmwasm/packages/registry/Cargo.toml
+++ /dev/null
@@ -1,22 +0,0 @@
-[package]
-name = "registry"
-version = "0.1.0"
-edition = "2021"
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-cosmwasm-schema =  { workspace = true }
-cosmwasm-std = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-bech32 = { workspace = true }
-serde-json-wasm = { workspace = true }
-serde-cw-value = { workspace = true }
-sha2 = "0.10.6"
-hex = "0.4.3"
-schemars = { workspace = true }
-osmosis-std = { version = "0.13.2" }
-osmosis-std-derive = "0.13.2"
-prost = {version = "0.11.2", default-features = false, features = ["prost-derive"]}
-itertools = {workspace = true}
diff --git a/cosmwasm/packages/registry/src/error.rs b/cosmwasm/packages/registry/src/error.rs
deleted file mode 100644
index c331030c2..000000000
--- a/cosmwasm/packages/registry/src/error.rs
+++ /dev/null
@@ -1,169 +0,0 @@
-use cosmwasm_std::StdError;
-use thiserror::Error;
-
-#[derive(Error, Debug, PartialEq)]
-pub enum RegistryError {
-    #[error("{0}")]
-    Std(#[from] StdError),
-
-    #[error("{0}")]
-    JsonSerialization(JsonSerError),
-
-    #[error("{0}")]
-    JsonDeserialization(#[from] serde_json_wasm::de::Error),
-
-    #[error("{0}")]
-    ValueSerialization(ValueSerError),
-
-    #[error("{0}")]
-    Bech32ErrorRaw(#[from] bech32::Error),
-
-    // Validation errors
-    #[error("Invalid channel id: {0}")]
-    InvalidChannelId(String),
-
-    #[error("error {action} {addr}")]
-    Bech32Error {
-        action: String,
-        addr: String,
-        #[source]
-        source: bech32::Error,
-    },
-
-    #[error("serialization error: {error}")]
-    SerialiaztionError { error: String },
-
-    #[error("registry improperly configured")]
-    ImproperlyConfigured {},
-
-    #[error("denom {denom:?} is not an IBC denom")]
-    InvalidIBCDenom { denom: String },
-
-    #[error("No denom trace found for: {denom:?}")]
-    NoDenomTrace { denom: String },
-
-    #[error("Invalid denom trace: {error}")]
-    InvalidDenomTrace { error: String },
-
-    #[error("Invalid path {path:?} for denom {denom:?}")]
-    InvalidDenomTracePath { path: String, denom: String },
-
-    #[error("Invalid transfer port {port:?}")]
-    InvalidTransferPort { port: String },
-
-    #[error("Invalid multihop length {length:?}. Must be >={min}")]
-    InvalidMultiHopLengthMin { length: usize, min: usize },
-
-    #[error("Invalid multihop length {length:?}. Must be <={max}")]
-    InvalidMultiHopLengthMax { length: usize, max: usize },
-
-    #[error(
-        "receiver prefix for {receiver} must match the bech32 prefix of the destination chain {chain}"
-    )]
-    InvalidReceiverPrefix { receiver: String, chain: String },
-
-    #[error("trying to transfer from chain {chain} to itself. This is not allowed.")]
-    InvalidHopSameChain { chain: String },
-
-    #[error("invalid json: {error}. Got: {json}")]
-    InvalidJson { error: String, json: String },
-
-    // Registry loading errors
-    #[error("contract alias does not exist: {alias:?}")]
-    AliasDoesNotExist { alias: String },
-
-    #[error("no authorized address found for source chain: {source_chain:?}")]
-    ChainAuthorizedAddressDoesNotExist { source_chain: String },
-
-    #[error("channel between chains not registered: {source_chain:?} -> {destination_chain:?}")]
-    ChainChannelLinkDoesNotExist {
-        source_chain: String,
-        destination_chain: String,
-    },
-
-    #[error("channel to chain link not registered: {channel_id:?} on {source_chain:?}")]
-    ChannelDoesNotExistOnChain {
-        channel_id: String,
-        source_chain: String,
-    },
-
-    #[error("native denom link does not exist: {native_denom:?}")]
-    NativeDenomLinkDoesNotExist { native_denom: String },
-
-    #[error("bech32 prefix does not exist for chain: {chain}")]
-    Bech32PrefixDoesNotExist { chain: String },
-
-    #[error("Chain {chain} does not support forwarding")]
-    ForwardingUnsopported { chain: String },
-}
-
-impl From<RegistryError> for StdError {
-    fn from(e: RegistryError) -> Self {
-        match e {
-            RegistryError::Std(e) => e,
-            _ => StdError::generic_err(e.to_string()),
-        }
-    }
-}
-
-// Everything bellow here is just boilerplate to make the error types compatible with PartialEq
-
-// Wrap unherited serialization errors so that we can derive PartialEq
-#[derive(Debug)]
-pub struct JsonSerError(pub serde_json_wasm::ser::Error);
-
-impl PartialEq for JsonSerError {
-    fn eq(&self, other: &Self) -> bool {
-        self.0.to_string() == other.0.to_string()
-    }
-}
-
-impl std::fmt::Display for JsonSerError {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.0)
-    }
-}
-
-impl Eq for JsonSerError {}
-
-impl From<serde_json_wasm::ser::Error> for JsonSerError {
-    fn from(e: serde_json_wasm::ser::Error) -> Self {
-        JsonSerError(e)
-    }
-}
-
-impl From<serde_json_wasm::ser::Error> for RegistryError {
-    fn from(e: serde_json_wasm::ser::Error) -> Self {
-        RegistryError::JsonSerialization(JsonSerError(e))
-    }
-}
-
-// Wrap unimplemented serialization errors so that we can derive PartialEq
-#[derive(Debug)]
-pub struct ValueSerError(pub serde_cw_value::SerializerError);
-
-impl PartialEq for ValueSerError {
-    fn eq(&self, other: &Self) -> bool {
-        self.0.to_string() == other.0.to_string()
-    }
-}
-
-impl std::fmt::Display for ValueSerError {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.0)
-    }
-}
-
-impl Eq for ValueSerError {}
-
-impl From<serde_cw_value::SerializerError> for ValueSerError {
-    fn from(e: serde_cw_value::SerializerError) -> Self {
-        ValueSerError(e)
-    }
-}
-
-impl From<serde_cw_value::SerializerError> for RegistryError {
-    fn from(e: serde_cw_value::SerializerError) -> Self {
-        RegistryError::ValueSerialization(ValueSerError(e))
-    }
-}
diff --git a/cosmwasm/packages/registry/src/lib.rs b/cosmwasm/packages/registry/src/lib.rs
deleted file mode 100644
index 0568bb6d0..000000000
--- a/cosmwasm/packages/registry/src/lib.rs
+++ /dev/null
@@ -1,11 +0,0 @@
-mod error;
-mod registry;
-
-pub use crate::registry::derive_wasmhooks_sender;
-pub use crate::registry::Registry;
-
-pub use error::RegistryError;
-
-pub mod msg;
-pub mod proto;
-pub mod utils;
diff --git a/cosmwasm/packages/registry/src/msg.rs b/cosmwasm/packages/registry/src/msg.rs
deleted file mode 100644
index 608af12fe..000000000
--- a/cosmwasm/packages/registry/src/msg.rs
+++ /dev/null
@@ -1,146 +0,0 @@
-use cosmwasm_schema::{cw_serde, QueryResponses};
-use cosmwasm_std::Addr;
-use schemars::JsonSchema;
-use serde_json_wasm::from_str;
-
-use crate::RegistryError;
-
-#[cw_serde]
-#[derive(QueryResponses)]
-pub enum QueryMsg {
-    #[returns(GetAddressFromAliasResponse)]
-    GetAddressFromAlias { contract_alias: String },
-
-    #[returns(GetChannelFromChainPairResponse)]
-    GetChannelFromChainPair {
-        source_chain: String,
-        destination_chain: String,
-    },
-
-    #[returns(GetDestinationChainFromSourceChainViaChannelResponse)]
-    GetDestinationChainFromSourceChainViaChannel {
-        on_chain: String,
-        via_channel: String,
-    },
-
-    #[returns(QueryGetBech32PrefixFromChainNameResponse)]
-    GetBech32PrefixFromChainName { chain_name: String },
-
-    #[returns(QueryGetChainNameFromBech32PrefixResponse)]
-    GetChainNameFromBech32Prefix { prefix: String },
-
-    #[returns(crate::proto::QueryDenomTraceResponse)]
-    GetDenomTrace { ibc_denom: String },
-
-    #[returns(bool)]
-    HasPacketForwarding { chain: String },
-
-    #[returns(QueryAliasForDenomPathResponse)]
-    GetAliasForDenomPath { denom_path: String },
-
-    #[returns(QueryDenomPathForAliasResponse)]
-    GetDenomPathForAlias { alias: String },
-}
-
-// Response for GetAddressFromAlias query
-#[cw_serde]
-pub struct GetAddressFromAliasResponse {
-    pub address: String,
-}
-
-// Response for GetChannelFromChainPair query
-#[cw_serde]
-pub struct GetChannelFromChainPairResponse {
-    pub channel_id: String,
-}
-
-// Response for GetDestinationChainFromSourceChainViaChannel query
-#[cw_serde]
-pub struct GetDestinationChainFromSourceChainViaChannelResponse {
-    pub destination_chain: String,
-}
-
-// Response for GetBech32PrefixFromChainName query
-#[cw_serde]
-pub struct QueryGetBech32PrefixFromChainNameResponse {
-    pub bech32_prefix: String,
-}
-
-// Response for GetChainNameFromBech32Prefix query
-#[cw_serde]
-pub struct QueryGetChainNameFromBech32PrefixResponse {
-    pub chain_name: String,
-}
-
-// Response for GetAliasForDenomPath query
-#[cw_serde]
-pub struct QueryAliasForDenomPathResponse {
-    pub alias: String,
-}
-
-// Response for GetDenomPathForAlias query
-#[cw_serde]
-pub struct QueryDenomPathForAliasResponse {
-    pub denom_path: String,
-}
-
-// Value does not implement JsonSchema, so we wrap it here. This can be removed
-// if https://github.com/CosmWasm/serde-cw-value/pull/3 gets merged
-#[derive(
-    ::cosmwasm_schema::serde::Serialize,
-    ::cosmwasm_schema::serde::Deserialize,
-    ::std::clone::Clone,
-    ::std::fmt::Debug,
-    PartialEq,
-    Eq,
-)]
-pub struct SerializableJson(pub serde_cw_value::Value);
-
-impl JsonSchema for SerializableJson {
-    fn schema_name() -> String {
-        "JSON".to_string()
-    }
-
-    fn json_schema(_gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        schemars::schema::Schema::from(true)
-    }
-}
-
-impl SerializableJson {
-    pub fn as_value(&self) -> &serde_cw_value::Value {
-        &self.0
-    }
-}
-
-impl From<serde_cw_value::Value> for SerializableJson {
-    fn from(value: serde_cw_value::Value) -> Self {
-        Self(value)
-    }
-}
-
-impl TryFrom<String> for SerializableJson {
-    type Error = RegistryError;
-
-    fn try_from(value: String) -> Result<Self, RegistryError> {
-        Ok(Self(from_str(&value)?))
-    }
-}
-
-/// Information about which contract to call when the crosschain swap finishes
-#[cw_serde]
-pub struct Callback {
-    pub contract: Addr,
-    pub msg: SerializableJson,
-}
-
-impl Callback {
-    pub fn try_string(&self) -> Result<String, RegistryError> {
-        serde_json_wasm::to_string(self).map_err(|e| e.into())
-    }
-
-    pub fn to_json(&self) -> Result<SerializableJson, RegistryError> {
-        Ok(SerializableJson(serde_json_wasm::from_str(
-            &self.try_string()?,
-        )?))
-    }
-}
diff --git a/cosmwasm/packages/registry/src/proto.rs b/cosmwasm/packages/registry/src/proto.rs
deleted file mode 100644
index 16ed2d61c..000000000
--- a/cosmwasm/packages/registry/src/proto.rs
+++ /dev/null
@@ -1,109 +0,0 @@
-use osmosis_std_derive::CosmwasmExt;
-
-#[derive(
-    Clone,
-    PartialEq,
-    Eq,
-    ::prost::Message,
-    serde::Serialize,
-    serde::Deserialize,
-    schemars::JsonSchema,
-)]
-pub struct IbcCounterpartyHeight {
-    #[prost(uint64, optional, tag = "1")]
-    revision_number: Option<u64>,
-    #[prost(uint64, optional, tag = "2")]
-    revision_height: Option<u64>,
-}
-
-// We need to define the transfer here as a stargate message because this is
-// not yet supported by cosmwasm-std. See https://github.com/CosmWasm/cosmwasm/issues/1477
-#[derive(
-    Clone,
-    PartialEq,
-    Eq,
-    ::prost::Message,
-    serde::Serialize,
-    serde::Deserialize,
-    schemars::JsonSchema,
-    CosmwasmExt,
-)]
-#[proto_message(type_url = "/ibc.applications.transfer.v1.MsgTransfer")]
-pub struct MsgTransfer {
-    #[prost(string, tag = "1")]
-    pub source_port: String,
-    #[prost(string, tag = "2")]
-    pub source_channel: String,
-    #[prost(message, optional, tag = "3")]
-    pub token: ::core::option::Option<osmosis_std::types::cosmos::base::v1beta1::Coin>,
-    #[prost(string, tag = "4")]
-    pub sender: String,
-    #[prost(string, tag = "5")]
-    pub receiver: String,
-    #[prost(message, optional, tag = "6")]
-    pub timeout_height: Option<IbcCounterpartyHeight>,
-    #[prost(uint64, optional, tag = "7")]
-    pub timeout_timestamp: ::core::option::Option<u64>,
-    #[prost(string, tag = "8")]
-    pub memo: String,
-}
-
-// We define the response as a prost message to be able to decode the protobuf data.
-#[derive(Clone, PartialEq, Eq, ::prost::Message)]
-pub struct MsgTransferResponse {
-    #[prost(uint64, tag = "1")]
-    pub sequence: u64,
-}
-
-// DenomTrace query message definition.
-#[derive(
-    Clone,
-    PartialEq,
-    Eq,
-    ::prost::Message,
-    serde::Serialize,
-    serde::Deserialize,
-    schemars::JsonSchema,
-    CosmwasmExt,
-)]
-#[proto_message(type_url = "/ibc.applications.transfer.v1.QueryDenomTraceRequest")]
-#[proto_query(
-    path = "/ibc.applications.transfer.v1.Query/DenomTrace",
-    response_type = QueryDenomTraceResponse
-)]
-pub struct QueryDenomTraceRequest {
-    #[prost(string, tag = "1")]
-    pub hash: ::prost::alloc::string::String,
-}
-
-#[derive(
-    Clone,
-    PartialEq,
-    Eq,
-    ::prost::Message,
-    serde::Serialize,
-    serde::Deserialize,
-    schemars::JsonSchema,
-    CosmwasmExt,
-)]
-#[proto_message(type_url = "/ibc.applications.transfer.v1.QueryDenomTraceResponse")]
-pub struct QueryDenomTraceResponse {
-    #[prost(message, optional, tag = "1")]
-    pub denom_trace: Option<DenomTrace>,
-}
-
-#[derive(
-    Clone,
-    PartialEq,
-    Eq,
-    ::prost::Message,
-    serde::Serialize,
-    serde::Deserialize,
-    schemars::JsonSchema,
-)]
-pub struct DenomTrace {
-    #[prost(string, tag = "1")]
-    pub path: ::prost::alloc::string::String,
-    #[prost(string, tag = "2")]
-    pub base_denom: ::prost::alloc::string::String,
-}
diff --git a/cosmwasm/packages/registry/src/registry.rs b/cosmwasm/packages/registry/src/registry.rs
deleted file mode 100644
index 8432c29a9..000000000
--- a/cosmwasm/packages/registry/src/registry.rs
+++ /dev/null
@@ -1,693 +0,0 @@
-use cosmwasm_schema::cw_serde;
-use cosmwasm_std::{Coin, Deps, Timestamp};
-use itertools::Itertools;
-use sha2::Digest;
-use sha2::Sha256;
-
-use crate::msg::Callback;
-use crate::proto;
-use crate::utils::merge_json;
-use crate::{error::RegistryError, msg::QueryMsg};
-use std::convert::AsRef;
-
-// takes a transfer message and returns ibc/<hash of denom>
-pub fn hash_denom_trace(unwrapped: &str) -> String {
-    let mut hasher = Sha256::new();
-    hasher.update(unwrapped.as_bytes());
-    let result = hasher.finalize();
-    let hash = hex::encode(result);
-    format!("ibc/{}", hash.to_uppercase())
-}
-
-// When a contract is called using ibc callbacks, the addres is a combination of
-// the channel and the original sender. This function lets us compute that.
-pub fn derive_wasmhooks_sender(
-    channel: &str,
-    original_sender: &str,
-    bech32_prefix: &str,
-) -> Result<String, RegistryError> {
-    let sender = format!("{channel}/{original_sender}");
-
-    let mut hasher0 = Sha256::new();
-    hasher0.update("ibc-wasm-hook-intermediary".as_bytes());
-    let th = hasher0.finalize();
-
-    let mut hasher = Sha256::new();
-    hasher.reset();
-    hasher.update(th.as_slice());
-    hasher.update(sender.as_bytes());
-
-    let result = hasher.finalize();
-
-    // The bech32 crate requires a Vec<u5> as input, so we need to convert the bytes.
-    let result_u5 = bech32::convert_bits(result.as_slice(), 8, 5, true)?;
-    // result_u5 contains the bytes as a u5 but in an u8 type, so we need to explicitly
-    // do the type conversion
-    let result_u5: Vec<bech32::u5> = result_u5
-        .iter()
-        .filter_map(|&x| bech32::u5::try_from_u8(x).ok())
-        .collect();
-
-    bech32::encode(bech32_prefix, result_u5, bech32::Variant::Bech32).map_err(|e| {
-        RegistryError::Bech32Error {
-            action: "encoding".into(),
-            addr: original_sender.into(),
-            source: e,
-        }
-    })
-}
-
-// IBC transfer port
-const TRANSFER_PORT: &str = "transfer";
-// IBC timeout
-pub const PACKET_LIFETIME: u64 = 604_800u64; // One week in seconds
-
-#[cw_serde]
-pub struct Chain(String);
-#[cw_serde]
-pub struct ChannelId(String);
-
-impl ChannelId {
-    pub fn new(channel_id: &str) -> Result<Self, RegistryError> {
-        if !ChannelId::validate(channel_id) {
-            return Err(RegistryError::InvalidChannelId(channel_id.to_string()));
-        }
-        Ok(Self(channel_id.to_string()))
-    }
-
-    pub fn validate(channel_id: &str) -> bool {
-        if !channel_id.starts_with("channel-") {
-            return false;
-        }
-        // Check that what comes after "channel-" is a valid int
-        let channel_num = &channel_id[8..];
-        if channel_num.parse::<u64>().is_err() {
-            return false;
-        }
-        true
-    }
-}
-
-impl AsRef<str> for ChannelId {
-    fn as_ref(&self) -> &str {
-        &self.0
-    }
-}
-
-impl AsRef<str> for Chain {
-    fn as_ref(&self) -> &str {
-        &self.0
-    }
-}
-
-enum CoinType {
-    Native,
-    Ibc,
-}
-
-impl CoinType {
-    fn is_native(&self) -> bool {
-        matches!(self, CoinType::Native)
-    }
-}
-
-#[cw_serde]
-pub struct ForwardingMemo {
-    pub receiver: String,
-    pub port: String,
-    pub channel: ChannelId,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    pub next: Option<Box<Memo>>,
-}
-
-#[cw_serde]
-pub struct Memo {
-    #[serde(skip_serializing_if = "Option::is_none")]
-    forward: Option<ForwardingMemo>,
-    #[serde(rename = "wasm")]
-    #[serde(skip_serializing_if = "Option::is_none")]
-    callback: Option<Callback>,
-}
-
-// We will assume here that chains use the standard ibc-go formats. This is ok
-// because we will be checking the channels in the registry and failing if they
-// are not valid. We also need to enforce that all ports are explicitly "transfer"
-#[cw_serde]
-pub struct MultiHopDenom {
-    pub local_denom: String,
-    pub on: Chain,
-    pub via: Option<ChannelId>, // This is optional because native tokens have no channel
-}
-
-// The name of the chain on which the contract using this lib is instantiated
-pub const CONTRACT_CHAIN: &str = "osmosis";
-
-pub struct Registry<'a> {
-    pub deps: Deps<'a>,
-    pub registry_contract: String,
-}
-
-impl<'a> Registry<'a> {
-    pub fn new(deps: Deps<'a>, registry_contract: String) -> Result<Self, RegistryError> {
-        deps.api.addr_validate(&registry_contract)?;
-        Ok(Self {
-            deps,
-            registry_contract,
-        })
-    }
-
-    pub fn default(deps: Deps<'a>) -> Self {
-        Self {
-            deps,
-            registry_contract: match option_env!("REGISTRY_CONTRACT") {
-                Some(registry_contract) => registry_contract.to_string(),
-                None => {
-                    panic!("REGISTRY_CONTRACT not set at compile time. Use Registry::new(contract_addr).")
-                }
-            },
-        }
-    }
-
-    fn debug(&self, msg: String) {
-        self.deps.api.debug(&msg);
-    }
-
-    /// Get a contract address by its alias
-    /// Example: get_contract("registries") -> "osmo1..."
-    pub fn get_contract(self, alias: String) -> Result<String, RegistryError> {
-        self.deps
-            .querier
-            .query_wasm_smart(
-                &self.registry_contract,
-                &QueryMsg::GetAddressFromAlias {
-                    contract_alias: alias.clone(),
-                },
-            )
-            .map_err(|_e| RegistryError::AliasDoesNotExist { alias })
-    }
-
-    /// Get a the name of the chain connected via channel `via_channel` on chain `on_chain`.
-    /// Example: get_connected_chain("osmosis", "channel-42") -> "juno"
-    pub fn get_connected_chain(
-        &self,
-        on_chain: &str,
-        via_channel: &str,
-    ) -> Result<String, RegistryError> {
-        self.deps
-            .querier
-            .query_wasm_smart(
-                &self.registry_contract,
-                &QueryMsg::GetDestinationChainFromSourceChainViaChannel {
-                    on_chain: on_chain.to_string(),
-                    via_channel: via_channel.to_string(),
-                },
-            )
-            .map_err(|_e| RegistryError::ChannelDoesNotExistOnChain {
-                channel_id: via_channel.to_string(),
-                source_chain: on_chain.to_string(),
-            })
-    }
-
-    /// Get the channel id for the channel connecting chain `on_chain` to chain `for_chain`.
-    /// Example: get_channel("osmosis", "juno") -> "channel-0"
-    /// Example: get_channel("juno", "osmosis") -> "channel-42"
-    pub fn get_channel(&self, for_chain: &str, on_chain: &str) -> Result<String, RegistryError> {
-        self.deps
-            .querier
-            .query_wasm_smart(
-                &self.registry_contract,
-                &QueryMsg::GetChannelFromChainPair {
-                    source_chain: on_chain.to_string(),
-                    destination_chain: for_chain.to_string(),
-                },
-            )
-            .map_err(|_e| RegistryError::ChainChannelLinkDoesNotExist {
-                source_chain: on_chain.to_string(),
-                destination_chain: for_chain.to_string(),
-            })
-    }
-
-    /// Returns a boolean specifying if a chain supports forwarding
-    /// Example: supports_forwarding("gaia") -> true
-    pub fn supports_forwarding(&self, chain: &str) -> Result<bool, RegistryError> {
-        self.deps
-            .querier
-            .query_wasm_smart(
-                &self.registry_contract,
-                &QueryMsg::HasPacketForwarding {
-                    chain: chain.to_string(),
-                },
-            )
-            .map_err(|_e| RegistryError::ImproperlyConfigured {})
-    }
-
-    /// Re-encodes the bech32 address for the receiving chain
-    /// Example: encode_addr_for_chain("osmo1...", "juno") -> "juno1..."
-    pub fn encode_addr_for_chain(&self, addr: &str, chain: &str) -> Result<String, RegistryError> {
-        let (_, data, variant) = bech32::decode(addr).map_err(|e| RegistryError::Bech32Error {
-            action: "decoding".into(),
-            addr: addr.into(),
-            source: e,
-        })?;
-
-        let response: String = self.deps.querier.query_wasm_smart(
-            &self.registry_contract,
-            &QueryMsg::GetBech32PrefixFromChainName {
-                chain_name: chain.to_string(),
-            },
-        )?;
-
-        let receiver =
-            bech32::encode(&response, data, variant).map_err(|e| RegistryError::Bech32Error {
-                action: "encoding".into(),
-                addr: addr.into(),
-                source: e,
-            })?;
-
-        Ok(receiver)
-    }
-
-    /// Get the bech32 prefix for the given chain
-    /// Example: get_bech32_prefix("osmosis") -> "osmo"
-    pub fn get_bech32_prefix(&self, chain: &str) -> Result<String, RegistryError> {
-        self.debug(format!("Getting prefix for chain: {chain}"));
-        let prefix: String = self
-            .deps
-            .querier
-            .query_wasm_smart(
-                &self.registry_contract,
-                &QueryMsg::GetBech32PrefixFromChainName {
-                    chain_name: chain.to_string(),
-                },
-            )
-            .map_err(|e| {
-                self.debug(format!("Got error: {e}"));
-                RegistryError::Bech32PrefixDoesNotExist {
-                    chain: chain.into(),
-                }
-            })?;
-        if prefix.is_empty() {
-            return Err(RegistryError::Bech32PrefixDoesNotExist {
-                chain: chain.into(),
-            });
-        }
-        Ok(prefix)
-    }
-
-    /// Get the chain that uses a bech32 prefix. If more than one chain uses the
-    /// same prefix, return an error
-    ///
-    /// Example: get_chain_for_bech32_prefix("osmo") -> "osmosis"
-    pub fn get_chain_for_bech32_prefix(&self, prefix: &str) -> Result<String, RegistryError> {
-        self.deps
-            .querier
-            .query_wasm_smart(
-                &self.registry_contract,
-                &QueryMsg::GetChainNameFromBech32Prefix {
-                    prefix: prefix.to_lowercase(),
-                },
-            )
-            .map_err(RegistryError::Std)
-    }
-
-    /// Returns the IBC path the denom has taken to get to the current chain
-    /// Example: unwrap_denom_path("ibc/0A...") -> [{"local_denom":"ibc/0A","on":"osmosis","via":"channel-17"},{"local_denom":"ibc/1B","on":"middle_chain","via":"channel-75"},{"local_denom":"token0","on":"source_chain","via":null}
-    pub fn unwrap_denom_path(&self, denom: &str) -> Result<Vec<MultiHopDenom>, RegistryError> {
-        self.debug(format!("Unwrapping denom {denom}"));
-
-        let mut current_chain = CONTRACT_CHAIN.to_string(); // The initial chain is always the contract chain
-
-        // Check that the denom is an IBC denom
-        if !denom.starts_with("ibc/") {
-            return Ok(vec![MultiHopDenom {
-                local_denom: denom.to_string(),
-                on: Chain(current_chain),
-                via: None,
-            }]);
-        }
-
-        // Get the denom trace
-        let res = proto::QueryDenomTraceRequest {
-            hash: denom.to_string(),
-        }
-        .query(&self.deps.querier)
-        .map_err(|_| RegistryError::InvalidDenomTrace {
-            error: format!("Cannot find denom trace for {denom}"),
-        })?;
-
-        let proto::DenomTrace { path, base_denom } = match res.denom_trace {
-            Some(denom_trace) => Ok(denom_trace),
-            None => Err(RegistryError::NoDenomTrace {
-                denom: denom.into(),
-            }),
-        }?;
-
-        self.debug(format!("procesing denom trace {path}"));
-        // Let's iterate over the parts of the denom trace and extract the
-        // chain/channels into a more useful structure: MultiHopDenom
-        let mut hops: Vec<MultiHopDenom> = vec![];
-        let mut rest: &str = &path;
-        let parts = path.split('/');
-
-        for chunk in &parts.chunks(2) {
-            let Some((port, channel)) = chunk.take(2).collect_tuple() else {
-                return Err(RegistryError::InvalidDenomTracePath{ path: path.clone(), denom: denom.into() });
-            };
-
-            // Check that the port is "transfer"
-            if port != TRANSFER_PORT {
-                return Err(RegistryError::InvalidTransferPort { port: port.into() });
-            }
-
-            // Check that the channel is valid
-            let full_trace = rest.to_owned() + "/" + &base_denom;
-            hops.push(MultiHopDenom {
-                local_denom: hash_denom_trace(&full_trace),
-                on: Chain(current_chain.clone().to_string()),
-                via: Some(ChannelId::new(channel)?),
-            });
-
-            current_chain = self.get_connected_chain(&current_chain, channel)?;
-            rest = rest
-                .trim_start_matches(&format!("{port}/{channel}"))
-                .trim_start_matches('/'); // hops other than first and last will have this slash
-        }
-
-        hops.push(MultiHopDenom {
-            local_denom: base_denom,
-            on: Chain(current_chain),
-            via: None,
-        });
-
-        Ok(hops)
-    }
-
-    pub fn get_native_chain(&self, denom: &str) -> Result<Chain, RegistryError> {
-        let hops = self.unwrap_denom_path(denom)?;
-        self.debug(format!("hops: {hops:?}"));
-        // verify that the last hop is native
-        let last_hop = hops.last().ok_or(RegistryError::NoDenomTrace {
-            denom: denom.into(),
-        })?;
-        if last_hop.via.is_some() {
-            return Err(RegistryError::InvalidDenomTrace {
-                error: format!("Path {hops:?} is not properly formatted"),
-            });
-        }
-        Ok(hops.last().unwrap().on.clone())
-    }
-
-    /// Returns an IBC MsgTransfer that with a packet forward middleware memo
-    /// that will send the coin back to its original chain and then to the
-    /// receiver in `into_chain`.
-    ///
-    /// If the receiver `into_chain` is not specified, we assume the receiver is
-    /// the current chain (where the the registries are hosted and the denom
-    /// original denom exists)
-    ///
-    /// `own_addr` must the the address of the contract that is calling this
-    /// function.
-    ///
-    /// `block_time` is the current block time. This is needed to calculate the
-    /// timeout timestamp.
-    #[allow(clippy::too_many_arguments)]
-    pub fn unwrap_coin_into(
-        &self,
-        coin: Coin,
-        receiver_addr: String,
-        into_chain: Option<&str>,
-        own_addr: String,
-        block_time: Timestamp,
-        first_transfer_memo: String,
-        receiver_callback: Option<Callback>,
-        skip_forwarding_check: bool,
-    ) -> Result<proto::MsgTransfer, RegistryError> {
-        // Calculate the path that this coin took to get to the current chain.
-        // Each element in the path is an IBC hop.
-        let path: Vec<MultiHopDenom> = self.unwrap_denom_path(&coin.denom)?;
-        self.deps
-            .api
-            .debug(&format!("Generating unwrap transfer message for: {path:?}"));
-
-        // Validate Path
-        if path.is_empty() {
-            return Err(RegistryError::InvalidDenomTracePath {
-                path: format!("{path:?}"),
-                denom: coin.denom,
-            });
-        }
-
-        // Define useful variables
-        let current_chain = path[0].on.clone();
-        let first_channel = path[0].via.clone();
-
-        let coin_type = if path.len() == 1 {
-            CoinType::Native
-        } else {
-            CoinType::Ibc
-        };
-
-        if coin_type.is_native() && first_channel.is_some() {
-            // Validate that the first channel is None for paths of len() == 1
-            // This is a redundante safety check in case of a bug in unwrap_denom_path
-            return Err(RegistryError::InvalidDenomTracePath {
-                path: format!("{path:?}"),
-                denom: coin.denom,
-            });
-        };
-
-        // default the receiver chain to the current chain if it isn't provided
-        let receiver_chain = match into_chain {
-            Some(chain) => chain,
-            None => current_chain.as_ref(),
-        };
-        // normalize it
-        let receiver_chain: &str = &receiver_chain.to_lowercase();
-
-        // If the token we're sending is native, we need the receiver to be
-        // different than the origin chain. Otherwise, we will try to make an
-        // ibc transfer to the same chain and it will fail. This may be possible
-        // in the future when we have IBC localhost channels
-        if coin_type.is_native() && current_chain.as_ref() == receiver_chain {
-            return Err(RegistryError::InvalidHopSameChain {
-                chain: receiver_chain.into(),
-            });
-        }
-
-        // validate the receiver matches the chain
-        let receiver_prefix = self.get_bech32_prefix(receiver_chain)?;
-        if receiver_addr[..receiver_prefix.len()] != receiver_prefix {
-            return Err(RegistryError::InvalidReceiverPrefix {
-                receiver: receiver_addr,
-                chain: receiver_chain.into(),
-            });
-        }
-
-        // Define the data to be used in the IBC MsgTransfer.
-
-        // If the coin is native, the ibc transfer needs to be sent to the
-        // receiver. Otherwise, it needs to be sent to the channel we received
-        // it from
-        let first_transfer_chain = match coin_type {
-            CoinType::Native => receiver_chain,
-            CoinType::Ibc => path[1].on.as_ref(), // Non native coins always have a path of len > 1 per definition
-        };
-
-        // encode the receiver address for the first chain
-        let first_receiver = self.encode_addr_for_chain(&receiver_addr, first_transfer_chain)?;
-        let first_channel = match first_channel {
-            Some(channel) => Ok::<String, RegistryError>(channel.as_ref().to_string()),
-            None => {
-                // If there is no first channel (i.e. coin_type.is_native() ==
-                // True), we get the channel from the registry
-                assert!(coin_type.is_native());
-                assert!(first_transfer_chain == receiver_chain);
-                let channel = self.get_channel(current_chain.as_ref(), first_transfer_chain)?;
-                Ok(channel)
-            }
-        }?;
-
-        // Generate the memo with the forwarding chain.
-
-        // remove the first hop from the path as it is the current chain
-        let path_iter = path.iter().skip(1);
-
-        // initialize mutable variables for the iteration
-        let mut next: Option<Box<Memo>> = None;
-        let mut prev_chain: &str = receiver_chain;
-        let mut callback = receiver_callback; // The last call should have the receiver callback
-
-        // Note that we iterate in reverse order. This is because the structure
-        // is nested and we build it from the inside out. We want the last hop
-        // to be the innermost memo.
-        for hop in path_iter.rev() {
-            self.debug(format!("processing hop: {hop:?}"));
-            // If the last hop is the same as the receiver chain, we don't need
-            // to forward anymore. The via.is_none() check is important because
-            // we could have a hop be the receiver chain without being the one
-            // the coin is native to.
-            if hop.via.is_none() && hop.on.as_ref() == receiver_chain {
-                continue;
-            }
-
-            // To unwrap we use the channel through which the token came, but once on the native
-            // chain, we need to get the channel that connects that chain to the receiver.
-            let channel = match &hop.via {
-                Some(channel) => channel.to_owned(),
-                None => ChannelId(self.get_channel(prev_chain, hop.on.as_ref())?),
-            };
-
-            self.debug(format!(
-                "checking that: {:?} supports pfm (into {:?})",
-                hop.on.as_ref(),
-                prev_chain
-            ));
-            if !skip_forwarding_check && !self.supports_forwarding(hop.on.as_ref())? {
-                return Err(RegistryError::ForwardingUnsopported {
-                    chain: hop.on.as_ref().into(),
-                });
-            }
-
-            // The next memo wraps the previous one
-            next = Some(Box::new(Memo {
-                forward: Some(ForwardingMemo {
-                    receiver: self.encode_addr_for_chain(&receiver_addr, prev_chain)?,
-                    port: TRANSFER_PORT.to_string(),
-                    channel,
-                    next: if next.is_none() && callback.is_some() {
-                        // If there is no next, this means we are on the last
-                        // forward. We can then default to a memo with only the
-                        // receiver callback.
-                        Some(Box::new(Memo {
-                            forward: None,
-                            callback, // The callback may be None
-                        }))
-                    } else {
-                        next
-                    },
-                }),
-                callback: None,
-            }));
-            prev_chain = hop.on.as_ref();
-            callback = None;
-        }
-
-        // If no memo was generated, we still want to include the user provided
-        // callback. This is not necessary if next.is_some() because the
-        // callback would already have been included.
-        if next.is_none() {
-            next = Some(Box::new(Memo {
-                forward: None,
-                callback, // The callback may also be None
-            }));
-        }
-
-        // Serialize the memo
-        let forward = serde_json_wasm::to_string(&next)?;
-
-        // If the user provided a memo to be included in the transfer, we merge
-        // it with the calculated one. By using the provided memo as a base,
-        // only its forward key would be overwritten if it existed
-        let memo = merge_json(&first_transfer_memo, &forward)?;
-        let ts = block_time.plus_seconds(PACKET_LIFETIME);
-
-        // Cosmwasm's IBCMsg::Transfer  does not support memo.
-        // To build and send the packet properly, we need to send it using stargate messages.
-        // See https://github.com/CosmWasm/cosmwasm/issues/1477
-        let ibc_transfer_msg = proto::MsgTransfer {
-            source_port: TRANSFER_PORT.to_string(),
-            source_channel: first_channel,
-            token: Some(coin.into()),
-            sender: own_addr,
-            receiver: first_receiver,
-            timeout_height: None,
-            timeout_timestamp: Some(ts.nanos()),
-            memo,
-        };
-
-        self.debug(format!("MsgTransfer: {ibc_transfer_msg:?}"));
-
-        Ok(ibc_transfer_msg)
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    #[test]
-    fn test_channel_id() {
-        assert!(ChannelId::validate("channel-0"));
-        assert!(ChannelId::validate("channel-1"));
-        assert!(ChannelId::validate("channel-1234567890"));
-        assert!(!ChannelId::validate("channel-"));
-        assert!(!ChannelId::validate("channel-abc"));
-        assert!(!ChannelId::validate("channel-1234567890a"));
-        assert!(!ChannelId::validate("channel-1234567890-"));
-        assert!(!ChannelId::validate("channel-1234567890-abc"));
-        assert!(!ChannelId::validate("channel-1234567890-1234567890"));
-    }
-
-    #[test]
-    fn test_forwarding_memo() {
-        let memo = Memo {
-            forward: Some(ForwardingMemo {
-                receiver: "receiver".to_string(),
-                port: "port".to_string(),
-                channel: ChannelId::new("channel-0").unwrap(),
-                next: Some(Box::new(Memo {
-                    forward: Some(ForwardingMemo {
-                        receiver: "receiver2".to_string(),
-                        port: "port2".to_string(),
-                        channel: ChannelId::new("channel-1").unwrap(),
-                        next: None,
-                    }),
-                    callback: None,
-                })),
-            }),
-            callback: None,
-        };
-        let encoded = serde_json_wasm::to_string(&memo).unwrap();
-        let decoded: Memo = serde_json_wasm::from_str(&encoded).unwrap();
-        assert_eq!(memo, decoded);
-        assert_eq!(
-            encoded,
-            r#"{"forward":{"receiver":"receiver","port":"port","channel":"channel-0","next":{"forward":{"receiver":"receiver2","port":"port2","channel":"channel-1"}}}}"#
-        )
-    }
-
-    #[test]
-    fn test_derive_wasmhooks_sender() {
-        let test_cases = vec![
-            (
-                "channel-0",
-                "cosmos1tfejvgp5yzd8ypvn9t0e2uv2kcjf2laa8upya8",
-                "osmo",
-                "osmo1sguz3gtyl2tjsdulwxmtprd68xtd43yyep6g5c554utz642sr8rqcgw0q6",
-            ),
-            (
-                "channel-1",
-                "cosmos1tfejvgp5yzd8ypvn9t0e2uv2kcjf2laa8upya8",
-                "osmo",
-                "osmo1svnare87kluww5hnltv24m4dg72hst0qqwm5xslsvnwd22gftcussaz5l7",
-            ),
-            (
-                "channel-0",
-                "osmo12smx2wdlyttvyzvzg54y2vnqwq2qjateuf7thj",
-                "osmo",
-                "osmo1vz8evs4ek3vnz4f8wy86nw9ayzn67y28vtxzjgxv6achc4pa8gesqldfz0",
-            ),
-            (
-                "channel-0",
-                "osmo12smx2wdlyttvyzvzg54y2vnqwq2qjateuf7thj",
-                "cosmos",
-                "cosmos1vz8evs4ek3vnz4f8wy86nw9ayzn67y28vtxzjgxv6achc4pa8ges4z434f",
-            ),
-        ];
-
-        for tc in test_cases {
-            assert!(derive_wasmhooks_sender(tc.0, tc.1, tc.2).is_ok());
-            assert_eq!(derive_wasmhooks_sender(tc.0, tc.1, tc.2).unwrap(), tc.3);
-        }
-    }
-}
diff --git a/cosmwasm/packages/registry/src/utils.rs b/cosmwasm/packages/registry/src/utils.rs
deleted file mode 100644
index 6ee785612..000000000
--- a/cosmwasm/packages/registry/src/utils.rs
+++ /dev/null
@@ -1,87 +0,0 @@
-use std::collections::BTreeMap;
-
-use cosmwasm_std::StdError;
-use serde_cw_value::Value;
-
-use crate::RegistryError;
-
-pub fn stringify(json: &serde_cw_value::Value) -> Result<String, RegistryError> {
-    serde_json_wasm::to_string(&json).map_err(|_| {
-        RegistryError::Std(StdError::generic_err(
-            "invalid value".to_string(), // This shouldn't happen.
-        ))
-    })
-}
-
-pub fn extract_map(json: Value) -> Result<BTreeMap<Value, Value>, RegistryError> {
-    match json {
-        serde_cw_value::Value::Map(m) => Ok(m),
-        _ => Err(RegistryError::InvalidJson {
-            error: "invalid json: expected an object".to_string(),
-            json: stringify(&json)?,
-        }),
-    }
-}
-
-pub fn merge_json(first: &str, second: &str) -> Result<String, RegistryError> {
-    // replacing some potential empty values we want to accept with an empty object
-    let first = match first {
-        "" => "{}",
-        "null" => "{}",
-        _ => first,
-    };
-    let second = match second {
-        "" => "{}",
-        "null" => "{}",
-        _ => second,
-    };
-
-    let first_val: Value = serde_json_wasm::from_str(first)?;
-    let second_val: Value = serde_json_wasm::from_str(second)?;
-
-    // checking potential "empty" values we want to accept
-
-    let mut first_map = extract_map(first_val)?;
-    let second_map = extract_map(second_val)?;
-
-    first_map.extend(second_map);
-
-    stringify(&Value::Map(first_map))
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_merge_json() {
-        // some examples
-        assert_eq!(
-            merge_json(r#"{"a": 1}"#, r#"{"b": 2}"#).unwrap(),
-            r#"{"a":1,"b":2}"#
-        );
-        assert_eq!(
-            merge_json(r#"{"a": 1}"#, r#"{"a": 2}"#).unwrap(),
-            r#"{"a":2}"#
-        );
-        assert_eq!(
-            merge_json(r#"{"a": 1}"#, r#"{"a": {"b": 2}}"#).unwrap(),
-            r#"{"a":{"b":2}}"#
-        );
-        assert_eq!(
-            merge_json(r#"{"a": {"b": 2}}"#, r#"{"a": 1}"#).unwrap(),
-            r#"{"a":1}"#
-        );
-        assert_eq!(
-            merge_json(r#"{"a": {"b": 2}}"#, r#"{"a": {"c": 3}}"#).unwrap(),
-            r#"{"a":{"c":3}}"#
-        );
-        // Empties
-        assert_eq!(merge_json(r#"{"a": 1}"#, r#""#).unwrap(), r#"{"a":1}"#);
-        assert_eq!(merge_json(r#""#, r#"{"a": 1}"#).unwrap(), r#"{"a":1}"#);
-        assert_eq!(merge_json(r#"{"a": 1}"#, r#"null"#).unwrap(), r#"{"a":1}"#);
-        assert_eq!(merge_json(r#"null"#, r#"{"a": 1}"#).unwrap(), r#"{"a":1}"#);
-        assert_eq!(merge_json(r#"{"a": 1}"#, r#"{}"#).unwrap(), r#"{"a":1}"#);
-        assert_eq!(merge_json(r#"{}"#, r#"{"a": 1}"#).unwrap(), r#"{"a":1}"#);
-    }
-}
diff --git a/tests/localosmosis/docker-compose.yml b/tests/localosmosis/docker-compose.yml
index 56cf57821..f80443a64 100644
--- a/tests/localosmosis/docker-compose.yml
+++ b/tests/localosmosis/docker-compose.yml
@@ -23,8 +23,8 @@ services:
     command:
       - $STATE
     ports:
-      - 26657:26657
-      - 1317:1317
+      - 26658:26657
+      - 1318:1317
       - 9090:9090
       - 9091:9091
       - 6060:6060
diff --git a/tests/localosmosis/scripts/setup.sh b/tests/localosmosis/scripts/setup.sh
index fbef3b229..617a77f0f 100755
--- a/tests/localosmosis/scripts/setup.sh
+++ b/tests/localosmosis/scripts/setup.sh
@@ -26,7 +26,7 @@ edit_genesis () {
 
     # Update staking module
     dasel put -t string -f $GENESIS '.app_state.staking.params.bond_denom' -v 'uosmo'
-    dasel put -t string -f $GENESIS '.app_state.staking.params.unbonding_time' -v '240s'
+    # dasel put -t string -f $GENESIS '.app_state.staking.params.unbonding_time' -v '240s'
 
     # Update bank module
     dasel put -t string -f $GENESIS '.app_state.bank.denom_metadata.[].description' -v 'Registered denom uion for localosmosis testing'
@@ -49,23 +49,23 @@ edit_genesis () {
     dasel put -t string -f $GENESIS '.app_state.crisis.constant_fee.denom' -v 'uosmo'
 
     # Update gov module
-    dasel put -t string -f $GENESIS '.app_state.gov.voting_params.voting_period' -v '60s'
+    # dasel put -t string -f $GENESIS '.app_state.gov.voting_params.voting_period' -v '60s'
     dasel put -t string -f $GENESIS '.app_state.gov.params.min_deposit.[0].denom' -v 'uosmo'
 
     # Update epochs module
-    dasel put -t string -f $GENESIS '.app_state.epochs.epochs.[1].duration' -v "60s"
+    # dasel put -t string -f $GENESIS '.app_state.epochs.epochs.[1].duration' -v "60s"
 
     # Update poolincentives module
-    dasel put -t string -f $GENESIS '.app_state.poolincentives.lockable_durations.[0]' -v "120s"
-    dasel put -t string -f $GENESIS '.app_state.poolincentives.lockable_durations.[1]' -v "180s"
-    dasel put -t string -f $GENESIS '.app_state.poolincentives.lockable_durations.[2]' -v "240s"
+    # dasel put -t string -f $GENESIS '.app_state.poolincentives.lockable_durations.[0]' -v "120s"
+    # dasel put -t string -f $GENESIS '.app_state.poolincentives.lockable_durations.[1]' -v "180s"
+    # dasel put -t string -f $GENESIS '.app_state.poolincentives.lockable_durations.[2]' -v "240s"
     dasel put -t string -f $GENESIS '.app_state.poolincentives.params.minted_denom' -v "uosmo"
 
     # Update incentives module
-    dasel put -t string -f $GENESIS '.app_state.incentives.lockable_durations.[0]' -v "1s"
-    dasel put -t string -f $GENESIS '.app_state.incentives.lockable_durations.[1]' -v "120s"
-    dasel put -t string -f $GENESIS '.app_state.incentives.lockable_durations.[2]' -v "180s"
-    dasel put -t string -f $GENESIS '.app_state.incentives.lockable_durations.[3]' -v "240s"
+    # dasel put -t string -f $GENESIS '.app_state.incentives.lockable_durations.[0]' -v "1s"
+    # dasel put -t string -f $GENESIS '.app_state.incentives.lockable_durations.[1]' -v "120s"
+    # dasel put -t string -f $GENESIS '.app_state.incentives.lockable_durations.[2]' -v "180s"
+    # dasel put -t string -f $GENESIS '.app_state.incentives.lockable_durations.[3]' -v "240s"
     dasel put -t string -f $GENESIS '.app_state.incentives.params.distr_epoch_identifier' -v "hour"
 
     # Update mint module
