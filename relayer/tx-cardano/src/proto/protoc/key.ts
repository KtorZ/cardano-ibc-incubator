/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: key.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace key {
    export class AddKeyRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key_name?: string;
            chain_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key_name" in data && data.key_name != undefined) {
                    this.key_name = data.key_name;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
            }
        }
        get key_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            key_name?: string;
            chain_id?: string;
        }): AddKeyRequest {
            const message = new AddKeyRequest({});
            if (data.key_name != null) {
                message.key_name = data.key_name;
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            return message;
        }
        toObject() {
            const data: {
                key_name?: string;
                chain_id?: string;
            } = {};
            if (this.key_name != null) {
                data.key_name = this.key_name;
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_name.length)
                writer.writeString(1, this.key_name);
            if (this.chain_id.length)
                writer.writeString(2, this.chain_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddKeyRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AddKeyRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key_name = reader.readString();
                        break;
                    case 2:
                        message.chain_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AddKeyRequest {
            return AddKeyRequest.deserialize(bytes);
        }
    }
    export class AddKeyResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
            mnemonic?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("mnemonic" in data && data.mnemonic != undefined) {
                    this.mnemonic = data.mnemonic;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get mnemonic() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set mnemonic(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            address?: string;
            mnemonic?: string;
        }): AddKeyResponse {
            const message = new AddKeyResponse({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.mnemonic != null) {
                message.mnemonic = data.mnemonic;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                mnemonic?: string;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.mnemonic != null) {
                data.mnemonic = this.mnemonic;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (this.mnemonic.length)
                writer.writeString(2, this.mnemonic);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddKeyResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AddKeyResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        message.mnemonic = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AddKeyResponse {
            return AddKeyResponse.deserialize(bytes);
        }
    }
    export class DeleteKeyRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key_name?: string;
            chain_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key_name" in data && data.key_name != undefined) {
                    this.key_name = data.key_name;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
            }
        }
        get key_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            key_name?: string;
            chain_id?: string;
        }): DeleteKeyRequest {
            const message = new DeleteKeyRequest({});
            if (data.key_name != null) {
                message.key_name = data.key_name;
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            return message;
        }
        toObject() {
            const data: {
                key_name?: string;
                chain_id?: string;
            } = {};
            if (this.key_name != null) {
                data.key_name = this.key_name;
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_name.length)
                writer.writeString(1, this.key_name);
            if (this.chain_id.length)
                writer.writeString(2, this.chain_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DeleteKeyRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DeleteKeyRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key_name = reader.readString();
                        break;
                    case 2:
                        message.chain_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DeleteKeyRequest {
            return DeleteKeyRequest.deserialize(bytes);
        }
    }
    export class DeleteKeyResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): DeleteKeyResponse {
            const message = new DeleteKeyResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DeleteKeyResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DeleteKeyResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DeleteKeyResponse {
            return DeleteKeyResponse.deserialize(bytes);
        }
    }
    export class ShowAddressRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key_name?: string;
            chain_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key_name" in data && data.key_name != undefined) {
                    this.key_name = data.key_name;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
            }
        }
        get key_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            key_name?: string;
            chain_id?: string;
        }): ShowAddressRequest {
            const message = new ShowAddressRequest({});
            if (data.key_name != null) {
                message.key_name = data.key_name;
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            return message;
        }
        toObject() {
            const data: {
                key_name?: string;
                chain_id?: string;
            } = {};
            if (this.key_name != null) {
                data.key_name = this.key_name;
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_name.length)
                writer.writeString(1, this.key_name);
            if (this.chain_id.length)
                writer.writeString(2, this.chain_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShowAddressRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShowAddressRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key_name = reader.readString();
                        break;
                    case 2:
                        message.chain_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ShowAddressRequest {
            return ShowAddressRequest.deserialize(bytes);
        }
    }
    export class ShowAddressResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            address?: string;
        }): ShowAddressResponse {
            const message = new ShowAddressResponse({});
            if (data.address != null) {
                message.address = data.address;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShowAddressResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShowAddressResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ShowAddressResponse {
            return ShowAddressResponse.deserialize(bytes);
        }
    }
    export class KeyExistRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key_name?: string;
            chain_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key_name" in data && data.key_name != undefined) {
                    this.key_name = data.key_name;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
            }
        }
        get key_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            key_name?: string;
            chain_id?: string;
        }): KeyExistRequest {
            const message = new KeyExistRequest({});
            if (data.key_name != null) {
                message.key_name = data.key_name;
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            return message;
        }
        toObject() {
            const data: {
                key_name?: string;
                chain_id?: string;
            } = {};
            if (this.key_name != null) {
                data.key_name = this.key_name;
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_name.length)
                writer.writeString(1, this.key_name);
            if (this.chain_id.length)
                writer.writeString(2, this.chain_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyExistRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyExistRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key_name = reader.readString();
                        break;
                    case 2:
                        message.chain_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KeyExistRequest {
            return KeyExistRequest.deserialize(bytes);
        }
    }
    export class KeyExistResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            exist?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("exist" in data && data.exist != undefined) {
                    this.exist = data.exist;
                }
            }
        }
        get exist() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set exist(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            exist?: boolean;
        }): KeyExistResponse {
            const message = new KeyExistResponse({});
            if (data.exist != null) {
                message.exist = data.exist;
            }
            return message;
        }
        toObject() {
            const data: {
                exist?: boolean;
            } = {};
            if (this.exist != null) {
                data.exist = this.exist;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.exist != false)
                writer.writeBool(1, this.exist);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyExistResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyExistResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.exist = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KeyExistResponse {
            return KeyExistResponse.deserialize(bytes);
        }
    }
    export class AddressInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key_name?: string;
            address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key_name" in data && data.key_name != undefined) {
                    this.key_name = data.key_name;
                }
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
            }
        }
        get key_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            key_name?: string;
            address?: string;
        }): AddressInfo {
            const message = new AddressInfo({});
            if (data.key_name != null) {
                message.key_name = data.key_name;
            }
            if (data.address != null) {
                message.address = data.address;
            }
            return message;
        }
        toObject() {
            const data: {
                key_name?: string;
                address?: string;
            } = {};
            if (this.key_name != null) {
                data.key_name = this.key_name;
            }
            if (this.address != null) {
                data.address = this.address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_name.length)
                writer.writeString(1, this.key_name);
            if (this.address.length)
                writer.writeString(2, this.address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddressInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AddressInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key_name = reader.readString();
                        break;
                    case 2:
                        message.address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AddressInfo {
            return AddressInfo.deserialize(bytes);
        }
    }
    export class ListAddressesRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            chain_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
            }
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            chain_id?: string;
        }): ListAddressesRequest {
            const message = new ListAddressesRequest({});
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            return message;
        }
        toObject() {
            const data: {
                chain_id?: string;
            } = {};
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.chain_id.length)
                writer.writeString(1, this.chain_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListAddressesRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListAddressesRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.chain_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListAddressesRequest {
            return ListAddressesRequest.deserialize(bytes);
        }
    }
    export class ListAddressesResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            addresses?: AddressInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("addresses" in data && data.addresses != undefined) {
                    this.addresses = data.addresses;
                }
            }
        }
        get addresses() {
            return pb_1.Message.getRepeatedWrapperField(this, AddressInfo, 1) as AddressInfo[];
        }
        set addresses(value: AddressInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            addresses?: ReturnType<typeof AddressInfo.prototype.toObject>[];
        }): ListAddressesResponse {
            const message = new ListAddressesResponse({});
            if (data.addresses != null) {
                message.addresses = data.addresses.map(item => AddressInfo.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                addresses?: ReturnType<typeof AddressInfo.prototype.toObject>[];
            } = {};
            if (this.addresses != null) {
                data.addresses = this.addresses.map((item: AddressInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.addresses.length)
                writer.writeRepeatedMessage(1, this.addresses, (item: AddressInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListAddressesResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListAddressesResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.addresses, () => pb_1.Message.addToRepeatedWrapperField(message, 1, AddressInfo.deserialize(reader), AddressInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListAddressesResponse {
            return ListAddressesResponse.deserialize(bytes);
        }
    }
    export class KeyFromKeyOrAddressRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            chain_id?: string;
            key_or_address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
                if ("key_or_address" in data && data.key_or_address != undefined) {
                    this.key_or_address = data.key_or_address;
                }
            }
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get key_or_address() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set key_or_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            chain_id?: string;
            key_or_address?: string;
        }): KeyFromKeyOrAddressRequest {
            const message = new KeyFromKeyOrAddressRequest({});
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            if (data.key_or_address != null) {
                message.key_or_address = data.key_or_address;
            }
            return message;
        }
        toObject() {
            const data: {
                chain_id?: string;
                key_or_address?: string;
            } = {};
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            if (this.key_or_address != null) {
                data.key_or_address = this.key_or_address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.chain_id.length)
                writer.writeString(1, this.chain_id);
            if (this.key_or_address.length)
                writer.writeString(2, this.key_or_address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyFromKeyOrAddressRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyFromKeyOrAddressRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.chain_id = reader.readString();
                        break;
                    case 2:
                        message.key_or_address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KeyFromKeyOrAddressRequest {
            return KeyFromKeyOrAddressRequest.deserialize(bytes);
        }
    }
    export class KeyFromKeyOrAddressResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key_name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key_name" in data && data.key_name != undefined) {
                    this.key_name = data.key_name;
                }
            }
        }
        get key_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            key_name?: string;
        }): KeyFromKeyOrAddressResponse {
            const message = new KeyFromKeyOrAddressResponse({});
            if (data.key_name != null) {
                message.key_name = data.key_name;
            }
            return message;
        }
        toObject() {
            const data: {
                key_name?: string;
            } = {};
            if (this.key_name != null) {
                data.key_name = this.key_name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_name.length)
                writer.writeString(1, this.key_name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyFromKeyOrAddressResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyFromKeyOrAddressResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key_name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KeyFromKeyOrAddressResponse {
            return KeyFromKeyOrAddressResponse.deserialize(bytes);
        }
    }
    export class RestoreKeyRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key_name?: string;
            chain_id?: string;
            mnemonic?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key_name" in data && data.key_name != undefined) {
                    this.key_name = data.key_name;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
                if ("mnemonic" in data && data.mnemonic != undefined) {
                    this.mnemonic = data.mnemonic;
                }
            }
        }
        get key_name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get mnemonic() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set mnemonic(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            key_name?: string;
            chain_id?: string;
            mnemonic?: string;
        }): RestoreKeyRequest {
            const message = new RestoreKeyRequest({});
            if (data.key_name != null) {
                message.key_name = data.key_name;
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            if (data.mnemonic != null) {
                message.mnemonic = data.mnemonic;
            }
            return message;
        }
        toObject() {
            const data: {
                key_name?: string;
                chain_id?: string;
                mnemonic?: string;
            } = {};
            if (this.key_name != null) {
                data.key_name = this.key_name;
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            if (this.mnemonic != null) {
                data.mnemonic = this.mnemonic;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_name.length)
                writer.writeString(1, this.key_name);
            if (this.chain_id.length)
                writer.writeString(2, this.chain_id);
            if (this.mnemonic.length)
                writer.writeString(3, this.mnemonic);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RestoreKeyRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RestoreKeyRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key_name = reader.readString();
                        break;
                    case 2:
                        message.chain_id = reader.readString();
                        break;
                    case 3:
                        message.mnemonic = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RestoreKeyRequest {
            return RestoreKeyRequest.deserialize(bytes);
        }
    }
    export class RestoreKeyResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            address?: string;
        }): RestoreKeyResponse {
            const message = new RestoreKeyResponse({});
            if (data.address != null) {
                message.address = data.address;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RestoreKeyResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RestoreKeyResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RestoreKeyResponse {
            return RestoreKeyResponse.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedKeyServiceService {
        static definition = {
            AddKey: {
                path: "/key.KeyService/AddKey",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: AddKeyRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => AddKeyRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: AddKeyResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => AddKeyResponse.deserialize(new Uint8Array(bytes))
            },
            ShowAddress: {
                path: "/key.KeyService/ShowAddress",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ShowAddressRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ShowAddressRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: ShowAddressResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => ShowAddressResponse.deserialize(new Uint8Array(bytes))
            },
            DeleteKey: {
                path: "/key.KeyService/DeleteKey",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: DeleteKeyRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => DeleteKeyRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: DeleteKeyResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => DeleteKeyResponse.deserialize(new Uint8Array(bytes))
            },
            KeyExist: {
                path: "/key.KeyService/KeyExist",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: KeyExistRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => KeyExistRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: KeyExistResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => KeyExistResponse.deserialize(new Uint8Array(bytes))
            },
            ListAddresses: {
                path: "/key.KeyService/ListAddresses",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ListAddressesRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ListAddressesRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: ListAddressesResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => ListAddressesResponse.deserialize(new Uint8Array(bytes))
            },
            KeyFromKeyOrAddress: {
                path: "/key.KeyService/KeyFromKeyOrAddress",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: KeyFromKeyOrAddressRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => KeyFromKeyOrAddressRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: KeyFromKeyOrAddressResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => KeyFromKeyOrAddressResponse.deserialize(new Uint8Array(bytes))
            },
            RestoreKey: {
                path: "/key.KeyService/RestoreKey",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: RestoreKeyRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => RestoreKeyRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: RestoreKeyResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => RestoreKeyResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract AddKey(call: grpc_1.ServerUnaryCall<AddKeyRequest, AddKeyResponse>, callback: grpc_1.sendUnaryData<AddKeyResponse>): void;
        abstract ShowAddress(call: grpc_1.ServerUnaryCall<ShowAddressRequest, ShowAddressResponse>, callback: grpc_1.sendUnaryData<ShowAddressResponse>): void;
        abstract DeleteKey(call: grpc_1.ServerUnaryCall<DeleteKeyRequest, DeleteKeyResponse>, callback: grpc_1.sendUnaryData<DeleteKeyResponse>): void;
        abstract KeyExist(call: grpc_1.ServerUnaryCall<KeyExistRequest, KeyExistResponse>, callback: grpc_1.sendUnaryData<KeyExistResponse>): void;
        abstract ListAddresses(call: grpc_1.ServerUnaryCall<ListAddressesRequest, ListAddressesResponse>, callback: grpc_1.sendUnaryData<ListAddressesResponse>): void;
        abstract KeyFromKeyOrAddress(call: grpc_1.ServerUnaryCall<KeyFromKeyOrAddressRequest, KeyFromKeyOrAddressResponse>, callback: grpc_1.sendUnaryData<KeyFromKeyOrAddressResponse>): void;
        abstract RestoreKey(call: grpc_1.ServerUnaryCall<RestoreKeyRequest, RestoreKeyResponse>, callback: grpc_1.sendUnaryData<RestoreKeyResponse>): void;
    }
    export class KeyServiceClient extends grpc_1.makeGenericClientConstructor(UnimplementedKeyServiceService.definition, "KeyService", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        AddKey: GrpcUnaryServiceInterface<AddKeyRequest, AddKeyResponse> = (message: AddKeyRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<AddKeyResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<AddKeyResponse>, callback?: grpc_1.requestCallback<AddKeyResponse>): grpc_1.ClientUnaryCall => {
            return super.AddKey(message, metadata, options, callback);
        };
        ShowAddress: GrpcUnaryServiceInterface<ShowAddressRequest, ShowAddressResponse> = (message: ShowAddressRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<ShowAddressResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<ShowAddressResponse>, callback?: grpc_1.requestCallback<ShowAddressResponse>): grpc_1.ClientUnaryCall => {
            return super.ShowAddress(message, metadata, options, callback);
        };
        DeleteKey: GrpcUnaryServiceInterface<DeleteKeyRequest, DeleteKeyResponse> = (message: DeleteKeyRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<DeleteKeyResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<DeleteKeyResponse>, callback?: grpc_1.requestCallback<DeleteKeyResponse>): grpc_1.ClientUnaryCall => {
            return super.DeleteKey(message, metadata, options, callback);
        };
        KeyExist: GrpcUnaryServiceInterface<KeyExistRequest, KeyExistResponse> = (message: KeyExistRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<KeyExistResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<KeyExistResponse>, callback?: grpc_1.requestCallback<KeyExistResponse>): grpc_1.ClientUnaryCall => {
            return super.KeyExist(message, metadata, options, callback);
        };
        ListAddresses: GrpcUnaryServiceInterface<ListAddressesRequest, ListAddressesResponse> = (message: ListAddressesRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<ListAddressesResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<ListAddressesResponse>, callback?: grpc_1.requestCallback<ListAddressesResponse>): grpc_1.ClientUnaryCall => {
            return super.ListAddresses(message, metadata, options, callback);
        };
        KeyFromKeyOrAddress: GrpcUnaryServiceInterface<KeyFromKeyOrAddressRequest, KeyFromKeyOrAddressResponse> = (message: KeyFromKeyOrAddressRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<KeyFromKeyOrAddressResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<KeyFromKeyOrAddressResponse>, callback?: grpc_1.requestCallback<KeyFromKeyOrAddressResponse>): grpc_1.ClientUnaryCall => {
            return super.KeyFromKeyOrAddress(message, metadata, options, callback);
        };
        RestoreKey: GrpcUnaryServiceInterface<RestoreKeyRequest, RestoreKeyResponse> = (message: RestoreKeyRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<RestoreKeyResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<RestoreKeyResponse>, callback?: grpc_1.requestCallback<RestoreKeyResponse>): grpc_1.ClientUnaryCall => {
            return super.RestoreKey(message, metadata, options, callback);
        };
    }
}
